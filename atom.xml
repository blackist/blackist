<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>董亮亮的开发笔记</title>
  
  <subtitle>安卓和后台开发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blackist.org/"/>
  <updated>2019-10-01T11:40:16.069Z</updated>
  <id>https://blackist.org/</id>
  
  <author>
    <name>董亮亮</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://blackist.org/2019/10/05/java-hashmap-concurrenthashmap/"/>
    <id>https://blackist.org/2019/10/05/java-hashmap-concurrenthashmap/</id>
    <published>2019-10-05T11:37:29.000Z</published>
    <updated>2019-10-01T11:40:16.069Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>转载</strong> <a href="https://javadoop.com/post/hashmap" target="_blank" rel="noopener">https://javadoop.com/post/hashmap</a></p><p>今天发一篇”水文”，可能很多读者都会表示不理解，不过我想把它作为并发序列文章中不可缺少的一块来介绍。本来以为花不了多少时间的，不过最终还是投入了挺多时间来完成这篇文章的。</p><p>网上关于 HashMap 和 ConcurrentHashMap 的文章确实不少，不过缺斤少两的文章比较多，所以才想自己也写一篇，把细节说清楚说透，尤其像 Java8 中的 ConcurrentHashMap，大部分文章都说不清楚。终归是希望能降低大家学习的成本，不希望大家到处找各种不是很靠谱的文章，看完一篇又一篇，可是还是模模糊糊。</p><p>阅读建议：四节基本上可以进行独立阅读，建议初学者可按照 Java7 HashMap -&gt; Java7 ConcurrentHashMap -&gt; Java8 HashMap -&gt; Java8 ConcurrentHashMap 顺序进行阅读，可适当降低阅读门槛。</p><p>阅读前提：本文分析的是源码，所以至少读者要熟悉它们的接口使用，同时，对于并发，读者至少要知道 CAS、ReentrantLock、UNSAFE 操作这几个基本的知识，文中不会对这些知识进行介绍。Java8 用到了红黑树，不过本文不会进行展开，感兴趣的读者请自行查找相关资料。</p><a id="more"></a><h2 id="Java7-HashMap"><a href="#Java7-HashMap" class="headerlink" title="Java7 HashMap"></a>Java7 HashMap</h2><p>HashMap 是最简单的，一来我们非常熟悉，二来就是它不支持并发操作，所以源码也非常简单。</p><p>首先，我们用下面这张图来介绍 HashMap 的结构。</p><p><img src="http://pic.blackist.top/dev-201910011925-789.png" alt></p><blockquote><p>这个仅仅是示意图，因为没有考虑到数组要扩容的情况，具体的后面再说。</p></blockquote><p>大方向上，HashMap 里面是一个<strong>数组</strong>，然后数组中每个元素是一个<strong>单向链表</strong>。</p><p>上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</p><p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</p><p>loadFactor：负载因子，默认为 0.75。</p><p>threshold：扩容的阈值，等于 capacity * loadFactor</p><h3 id="put-过程分析"><a href="#put-过程分析" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><p>还是比较简单的，跟着代码走一遍吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当插入第一个元素的时候，需要先初始化数组大小</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">// 1. 求 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 2. 找到对应的数组下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，</span></span><br><span class="line">    <span class="comment">//    如果有，直接覆盖，put 方法返回旧值就结束了</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h4><p>在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证数组大小一定是 2 的 n 次方。</span></span><br><span class="line">    <span class="comment">// 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">// 计算扩容阈值：capacity * loadFactor</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 算是初始化数组吧</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity); <span class="comment">//ignore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。</p><h4 id="计算具体数组位置"><a href="#计算具体数组位置" class="headerlink" title="计算具体数组位置"></a>计算具体数组位置</h4><p>这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> hash, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> hash &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。</p><h4 id="添加节点到链表中"><a href="#添加节点到链表中" class="headerlink" title="添加节点到链表中"></a>添加节点到链表中</h4><p>找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的<strong>表头</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">// 扩容，后面会介绍一下</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">// 扩容以后，重新计算 hash 值</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 重新计算扩容后的新的下标</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往下看</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个很简单，其实就是将新值放到链表的表头，然后 size++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p><h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>前面我们看到，在插入新值的时候，如果<strong>当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素</strong>，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 将原来数组中的值迁移到新的更大的数组中</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p><p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。</p><h3 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 过程，get 过程是非常简单的。</p><ol><li>根据 key 计算 hash 值。</li><li>找到相应的数组下标：hash &amp; (length - 1)。</li><li>遍历该数组位置处的链表，直到找到相等(==或equals)的 key。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getEntry(key):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="comment">// 确定数组下标，然后从头开始遍历链表，直到找到为止</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java7-ConcurrentHashMap"><a href="#Java7-ConcurrentHashMap" class="headerlink" title="Java7 ConcurrentHashMap"></a>Java7 ConcurrentHashMap</h2><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。</p><p>整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为<strong>分段锁</strong>。注意，行文中，我很多地方用了“<strong>槽</strong>”来代表一个 segment。</p><p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p><p><img src="http://pic.blackist.top/dev-201910011926-996.png" alt></p><p><strong>concurrencyLevel</strong>：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p><p>再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>initialCapacity：初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。</p><p>loadFactor：负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4</span></span><br><span class="line">    <span class="comment">// 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值</span></span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// initialCapacity 是设置整个 map 初始的大小，</span></span><br><span class="line">    <span class="comment">// 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小</span></span><br><span class="line">    <span class="comment">// 如 initialCapacity 为 64，那么每个 Segment 或称之为"槽"可以分到 4 个</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="comment">// 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，</span></span><br><span class="line">    <span class="comment">// 插入一个元素不至于扩容，插入第二个的时候才会扩容</span></span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY; </span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Segment 数组，</span></span><br><span class="line">    <span class="comment">// 并创建数组的第一个元素 segment[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    <span class="comment">// 往数组写入 segment[0]</span></span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化完成，我们得到了一个 Segment 数组。</p><p>我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：</p><ul><li>Segment 数组长度为 16，不可以扩容</li><li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li><li>这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍</li><li>当前 segmentShift 的值为 32 - 4 = 28，segmentMask 为 16 - 1 = 15，姑且把它们简单翻译为<strong>移位数</strong>和<strong>掩码</strong>，这两个值马上就会用到</li></ul><h3 id="put-过程分析-1"><a href="#put-过程分析-1" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><p>我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 1. 计算 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 2. 根据 hash 值找到 Segment 数组中的位置 j</span></span><br><span class="line">    <span class="comment">//    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下高 4 位，</span></span><br><span class="line">    <span class="comment">//    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的高 4 位，也就是槽的数组下标</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">// 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，</span></span><br><span class="line">    <span class="comment">// ensureSegment(j) 对 segment[j] 进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">// 3. 插入新值到 槽 s 中</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p><p>Segment 内部是由 <strong>数组+链表</strong> 组成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在往该 segment 写入前，需要先获取该 segment 的独占锁</span></span><br><span class="line">    <span class="comment">//    先看主流程，后面还会具体介绍这部分内容</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这个是 segment 内部的数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 再利用 hash 值，求应该放置的数组下标</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// first 是数组该位置处的链表的表头</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        <span class="comment">// 覆盖旧值</span></span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 继续顺着链表走</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。</span></span><br><span class="line">                <span class="comment">// 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果超过了该 segment 的阈值，这个 segment 需要扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node); <span class="comment">// 扩容后面也会具体分析</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 没有达到阈值，将 node 放到数组 tab 的 index 位置，</span></span><br><span class="line">                    <span class="comment">// 其实就是将新的节点设置成原链表的表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。</p><p>到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。</p><h4 id="初始化槽-ensureSegment"><a href="#初始化槽-ensureSegment" class="headerlink" title="初始化槽: ensureSegment"></a>初始化槽: ensureSegment</h4><p>ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。</p><p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里看到为什么之前要初始化 segment[0] 了，</span></span><br><span class="line">        <span class="comment">// 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]</span></span><br><span class="line">        <span class="comment">// 为什么要用“当前”，因为 segment[0] 可能早就扩容过了</span></span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化 segment[k] 内部的数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == <span class="keyword">null</span>) &#123; <span class="comment">// 再次检查一遍该槽是否被其他线程初始化了。</span></span><br><span class="line">          </span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。</p><blockquote><p>我没搞懂这里为什么要搞一个 while 循环，CAS 失败不就代表有其他线程成功了吗，为什么要再进行判断？</p><p>感谢评论区的<strong>李子木</strong>，如果当前线程 CAS 失败，这里的 while 循环是为了将 seg 赋值返回。</p></blockquote><h4 id="获取写入锁-scanAndLockForPut"><a href="#获取写入锁-scanAndLockForPut" class="headerlink" title="获取写入锁: scanAndLockForPut"></a>获取写入锁: scanAndLockForPut</h4><p>前面我们看到，在往某个 segment 中 put 的时候，首先会调用  node = tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p><p>下面我们来具体分析这个方法中是怎么控制加锁的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环获取锁</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    <span class="comment">// 进到这里说明数组该位置的链表是空的，没有任何元素</span></span><br><span class="line">                    <span class="comment">// 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 顺着链表往下走</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁</span></span><br><span class="line">        <span class="comment">//    lock() 是阻塞方法，直到获取锁后返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 <span class="comment">// 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头</span></span><br><span class="line">                 <span class="comment">//     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法</span></span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p><p>这个方法就是看似复杂，但是其实就是做了一件事，那就是<strong>获取该 segment 的独占锁</strong>，如果需要的话顺便实例化了一下 node。</p><h4 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容: rehash"></a>扩容: rehash</h4><p>重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry\<k,v>[] 进行扩容，扩容后，容量为原来的 2 倍。</k,v></p><p>首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。</p><p>该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 2 倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// e 是链表的第一个元素</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算应该放置在新数组中的位置，</span></span><br><span class="line">            <span class="comment">// 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">// 该位置处只有一个元素，那比较好办</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// e 是链表表头</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="comment">// idx 是当前链表的头结点 e 的新位置</span></span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// 下面的操作是处理 lastRun 之前的节点，</span></span><br><span class="line">                <span class="comment">//    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢？</p><p>仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。</p><p>我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。<strong>不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆</strong>。</p><h3 id="get-过程分析-1"><a href="#get-过程分析-1" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 来说，get 真的不要太简单。</p><ol><li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li><li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li><li>到这里是链表了，顺着链表进行查找即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 1. hash 值</span></span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 2. 根据 hash 找到对应的 segment</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. 找到segment 内部数组相应位置的链表，遍历</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并发问题分析"><a href="#并发问题分析" class="headerlink" title="并发问题分析"></a>并发问题分析</h3><p>现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。</p><p>添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。</p><ol><li><p>put 操作的线程安全性。</p><ol><li>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</li><li>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</li><li>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</li></ol></li><li><p>remove 操作的线程安全性。</p><p>remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。</p><p>get 操作需要遍历链表，但是 remove 操作会”破坏”链表。</p><p>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。</p><p>如果 remove 先破坏了一个节点，分两种情况考虑。  1、如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。</p></li></ol><h2 id="Java8-HashMap"><a href="#Java8-HashMap" class="headerlink" title="Java8 HashMap"></a>Java8 HashMap</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 <strong>数组+链表+红黑树</strong> 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 <strong>O(n)</strong>。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 <strong>O(logN)</strong>。</p><p>来一张图简单示意一下吧：</p><p><img src="http://pic.blackist.top/dev-201910011927-365.png" alt></p><blockquote><p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p></blockquote><p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p><p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 <strong>Node</strong>，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong>TreeNode</strong>。</p><p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p><h3 id="put-过程分析-2"><a href="#put-过程分析-2" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span></span><br><span class="line"><span class="comment">// 第四个参数 evict 我们这里不关心</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span></span><br><span class="line">    <span class="comment">// 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 数组该位置有数据</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是"相等"，如果是，取出这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 到这里，说明数组该位置上是一个链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个</span></span><br><span class="line">                    <span class="comment">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在该链表中找到了"相等"的 key(== 或 equals)</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 此时 break，那么 e 为链表中[与要插入的新值的 key "相等"]的 node</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e!=null 说明存在旧值的key与要插入的key"相等"</span></span><br><span class="line">        <span class="comment">// 对于我们分析的put操作，下面这个 if 其实就是进行 "值覆盖"，然后返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p><h4 id="数组扩容-1"><a href="#数组扩容-1" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>resize() 方法用于<strong>初始化数组</strong>或<strong>数组扩容</strong>，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 对应数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数组大小扩大一倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 将阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用新的数组大小初始化新的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab; <span class="comment">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始遍历原数组，进行数据迁移。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果是红黑树，具体我们就不展开了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">// 这块是处理链表的情况，</span></span><br><span class="line">                    <span class="comment">// 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span></span><br><span class="line">                    <span class="comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第一条链表</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第二条链表的新的位置是 j + oldCap，这个很好理解</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-过程分析-2"><a href="#get-过程分析-2" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 来说，get 真的太简单了。</p><ol><li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li><li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li><li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li><li>遍历链表，直到找到相等(==或equals)的 key</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个节点是不是就是需要的</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 链表遍历</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java8-ConcurrentHashMap"><a href="#Java8-ConcurrentHashMap" class="headerlink" title="Java8 ConcurrentHashMap"></a>Java8 ConcurrentHashMap</h2><p>Java7 中实现的 ConcurrentHashMap 说实话还是比较复杂的，Java8 对 ConcurrentHashMap 进行了比较大的改动。建议读者可以参考 Java8 中 HashMap 相对于 Java7 HashMap 的改动，对于 ConcurrentHashMap，Java8 也引入了红黑树。</p><p><strong>说实话，Java8 ConcurrentHashMap 源码真心不简单，最难的在于扩容，数据迁移操作不容易看懂。</strong></p><p>我们先用一个示意图来描述下其结构：</p><p><img src="http://pic.blackist.top/dev-201910011927-521.png" alt></p><p>结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。</p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这构造函数里，什么都不干</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</p><p>sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。</p><p>如果你爱折腾，也可以看下另一个有三个参数的构造方法，这里我就不说了，大部分时候，我们会使用无参构造函数进行实例化，我们也按照这个思路来进行源码分析吧。</p><h3 id="put-过程分析-3"><a href="#put-过程分析-3" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><p>仔细地一行一行代码看下去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 得到 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 用于记录相应链表的长度</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果数组"空"，进行数组初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 初始化数组，后面会详细介绍</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找该 hash 值对应的数组下标，得到第一个节点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果数组该位置为空，</span></span><br><span class="line">            <span class="comment">//    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了</span></span><br><span class="line">            <span class="comment">//  如果 CAS 失败，那就是有并发操作，进到下一个循环就好了</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 到这里就是说，f 是该位置的头结点，而且不为空</span></span><br><span class="line">            </span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 获取数组该位置的头结点的监视器锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 头结点的 hash 值大于 0，说明是链表</span></span><br><span class="line">                        <span class="comment">// 用于累加，记录链表的长度</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果发现了"相等"的 key，判断是否要进行值覆盖，然后也就可以 break 了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 到了链表的最末端，将这个新值放到链表的最后面</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用红黑树的插值方法插入新节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span></span><br><span class="line">                    <span class="comment">// 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span></span><br><span class="line">                    <span class="comment">//    具体源码我们就不看了，扩容部分后面说</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put 的主流程看完了，但是至少留下了几个问题，第一个是初始化，第二个是扩容，第三个是帮助数据迁移，这些我们都会在后面进行一一介绍。</p><h4 id="初始化数组：initTable"><a href="#初始化数组：initTable" class="headerlink" title="初始化数组：initTable"></a>初始化数组：initTable</h4><p>这个比较简单，主要就是初始化一个<strong>合适大小</strong>的数组，然后会设置 sizeCtl。</p><p>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化的"功劳"被其他线程"抢去"了</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// DEFAULT_CAPACITY 默认初始容量是 16</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line"><span class="comment">// 初始化数组，长度为 16 或初始化时提供的长度</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">// 将这个数组赋值给 table，table 是 volatile 的</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 如果 n 为 16 的话，那么这里 sc = 12</span></span><br><span class="line">                    <span class="comment">// 其实就是 0.75 * n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 设置 sizeCtl 为 sc，我们就当是 12 吧</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表转红黑树-treeifyBin"><a href="#链表转红黑树-treeifyBin" class="headerlink" title="链表转红黑树: treeifyBin"></a>链表转红黑树: treeifyBin</h4><p>前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// MIN_TREEIFY_CAPACITY 为 64</span></span><br><span class="line">        <span class="comment">// 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            <span class="comment">// 后面我们再详细分析这个方法</span></span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// b 是头结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    <span class="comment">// 下面就是遍历链表，建立一颗红黑树</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将红黑树设置到数组相应位置中</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容：tryPresize"><a href="#扩容：tryPresize" class="headerlink" title="扩容：tryPresize"></a>扩容：tryPresize</h3><p>如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。</p><p>这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。</p><p>这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// 0.75 * n</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="comment">// 我没看懂 rs 的真正含义是什么，不过也关系不大</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span></span><br><span class="line">                <span class="comment">//    此时 nextTab 不为 null</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span><br><span class="line">            <span class="comment">//     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数</span></span><br><span class="line">            <span class="comment">//  调用 transfer 方法，此时 nextTab 参数为 null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。</p><p>所以，可能的操作就是执行 <strong>1 次 transfer(tab, null) + 多次 transfer(tab, nt)</strong>，这里怎么结束循环的需要看完 transfer 源码才清楚。</p><h4 id="数据迁移：transfer"><a href="#数据迁移：transfer" class="headerlink" title="数据迁移：transfer"></a>数据迁移：transfer</h4><p>下面这个方法有点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。</p><p>虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。</p><p>此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。</p><p>阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是<strong>步长</strong>，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。</p><p>第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后<strong>从后往前</strong>的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// stride 在单核下直接等于 n，多核模式下为 (n&gt;&gt;&gt;3)/NCPU，最小值是 16</span></span><br><span class="line">    <span class="comment">// stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，</span></span><br><span class="line">    <span class="comment">//   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 nextTab 为 null，先进行一次初始化</span></span><br><span class="line">    <span class="comment">//    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null</span></span><br><span class="line">    <span class="comment">//   之后参与迁移的线程调用此方法时，nextTab 不会为 null</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 容量翻倍</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nextTable 是 ConcurrentHashMap 中的属性</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ForwardingNode 翻译过来就是正在被迁移的 Node</span></span><br><span class="line">    <span class="comment">// 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED</span></span><br><span class="line">    <span class="comment">// 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，</span></span><br><span class="line">    <span class="comment">//    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了</span></span><br><span class="line">    <span class="comment">//    所以它其实相当于是一个标志。</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// i 是位置索引，bound 是边界，注意是从后往前</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面这个 while 真的是不好理解</span></span><br><span class="line">        <span class="comment">// advance 为 true 表示可以进行下一个位置的迁移了</span></span><br><span class="line">        <span class="comment">//   简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将 transferIndex 值赋给 nextIndex</span></span><br><span class="line">            <span class="comment">// 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">// 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">// 所有的迁移操作已经完成</span></span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 将新的 nextTab 赋值给 table 属性，完成迁移</span></span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">// 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span></span><br><span class="line">            <span class="comment">// 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，</span></span><br><span class="line">            <span class="comment">// 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 任务结束，方法退出</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 到这里，说明 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，</span></span><br><span class="line">                <span class="comment">// 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing)&#123;&#125; 分支了</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">// 该位置处是一个 ForwardingNode，代表该位置已经迁移过了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">// 头结点的 hash 大于 0，说明是链表的 Node 节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，</span></span><br><span class="line">                        <span class="comment">// 需要将链表一分为二，</span></span><br><span class="line">                        <span class="comment">//   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的</span></span><br><span class="line">                        <span class="comment">//   lastRun 之前的节点需要进行克隆，然后分到两个链表中</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 其中的一个链表放在新数组的位置 i</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 另一个链表放在新数组的位置 i+n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span><br><span class="line">                        <span class="comment">//    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// advance 设置为 true，代表该位置已经迁移完毕</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 红黑树的迁移</span></span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果一分为二后，节点数少于 8，那么将红黑树转换回链表</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 将 ln 放置在新数组的位置 i</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 将 hn 放置在新数组的位置 i+n</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span><br><span class="line">                        <span class="comment">//    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// advance 设置为 true，代表该位置已经迁移完毕</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。</p><p>这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。</p><h3 id="get-过程分析-3"><a href="#get-过程分析-3" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>get 方法从来都是最简单的，这里也不例外：</p><ol><li>计算 hash 值</li><li>根据 hash 值找到数组对应位置: (n - 1) &amp; h</li><li>根据该位置处结点性质进行相应查找<ul><li>如果该位置为 null，那么直接返回 null 就可以了</li><li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li><li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li><li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断头结点是否就是我们需要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实也不是很难嘛，虽然没有像之前的 AQS 和线程池一样一行一行源码进行分析，但还是把所有初学者可能会糊涂的地方都进行了深入的介绍，只要是稍微有点基础的读者，应该是很容易就能看懂 HashMap 和 ConcurrentHashMap 源码了。</p><p>看源码不算是目的吧，深入地了解 Doug Lea 的设计思路，我觉得还挺有趣的，大师就是大师，代码写得真的是好啊。</p><p>我发现很多人都以为我写博客主要是源码分析，说真的，我对于源码分析没有那么大热情，主要都是为了用源码说事罢了，可能之后的文章还是会有比较多的源码分析成分。</p><p>不要脸地自以为本文的质量还是挺高的，信息量比较大，如果你觉得有写得不好的地方，或者说看完本文你还是没看懂它们，那么请提出来~~~</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;转载&lt;/strong&gt; &lt;a href=&quot;https://javadoop.com/post/hashmap&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://javadoop.com/post/hashmap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天发一篇”水文”，可能很多读者都会表示不理解，不过我想把它作为并发序列文章中不可缺少的一块来介绍。本来以为花不了多少时间的，不过最终还是投入了挺多时间来完成这篇文章的。&lt;/p&gt;
&lt;p&gt;网上关于 HashMap 和 ConcurrentHashMap 的文章确实不少，不过缺斤少两的文章比较多，所以才想自己也写一篇，把细节说清楚说透，尤其像 Java8 中的 ConcurrentHashMap，大部分文章都说不清楚。终归是希望能降低大家学习的成本，不希望大家到处找各种不是很靠谱的文章，看完一篇又一篇，可是还是模模糊糊。&lt;/p&gt;
&lt;p&gt;阅读建议：四节基本上可以进行独立阅读，建议初学者可按照 Java7 HashMap -&amp;gt; Java7 ConcurrentHashMap -&amp;gt; Java8 HashMap -&amp;gt; Java8 ConcurrentHashMap 顺序进行阅读，可适当降低阅读门槛。&lt;/p&gt;
&lt;p&gt;阅读前提：本文分析的是源码，所以至少读者要熟悉它们的接口使用，同时，对于并发，读者至少要知道 CAS、ReentrantLock、UNSAFE 操作这几个基本的知识，文中不会对这些知识进行介绍。Java8 用到了红黑树，不过本文不会进行展开，感兴趣的读者请自行查找相关资料。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://blackist.org/categories/Java/"/>
    
    
      <category term="开发" scheme="https://blackist.org/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="java" scheme="https://blackist.org/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式也可以这么简单</title>
    <link href="https://blackist.org/2019/10/01/dev-design-pattern/"/>
    <id>https://blackist.org/2019/10/01/dev-design-pattern/</id>
    <published>2019-10-01T11:29:25.000Z</published>
    <updated>2019-10-01T11:36:33.289Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>转载</strong> <a href="https://javadoop.com/post/design-pattern" target="_blank" rel="noopener">https://javadoop.com/post/design-pattern</a></p><p>一直想写一篇介绍设计模式的文章，让读者可以很快看完，而且一看就懂，看懂就会用，同时不会将各个模式搞混。自认为本文还是写得不错的😂😂😂，花了不少心思来写这文章和做图，力求让读者真的能看着简单同时有所收获。</p><p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。</p><p>有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：</p><ol><li>面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</li><li>职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。</li><li>对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</li></ol><p><strong>创建型模式比较简单，但是会比较没有意思，结构型和行为型比较有意思。</strong></p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>和名字一样简单，非常简单，直接上代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title">makeFood</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"noodle"</span>)) &#123;</span><br><span class="line">            Food noodle = <span class="keyword">new</span> LanZhouNoodle();</span><br><span class="line">            noodle.addSpicy(<span class="string">"more"</span>);</span><br><span class="line">            <span class="keyword">return</span> noodle;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"chicken"</span>)) &#123;</span><br><span class="line">            Food chicken = <span class="keyword">new</span> HuangMenChicken();</span><br><span class="line">            chicken.addCondiment(<span class="string">"potato"</span>);</span><br><span class="line">            <span class="keyword">return</span> chicken;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</em></p><p>简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</p><blockquote><p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</p></blockquote><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Food <span class="title">makeFood</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseFoodFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeFood</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChineseFoodA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChineseFoodB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFoodFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeFood</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AmericanFoodA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AmericanFoodB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。</p><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先选择一个具体的工厂</span></span><br><span class="line">        FoodFactory factory = <span class="keyword">new</span> ChineseFoodFactory();</span><br><span class="line">        <span class="comment">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span></span><br><span class="line">        Food food = factory.makeFood(<span class="string">"A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然都是调用 makeFood(“A”)  制作 A 类食物，但是，不同的工厂生产出来的完全不一样。</p><p>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。</p><p><strong>核心在于，我们需要在第一步选好我们需要的工厂</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。</p><p>虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/factory-1.png" alt="factory-1"></p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</p><p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p><p>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-1.png" alt="factory-1"></p><p>这个时候的客户端调用是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到 Intel 的 CPU</span></span><br><span class="line">CPUFactory cpuFactory = <span class="keyword">new</span> IntelCPUFactory();</span><br><span class="line">CPU cpu = intelCPUFactory.makeCPU();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到 AMD 的主板</span></span><br><span class="line">MainBoardFactory mainBoardFactory = <span class="keyword">new</span> AmdMainBoardFactory();</span><br><span class="line">MainBoard mainBoard = mainBoardFactory.make();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装 CPU 和主板</span></span><br><span class="line">Computer computer = <span class="keyword">new</span> Computer(cpu, mainBoard);</span><br></pre></td></tr></table></figure><p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p><p>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p><p>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-2.png" alt="abstract-factory-2"></p><p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-3.png" alt="abstract-factory-3"></p><p>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步就要选定一个“大厂”</span></span><br><span class="line">    ComputerFactory cf = <span class="keyword">new</span> AmdFactory();</span><br><span class="line">    <span class="comment">// 从这个大厂造 CPU</span></span><br><span class="line">    CPU cpu = cf.makeCPU();</span><br><span class="line">    <span class="comment">// 从这个大厂造主板</span></span><br><span class="line">    MainBoard board = cf.makeMainBoard();</span><br><span class="line">  <span class="comment">// 从这个大厂造硬盘</span></span><br><span class="line">  HardDisk hardDisk = cf.makeHardDisk();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span></span><br><span class="line">    Computer result = <span class="keyword">new</span> Computer(cpu, board, hardDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式用得最多，错得最多。</p><p>饿汉模式最简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先，将 new Singleton() 堵死</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，</span></span><br><span class="line">    <span class="comment">// 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">getDate</span><span class="params">(String mode)</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Date();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。</p></blockquote><p>饱汉模式最容易出错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先，也是先堵死 new Singleton() 这条路</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 这一次判断也是必须的，不然会有并发问题</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>双重检查，指的是两次检查 instance 是否为 null。</p><p>volatile 在这里是需要的，希望能引起读者的关注。</p><p>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</p></blockquote><p>嵌套类最经典，以后大家就用它吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</p></blockquote><p>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。</p><p>虽然我们平时很少看到用枚举来实现单例，但是在 RxJava 的源码中，有很多地方都用了枚举来实现单例。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Food food = <span class="keyword">new</span> FoodBuilder().a().b().c().build();</span><br><span class="line">Food food = Food.builder().a().b().c().build();</span><br></pre></td></tr></table></figure><p>套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。</p><p>来一个中规中矩的建造者模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面是“一堆”的属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化，不然客户端就会直接调用构造方法了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(String name, String password, String nickName, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，</span></span><br><span class="line">    <span class="comment">// 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBuilder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 下面是和 User 一模一样的一堆属性</span></span><br><span class="line">        <span class="keyword">private</span> String  name;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">        <span class="keyword">private</span> String nickName;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">UserBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链式调用设置各个属性值，返回 this，即 UserBuilder</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserBuilder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserBuilder <span class="title">password</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.password = password;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserBuilder <span class="title">nickName</span><span class="params">(String nickName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserBuilder <span class="title">age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。</span></span><br><span class="line">        <span class="comment">// 当然，可以在 “复制” 之前做点检验</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="keyword">null</span> || password == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"用户名和密码必填"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (age &lt;= <span class="number">0</span> || age &gt;= <span class="number">150</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"年龄不合法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还可以做赋予”默认值“的功能</span></span><br><span class="line">          <span class="keyword">if</span> (nickName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                nickName = name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(name, password, nickName, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性<strong>复制</strong>给实际产生的对象。</p><p>看看客户端的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User d = User.builder()</span><br><span class="line">                .name(<span class="string">"foo"</span>)</span><br><span class="line">                .password(<span class="string">"pAss12345"</span>)</span><br><span class="line">                .age(<span class="number">25</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说实话，建造者模式的<strong>链式</strong>写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 <strong>Builder 的构造方法</strong>中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。</p><blockquote><p>题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String  name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>怎么样，省下来的时间是不是又可以干点别的了。</p></blockquote><p>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 <strong>return this</strong> 就可以了，然后就可以像下面这样调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User().setName(<span class="string">""</span>).setPassword(<span class="string">""</span>).setAge(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><blockquote><p>很多人是这么用的，但是笔者觉得其实这种写法非常地不优雅，不是很推荐使用。</p></blockquote><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>这是我要说的创建型模式的最后一个设计模式了。</p><p>原型模式很简单：有一个原型<strong>实例</strong>，基于这个原型实例产生新的实例，也就是“克隆”了。</p><p>Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先<strong>实现 Cloneable 接口</strong>，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><blockquote><p>java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。</p></blockquote><p>原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。</p><h3 id="创建型模式总结"><a href="#创建型模式总结" class="headerlink" title="创建型模式总结"></a>创建型模式总结</h3><p>创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是<strong>面向对象</strong>的代码，所以我们第一步当然是需要创建一个对象了。</p><p>简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。</p><p>既然说是<strong>代理</strong>，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。</p><blockquote><p>理解<strong>代理</strong>这个词，这个模式其实就简单了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FoodService</span> </span>&#123;</span><br><span class="line">    <span class="function">Food <span class="title">makeChicken</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Food <span class="title">makeNoodle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoodServiceImpl</span> <span class="keyword">implements</span> <span class="title">FoodService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeChicken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Food f = <span class="keyword">new</span> Chicken()</span><br><span class="line">        f.setChicken(<span class="string">"1kg"</span>);</span><br><span class="line">      f.setSpicy(<span class="string">"1g"</span>);</span><br><span class="line">      f.setSalt(<span class="string">"3g"</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeNoodle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Food f = <span class="keyword">new</span> Noodle();</span><br><span class="line">        f.setNoodle(<span class="string">"500g"</span>);</span><br><span class="line">        f.setSalt(<span class="string">"5g"</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理要表现得“就像是”真实实现类，所以需要实现 FoodService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoodServiceProxy</span> <span class="keyword">implements</span> <span class="title">FoodService</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 内部一定要有一个真实的实现类，当然也可以通过构造方法注入</span></span><br><span class="line">    <span class="keyword">private</span> FoodService foodService = <span class="keyword">new</span> FoodServiceImpl();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeChicken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我们马上要开始制作鸡肉了"</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，</span></span><br><span class="line">        <span class="comment">// 代理只是在核心代码前后做些“无足轻重”的事情</span></span><br><span class="line">        Food food = foodService.makeChicken();</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">"鸡肉制作完成啦，加点胡椒粉"</span>); <span class="comment">// 增强</span></span><br><span class="line">      food.addCondiment(<span class="string">"pepper"</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeNoodle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备制作拉面~"</span>);</span><br><span class="line">        Food food = foodService.makeNoodle();</span><br><span class="line">        System.out.println(<span class="string">"制作完成啦"</span>)</span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用，注意，我们要用代理来实例化接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里用代理类来实例化</span></span><br><span class="line">FoodService foodService = <span class="keyword">new</span> FoodServiceProxy();</span><br><span class="line">foodService.makeChicken();</span><br></pre></td></tr></table></figure><p><img src="https://www.javadoop.com/blogimages/design-pattern/proxy-1.png" alt="proxy"></p><p>我们发现没有，代理模式说白了就是做 <strong>“方法包装”</strong> 或做 <strong>“方法增强”</strong>。在面向切面编程中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。</p><p>说到动态代理，又可以展开说，Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。</p><p>适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。</p><p>适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。</p><h4 id="默认适配器模式"><a href="#默认适配器模式" class="headerlink" title="默认适配器模式"></a>默认适配器模式</h4><p>首先，我们先看看最简单的适配器模式<strong>默认适配器模式(Default Adapter)</strong>是怎么样的。</p><p>我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileAlterationListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的<strong>文件创建</strong>和<strong>文件删除</strong>事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。</p><p>所以，我们需要下面的一个<strong>适配器</strong>，它用于实现上面的接口，但是<strong>所有的方法都是空方法</strong>，这样，我们就可以转而定义自己的类来继承下面这个类即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileAlterationListenerAdaptor</span> <span class="keyword">implements</span> <span class="title">FileAlterationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileMonitor</span> <span class="keyword">extends</span> <span class="title">FileAlterationListenerAdaptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 文件创建</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 文件删除</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍<strong>“正统的”</strong>适配器模式。</p><h4 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h4><p>来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>; <span class="comment">// 鸭的呱呱叫</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span></span>; <span class="comment">// 鸡的咕咕叫</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildCock</span> <span class="keyword">implements</span> <span class="title">Cock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"咕咕叫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸡也会飞哦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CockAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    Cock cock;</span><br><span class="line">    <span class="comment">// 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CockAdapter</span><span class="params">(Cock cock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cock = cock;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 实现鸭的呱呱叫方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 内部其实是一只鸡的咕咕叫</span></span><br><span class="line">        cock.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cock.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用很简单了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有一只野鸡</span></span><br><span class="line">  Cock wildCock = <span class="keyword">new</span> WildCock();</span><br><span class="line">  <span class="comment">// 成功将野鸡适配成鸭</span></span><br><span class="line">  Duck duck = <span class="keyword">new</span> CockAdapter(wildCock);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。</p><p>我们用一个图来简单说明下：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-1.png" alt="adapter-1"></p><p>上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。</p><h4 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h4><p>废话少说，直接上图：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-2.png" alt="adapter-1"></p><p>看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 <code>Target t = new SomeAdapter();</code> 就可以了。</p><h4 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h4><ol><li><p>类适配和对象适配的异同</p><blockquote><p>一个采用继承，一个采用组合；</p><p>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。</p><p>总体来说，对象适配用得比较多。</p></blockquote></li><li><p>适配器模式和代理模式的异同</p><p>比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-5.png" alt="adapter-5"></p></li></ol><h3 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h3><p>理解桥梁模式，其实就是理解代码抽象和解耦。</p><p>我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是一系列实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedPen</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用红色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenPen</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用绿色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BluePen</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用蓝色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个抽象类，此类的实现类都需要使用 DrawAPI：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Shape</span><span class="params">(DrawAPI drawAPI)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象类的子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 圆形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">int</span> radius, DrawAPI drawAPI)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drawAPI);</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        drawAPI.draw(radius, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 长方形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, DrawAPI drawAPI)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drawAPI);</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        drawAPI.draw(<span class="number">0</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们来看客户端演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Shape greenCircle = <span class="keyword">new</span> Circle(<span class="number">10</span>, <span class="keyword">new</span> GreenPen());</span><br><span class="line">    Shape redRectangle = <span class="keyword">new</span> Rectangle(<span class="number">4</span>, <span class="number">8</span>, <span class="keyword">new</span> RedPen());</span><br><span class="line">    greenCircle.draw();</span><br><span class="line">    redRectangle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/bridge-1.png" alt="bridge-1"></p><p>这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。</p><blockquote><p>本节引用了<a href="https://www.tutorialspoint.com/design_pattern/bridge_pattern.htm" target="_blank" rel="noopener">这里</a>的例子，并对其进行了修改。</p></blockquote><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 <strong>Java IO</strong> 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。</p><p>首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-1.png" alt="decorator-1"></p><p>我们来说说装饰模式的出发点，从图中可以看到，接口 <code>Component</code> 其实已经有了 <code>ConcreteComponentA</code> 和 <code>ConcreteComponentB</code> 两个实现类了，但是，如果我们要<strong>增强</strong>这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来<strong>装饰</strong>实现类，以达到增强的目的。</p><blockquote><p>从名字来简单解释下装饰器。既然说是装饰，那么往往就是<strong>添加小功能</strong>这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，但是那样的话代码就复杂了。</p></blockquote><p>首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 <strong>ConcreteDecorator*</strong> 都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent<em> 的区别是，它们只是装饰者，起<strong>装饰</strong>作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中<em>*加了层皮来装饰</em></em>而已。</p><blockquote><p>注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。</p></blockquote><p>下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。</p><p>最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。</p><p>在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea……但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？</p><p>不说废话了，上代码。</p><p>首先，定义饮料抽象基类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回描述</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 返回价格</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是三个基础饮料实现类，红茶、绿茶和咖啡：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackTea</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"红茶"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenTea</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"绿茶"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">// 咖啡省略</span></span><br></pre></td></tr></table></figure><p>定义调料，也就是装饰者的基类，此类必须继承自 Beverage：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Condiment</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承调料 Condiment 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lemon</span> <span class="keyword">extends</span> <span class="title">Condiment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Beverage bevarage;</span><br><span class="line">    <span class="comment">// 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，</span></span><br><span class="line">    <span class="comment">// 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lemon</span><span class="params">(Beverage bevarage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 装饰</span></span><br><span class="line">        <span class="keyword">return</span> bevarage.getDescription() + <span class="string">", 加柠檬"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 装饰</span></span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">2</span>; <span class="comment">// 加柠檬需要 2 元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mango</span> <span class="keyword">extends</span> <span class="title">Condiment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Beverage bevarage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mango</span><span class="params">(Beverage bevarage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bevarage.getDescription() + <span class="string">", 加芒果"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">3</span>; <span class="comment">// 加芒果需要 3 元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">// 给每一种调料都加一个类</span></span><br></pre></td></tr></table></figure><p>看客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先，我们需要一个基础饮料，红茶、绿茶或咖啡</span></span><br><span class="line">    Beverage beverage = <span class="keyword">new</span> GreenTea();</span><br><span class="line">    <span class="comment">// 开始装饰</span></span><br><span class="line">    beverage = <span class="keyword">new</span> Lemon(beverage); <span class="comment">// 先加一份柠檬</span></span><br><span class="line">    beverage = <span class="keyword">new</span> Mongo(beverage); <span class="comment">// 再加一份芒果</span></span><br><span class="line"></span><br><span class="line">    System.out.println(beverage.getDescription() + <span class="string">" 价格：￥"</span> + beverage.cost());</span><br><span class="line">    <span class="comment">//"绿茶, 加柠檬, 加芒果 价格：￥16"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们需要 <strong>芒果-珍珠-双份柠檬-红茶</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Beverage beverage = <span class="keyword">new</span> Mongo(<span class="keyword">new</span> Pearl(<span class="keyword">new</span> Lemon(<span class="keyword">new</span> Lemon(<span class="keyword">new</span> BlackTea()))));</span><br></pre></td></tr></table></figure><p>是不是很变态？</p><p>看看下图可能会清晰一些：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-2.png" alt="decorator-2"></p><p>到这里，大家应该已经清楚装饰模式了吧。</p><p>下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-3.png" alt="decorator-3"></p><p>我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。</p><p>FilterInputStream 承接了装饰模式的关键节点，它的实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。</p><p>当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">new</span> LineNumberInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">""</span>)));</span><br></pre></td></tr></table></figure><p>这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。</p><p>我们应该像下面这样使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream is = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">  <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                              <span class="keyword">new</span> FileInputStream(<span class="string">""</span>)));</span><br></pre></td></tr></table></figure><blockquote><p>所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。</p></blockquote><h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><p>门面模式（也叫外观模式，Facade Pattern）在许多源码中有使用，比如 slf4j 就可以理解为是门面模式的应用。这是一个简单的设计模式，我们直接上代码再说吧。</p><p>首先，我们定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义几个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Circle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Rectangle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 画一个圆形</span></span><br><span class="line">  Shape circle = <span class="keyword">new</span> Circle();</span><br><span class="line">  circle.draw();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 画一个长方形</span></span><br><span class="line">  Shape rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">  rectangle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。</p><p>下面，我们看看怎么用门面模式来让客户端调用更加友好一些。</p><p>我们先定义一个门面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeMaker</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Shape circle;</span><br><span class="line">   <span class="keyword">private</span> Shape rectangle;</span><br><span class="line">   <span class="keyword">private</span> Shape square;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ShapeMaker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      circle = <span class="keyword">new</span> Circle();</span><br><span class="line">      rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">      square = <span class="keyword">new</span> Square();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span></span>&#123;</span><br><span class="line">      circle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">      rectangle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSquare</span><span class="params">()</span></span>&#123;</span><br><span class="line">      square.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看现在客户端怎么调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ShapeMaker shapeMaker = <span class="keyword">new</span> ShapeMaker();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 客户端调用现在更加清晰了</span></span><br><span class="line">  shapeMaker.drawCircle();</span><br><span class="line">  shapeMaker.drawRectangle();</span><br><span class="line">  shapeMaker.drawSquare();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。</p><p>直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String dept;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> salary;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Employee&gt; subordinates; <span class="comment">// 下属</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name,String dept, <span class="keyword">int</span> sal)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.dept = dept;</span><br><span class="line">      <span class="keyword">this</span>.salary = sal;</span><br><span class="line">      subordinates = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">      subordinates.add(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">      subordinates.remove(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getSubordinates</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> subordinates;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="string">"Employee :[ Name : "</span> + name + <span class="string">", dept : "</span> + dept + <span class="string">", salary :"</span> + salary+<span class="string">" ]"</span>);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。</p><p>这说的其实就是组合模式，这种简单的模式我就不做过多介绍了，相信各位读者也不喜欢看我写废话。</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。</p><p>复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。</p><p>这种简单的代码我就不演示了。</p><h3 id="结构型模式总结"><a href="#结构型模式总结" class="headerlink" title="结构型模式总结"></a>结构型模式总结</h3><p>前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？</p><p>代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</p><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。</p><p>下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。</p><p>首先，先定义一个策略接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们定义具体的几个策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedPen</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"用红色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenPen</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"用绿色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BluePen</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"用蓝色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用策略的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeDraw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.draw(radius, x, y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> BluePen()); <span class="comment">// 使用绿色笔来画</span></span><br><span class="line">  context.executeDraw(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放到一张图上，让大家看得清晰些：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/strategy-1.png" alt="strategy-1"></p><p>这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/bridge-1.png" alt="bridge-1"></p><p>要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。</p><p>首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="comment">// 数据已变更，通知观察者们</span></span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知观察者们</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义观察者接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。</p><p>我们来定义具体的几个观察者类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在构造方法中进行订阅主题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="comment">// 通常在构造方法中将 this 发布出去的操作一定要小心</span></span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该方法由主题类在数据变更的时候进行调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = Integer.toBinaryString(subject.getState());</span><br><span class="line">        System.out.println(<span class="string">"订阅的数据发生变化，新的数据处理为二进制值为："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HexaObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HexaObserver</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = Integer.toHexString(subject.getState()).toUpperCase();</span><br><span class="line">        System.out.println(<span class="string">"订阅的数据发生变化，新的数据处理为十六进制值为："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端使用也非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先定义一个主题</span></span><br><span class="line">    Subject subject1 = <span class="keyword">new</span> Subject();</span><br><span class="line">    <span class="comment">// 定义观察者</span></span><br><span class="line">    <span class="keyword">new</span> BinaryObserver(subject1);</span><br><span class="line">    <span class="keyword">new</span> HexaObserver(subject1);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 模拟数据变更，这个时候，观察者们的 update 方法将会被调用</span></span><br><span class="line">    subject.setState(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">订阅的数据发生变化，新的数据处理为二进制值为：1011</span><br><span class="line">订阅的数据发生变化，新的数据处理为十六进制值为：B</span><br></pre></td></tr></table></figure><p>当然，jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。</p><p>实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。</p><p>还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。</p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。</p><p>有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。</p><blockquote><p>如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？</p></blockquote><p>首先，我们要定义流程上节点的基类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">protected</span> RuleHandler successor;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Context context)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(RuleHandler successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RuleHandler <span class="title">getSuccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们需要定义具体的每个节点了。</p><p>校验用户是否是新用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewUserRuleHandler</span> <span class="keyword">extends</span> <span class="title">RuleHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (context.isNewUser()) &#123;</span><br><span class="line">            <span class="comment">// 如果有后继节点的话，传递下去</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getSuccessor() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"该活动仅限新用户参与"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>校验用户所在地区是否可以参与：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocationRuleHandler</span> <span class="keyword">extends</span> <span class="title">RuleHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> allowed = activityService.isSupportedLocation(context.getLocation);</span><br><span class="line">        <span class="keyword">if</span> (allowed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getSuccessor() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"非常抱歉，您所在的地区无法参与本次活动"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>校验奖品是否已领完：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitRuleHandler</span> <span class="keyword">extends</span> <span class="title">RuleHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> remainedTimes = activityService.queryRemainedTimes(context); <span class="comment">// 查询剩余奖品</span></span><br><span class="line">        <span class="keyword">if</span> (remainedTimes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getSuccessor() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getSuccessor().apply(userInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"您来得太晚了，奖品被领完了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    RuleHandler newUserHandler = <span class="keyword">new</span> NewUserRuleHandler();</span><br><span class="line">    RuleHandler locationHandler = <span class="keyword">new</span> LocationRuleHandler();</span><br><span class="line">    RuleHandler limitHandler = <span class="keyword">new</span> LimitRuleHandler();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 假设本次活动仅校验地区和奖品数量，不校验新老用户</span></span><br><span class="line">    locationHandler.setSuccessor(limitHandler);</span><br><span class="line">  </span><br><span class="line">    locationHandler.apply(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。</p><p>至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。</p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>在含有继承结构的代码中，模板方法模式是非常常用的。</p><p>通常会有一个抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTemplate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这就是模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        apply(); <span class="comment">// 这个是重点</span></span><br><span class="line">        end(); <span class="comment">// 可以作为钩子方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init 抽象层已经实现，子类也可以选择覆写"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 留给子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。</p><p>我们写一个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteTemplate</span> <span class="keyword">extends</span> <span class="title">AbstractTemplate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类实现抽象方法 apply"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AbstractTemplate t = <span class="keyword">new</span> ConcreteTemplate();</span><br><span class="line">    <span class="comment">// 调用模板方法</span></span><br><span class="line">    t.templateMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>update: 2017-10-19</p><p>废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。</p><p>核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。</p><p>定义状态接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义减库存的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeductState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"商品卖出，准备减库存"</span>);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行减库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Deduct State"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义补库存状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RevertState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"给此商品补库存"</span>);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行加库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Revert State"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看下客户端调用，大家就一清二楚了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们需要操作的是 iPhone X</span></span><br><span class="line">    Context context = <span class="keyword">new</span> Context(<span class="string">"iPhone X"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 看看怎么进行补库存操作</span></span><br><span class="line">  State revertState = <span class="keyword">new</span> RevertState();</span><br><span class="line">  revertState.doAction(context);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 同样的，减库存操作也非常简单</span></span><br><span class="line">  State deductState = <span class="keyword">new</span> DeductState();</span><br><span class="line">  deductState.doAction(context);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果需要我们可以获取当前的状态</span></span><br><span class="line">    <span class="comment">// context.getState().toString();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。</p><p>不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。</p><h3 id="行为型模式总结"><a href="#行为型模式总结" class="headerlink" title="行为型模式总结"></a>行为型模式总结</h3><p>行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。我想，文章的最大收益者一般都是作者本人，为了写一篇文章，需要巩固自己的知识，需要寻找各种资料，而且，自己写过的才最容易记住，也算是我给读者的建议吧。</p><p>（全文完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发" scheme="https://blackist.org/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="https://blackist.org/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="设计模式" scheme="https://blackist.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>学期总结 2018-2019（二）</title>
    <link href="https://blackist.org/2019/09/30/life-semester-summary-2019-2/"/>
    <id>https://blackist.org/2019/09/30/life-semester-summary-2019-2/</id>
    <published>2019-09-30T07:16:22.000Z</published>
    <updated>2019-09-30T07:19:21.873Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>317实验室的学期总结来了，像我这样优秀的人当然是积极参与。</p><a id="more"></a><p>包老师名句镇楼：</p><blockquote><p>努力在于无时无刻，进步在于不知不觉。</p></blockquote><h3 id="学期总结"><a href="#学期总结" class="headerlink" title="学期总结"></a>学期总结</h3><p>转眼间，我们度过了研二下学期，这一学期我遇到了一些困难，经历了一些挫折，挥洒一些汗水，最终还是收获了一些成果。</p><p>新年过后，学期一开始我们便全力投入到智慧校园项目中，在大家的共同努力下克服了所有的开发问题，项目最终能够如期上线。项目部署场景至今历历在目，我看着项目组的设备一个个安装完毕，成功连接到服务器，校园用户一个个排着队录入指纹，然后扫码下载APP，注册、登录、使用、反馈，那是一种紧张又期待的心情。紧张的是产品能否适应现场环境，软件能否正常运行；期待的是用户对产品的认可，产品能够达到预期的设计意图。虽然用户陆续反馈了一些问题，好在我们都能很好地解决这些问题，一遍遍打磨之后让产品更稳定，直到现在可以进行量产。</p><p>回头看看，自己学到的知识和技能可以在实际项目中得以实践，是一件值得庆幸的事情，确实对我有所提升。在项目得到阶段性进展后，我们研二同学开始投入到论文中了，这对于天天敲代码的我们来说，简直是一场锤炼啊！</p><p>开始写论文的时候，自然是一脸，不，是一头雾水，只能循规蹈矩地阅读文献，琢磨为了创新而创新的“创新点”。一次次地创新，一次次地讨论，再一次次地自我否定，最终还是在脑壳上“凿了个洞”，成功地琢磨出了一个创新点。有了idea之后就下手写吧，写了摘要和引言，本来自己还蛮欣赏自己的“才华”，结果包老师说写出来的是科普文，不是论文呀。即便万念俱灰，我也不能放弃，因为我想把该做完的事情做完，然后好好放松下（后来证明放松是不可能的，因为接下来的事情更辛苦）。在包老师和厉害同学的帮助下，我还是打磨出了自己的论文，还给自己的论文起了一个很厉害的名字，这也是我认为本文最亮的创新点，结果证明那名字有点“飞扬跋扈”了，最终还是把名字改得中规中矩的。</p><p>论文投出去还没有结果，在此许下愿望，希望最终可以被录用。前面说了，论文写完也闲不住啊，之后把全部精力放在了找工作上，这又是一场残酷的历练。</p><p>刚开始以为自己有项目经验，用Java有5年了吧，还有博客加特，一线互联网大厂需要我这样的人才啊。不多久，网易的笔试一巴掌把我打醒了，更甚者，投了其它几个公司简历直接进入公海池，然后我发现原来这才是现实啊。灰头土脸的我选择埋头学习，看日常开发技术的基础，学习笔试算法，不断地投简历、笔试、面试，也明白了秋招不是找工作，应该叫求职。讲一点自己的感受，平时学习和做项目，一定要注重积累总结，不能满足于调用API 完成业务逻辑，要了解实现原理，因为面试问的就是原理和基础。还有一点就是，不管能不能面试成功大厂都要投递，因为哪怕是大厂的面试对你也是有提升的。</p><p>这一学期，不管是项目、论文、还是求职，都离不开包老师、包总和同学们的帮助，一起走来两年了，还是要深深地感谢你们。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;317实验室的学期总结来了，像我这样优秀的人当然是积极参与。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://blackist.org/categories/Life/"/>
    
    
      <category term="成长之路" scheme="https://blackist.org/tags/%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="学期总结" scheme="https://blackist.org/tags/%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JVM - 参数配置影响线程数</title>
    <link href="https://blackist.org/2019/09/29/java-jvm-thread-params/"/>
    <id>https://blackist.org/2019/09/29/java-jvm-thread-params/</id>
    <published>2019-09-29T05:56:47.000Z</published>
    <updated>2019-09-29T06:53:15.573Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一道面试</p><p>找工作是个脑力活也是个体力活啊，最近秋招给我累得够呛，昨天面了杭州大华，被一道 JVM 参数的问题难住了。</p><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>面试官：说个常用的 JVM 参数</p><p>我：好像有个什么 -Xms，不常用大太熟悉这些参数（语塞中…，本来背了几个，一紧张还是忘了）</p><p>面试官：如果 -Xmx 调大，线程数怎么变化</p><p>我：变小</p><p>面试官：为什么</p><p>我：猜的。。。</p></blockquote><p>虽然最后挨到 HR 面，但还是要把面试题捋一捋的。</p><h2 id="一、题目相关参数"><a href="#一、题目相关参数" class="headerlink" title="一、题目相关参数"></a>一、题目相关参数</h2><h3 id="1-1-三个重要参数"><a href="#1-1-三个重要参数" class="headerlink" title="1.1 三个重要参数"></a>1.1 三个重要参数</h3><ul><li><strong>-Xms</strong> 为 jvm 启动时分配 Heap初始内存(最小内存)，比如<code>-Xms200m</code>，表示分配200M</li><li><strong>-Xmx</strong> 为 jvm 运行过程中分配 Heap最大内存，比如<code>-Xms500m</code>，表示jvm进程最多只能够占用500M内存</li><li>-<strong>Xss</strong> 为 jvm 启动的每个线程分配的内存大小(stack size)，默认JDK1.4中是256K，JDK1.5+中是1M</li></ul><p>通常，<code>-Xms</code> 和 <code>-Xmx</code> 设置成一样的，避免每次垃圾回收完成后JVM重新分配内存。因为当Heap不够用时，发生内存抖动，影响程序运行稳定性。</p><h3 id="1-2-线程数的变动"><a href="#1-2-线程数的变动" class="headerlink" title="1.2 线程数的变动"></a>1.2 线程数的变动</h3><p>准确来说，是 jvm 可生产线程数的数量，由三个方面影响：</p><ul><li>jvm 的堆内存大小</li><li>Thread 的 Stack内存大小</li><li>系统最大可创建的线程数量</li></ul><p>增大堆内存（<strong>-Xms，-Xmx</strong>）会减少可创建的线程数量；增大线程栈内存（<strong>-Xss</strong>，32 位系统中此参数值最小为 60 K）也会减少可创建的线程数量。因此题中， <code>-Xmx</code> 加大，Heap内存增大，jvm 空闲的内存数（java虚拟机栈等）就更少，那么可以创建的线程也就更少。</p><p>系统从以下几个方面影响最大线程数：</p><ul><li>/proc/sys/kernel/pid_max，</li><li>/proc/sys/kernel/thread-max，</li><li>max_user_process（ulimit -u），</li><li>/proc/sys/vm/max_map_count</li></ul><p>具体影响过程参考 <a href="https://blog.csdn.net/moonpure/article/details/80701878" target="_blank" rel="noopener">https://blog.csdn.net/moonpure/article/details/80701878</a></p><h3 id="1-3-三个内存方法"><a href="#1-3-三个内存方法" class="headerlink" title="1.3 三个内存方法"></a>1.3 三个内存方法</h3><p>java.lang.Runtime 类中的 freeMemory(), totalMemory(), maxMemory() 这几个方法反映的都是 java 这个进程的内存情况，跟操作系统的内存根本没有关系。</p><h4 id="maxMemory"><a href="#maxMemory" class="headerlink" title="maxMemory()"></a>maxMemory()</h4><p>返回的是<strong>java虚拟机（这个进程）</strong>能构从操作系统那里挖到的最大的内存，以字节为单位，如果在运行 java 程序的时候，没有添加 -Xmx 参数，那么就是 64 M，也就是说 maxMemory() 返回的大约是64<em>1024</em>1024 字节，这是 java 虚拟机默认情况下能从操作系统那里挖到的最大的内存。如果添加了 -Xmx 参数，将以这个参数后面的值为准，例如<code>java -cp you_classpath -Xmx512m your_class</code>，那么最大内存就是 512<em>1024</em>1024 字节。</p><h4 id="totalMemory"><a href="#totalMemory" class="headerlink" title="totalMemory()"></a>totalMemory()</h4><p>返回的是 java 虚拟机现在已经从操作系统那里挖过来的内存大小，也就是java虚拟机这个进程当时所占用的所有内存。如果在运行 java 的时候没有添加 -Xms 参数，那么，在 java 程序运行的过程的，内存总是慢慢的从操作系统那里挖的，基本上是用多少挖多少，直到挖到 maxMemory() 为止，所以totalMemory() 是慢慢增大的。如果用了 -Xms 参数，程序在启动的时候就会无条件的从操作系统中挖 -Xms后面定义的内存数，然后在这些内存用的差不多的时候，再去挖。</p><h4 id="freeMemory"><a href="#freeMemory" class="headerlink" title="freeMemory()"></a>freeMemory()</h4><p>刚才讲到如果在运行java的时候没有添加 -Xms 参数，那么，在 java 程序运行的过程的，内存总是慢慢的从操作系统那里挖的，基本上是用多少挖多少，但是 java 虚拟机100％的情况下是会稍微多挖一点的，这些挖过来而又没有用上的内存，实际上就是 freeMemory()，所以freeMemory()的值一般情况下都是很小的，但是如果你在运行 java 程序的时候使用了 -Xms，这个时候因为程序在启动的时候就会无条件的从操作系统中挖 -Xms 后面定义的内存数，这个时候，挖过来的内存可能大部分没用上，所以这个时候 freeMemory() 可能会有些大。  </p><h2 id="二、常用参数"><a href="#二、常用参数" class="headerlink" title="二、常用参数"></a>二、常用参数</h2><h3 id="2-1-堆设置"><a href="#2-1-堆设置" class="headerlink" title="2.1 堆设置"></a>2.1 堆设置</h3><ul><li>-Xms：初始堆大小</li><li>-Xmx：最大堆大小</li><li>-XX:NewSize=n：设置年轻代大小</li><li>-XX:NewRatio=n：设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年代年老代和的1/4</li><li>-XX:SurvivorRatio=n：年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</li><li>-XX:MaxPermSize=n：设置持久代大小</li></ul><p>JVM 中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统下，一般限制在1.5G~2G；64为操作系统对内存无限制。我在Windows Server 2003 系统，3.5G物理内存，JDK5.0下测试，最大可设置为1478m。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k</span><br><span class="line">-Xmx3550m <span class="comment"># 设置JVM最大可用内存为3550M。</span></span><br><span class="line">-Xms3550m <span class="comment"># 设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</span></span><br><span class="line">-Xmn2g <span class="comment"># 设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小 。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</span></span><br><span class="line">-Xss128k <span class="comment"># 设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</span></span><br></pre></td></tr></table></figure><p>依据的原则是根据Java Performance里面的推荐公式来进行设置。</p><p><img src="http://pic.blackist.top/dev-201909291451-574.png" alt></p><p>具体来讲：</p><ul><li>Java整个堆大小设置，Xmx 和 Xms设置为老年代存活对象的3-4倍，即FullGC之后的老年代内存占用的3-4倍</li><li>永久代 PermSize和MaxPermSize设置为老年代存活对象的1.2-1.5倍。</li><li>年轻代Xmn的设置为老年代存活对象的1-1.5倍。</li><li>老年代的内存大小设置为老年代存活对象的2-3倍。</li></ul><p>BTW：</p><p>1、Sun官方建议年轻代的大小为整个堆的3/8左右， 所以按照上述设置的方式，基本符合Sun的建议。     </p><p>2、堆大小=年轻代大小+年老代大小， 即 xmx=xmn+老年代大小 。 Permsize不影响堆大小。</p><p>3、为什么要按照上面的来进行设置呢？ 没有具体的说明，但应该是根据多种调优之后得出的一个结论。</p><p>具体调整策略参考 <a href="https://blog.csdn.net/losetowin/article/details/78569001" target="_blank" rel="noopener">https://blog.csdn.net/losetowin/article/details/78569001</a></p><h3 id="2-2-收集器设置"><a href="#2-2-收集器设置" class="headerlink" title="2.2 收集器设置"></a>2.2 收集器设置</h3><ul><li>-XX:+UseSerialGC :设置串行收集器</li><li>-XX:+UseParallelGC :设置并行收集器</li><li>-XX:+UseParalledlOldGC :设置并行年老代收集器</li><li>-XX:+UseConcMarkSweepGC :设置并发收集器</li></ul><p>JVM给了三种选择：串行收集器、并行收集器、并发收集器 ，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0 以后，JVM会根据当前<a href="http://java.sun.com/j2se/1.5.0/docs/guide/vm/server-class.html" target="_blank" rel="noopener">系统配置</a></p><h4 id="吞吐量优先-的并行收集器"><a href="#吞吐量优先-的并行收集器" class="headerlink" title="吞吐量优先 的并行收集器"></a>吞吐量优先 的并行收集器</h4><p>如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。</p><p>典型配置 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</span><br><span class="line">-XX:+UseParallelGC <span class="comment"># 选择垃圾收集器为并行收集器。 此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</span></span><br><span class="line">-XX:ParallelGCThreads=20 <span class="comment"># 配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</span></span><br></pre></td></tr></table></figure><h4 id="响应时间优先-的并发收集器"><a href="#响应时间优先-的并发收集器" class="headerlink" title="响应时间优先 的并发收集器"></a>响应时间优先 的并发收集器</h4><p>如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。<br>典型配置 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</span><br><span class="line">-XX:+UseConcMarkSweepGC <span class="comment"># 设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。</span></span><br><span class="line">-XX:+UseParNewGC <span class="comment"># 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</span></span><br></pre></td></tr></table></figure><h3 id="2-3-垃圾回收统计信息"><a href="#2-3-垃圾回收统计信息" class="headerlink" title="2.3 垃圾回收统计信息"></a>2.3 垃圾回收统计信息</h3><p>-XX:+PrintGC<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-Xloggc:filename</p><h3 id="2-4-并行收集器设置"><a href="#2-4-并行收集器设置" class="headerlink" title="2.4 并行收集器设置"></a>2.4 并行收集器设置</h3><p>-XX:ParallelGCThreads=n :设置并行收集器收集时使用的CPU数。并行收集线程数。<br>-XX:MaxGCPauseMillis=n :设置并行收集最大暂停时间<br>-XX:GCTimeRatio=n :设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</p><h3 id="2-5-并发收集器设置"><a href="#2-5-并发收集器设置" class="headerlink" title="2.5 并发收集器设置"></a>2.5 并发收集器设置</h3><p>-XX:+CMSIncrementalMode :设置为增量模式。适用于单CPU情况。<br>-XX:ParallelGCThreads=n :设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/ceshi2016/p/8447989.html" target="_blank" rel="noopener">https://www.cnblogs.com/ceshi2016/p/8447989.html</a></p><p><a href="https://blog.csdn.net/moonpure/article/details/80701878" target="_blank" rel="noopener">https://blog.csdn.net/moonpure/article/details/80701878</a></p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一道面试&lt;/p&gt;
&lt;p&gt;找工作是个脑力活也是个体力活啊，最近秋招给我累得够呛，昨天面了杭州大华，被一道 JVM 参数的问题难住了。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://blackist.org/categories/Java/"/>
    
    
      <category term="开发" scheme="https://blackist.org/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="java" scheme="https://blackist.org/tags/java/"/>
    
      <category term="jvm" scheme="https://blackist.org/tags/jvm/"/>
    
      <category term="面试" scheme="https://blackist.org/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 - PNPoly处理点和多边形</title>
    <link href="https://blackist.org/2019/08/28/arithmetic-coordinate-point-segment-dist/"/>
    <id>https://blackist.org/2019/08/28/arithmetic-coordinate-point-segment-dist/</id>
    <published>2019-08-28T01:53:02.000Z</published>
    <updated>2019-08-28T03:29:45.697Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近做了一个算法题【盒马配货】：</p><blockquote><p>（题目大意）盒马店的配送范围由一些点组成的多边形确定，给定一个点判断其是否在配送范围内，若在，则此点不需要挪动，打印”no 0”；若不在，则给出此点需要挪动到配送范围的最短距离，打印”yes 距离”。</p></blockquote><a id="more"></a><h2 id="如何求解点到多边形的距离"><a href="#如何求解点到多边形的距离" class="headerlink" title="如何求解点到多边形的距离"></a>如何求解点到多边形的距离</h2><p>此题求解需要解决两个问题：</p><ul><li>点到多边形的边的最短距离。</li><li>点是否包含在多边形内。</li></ul><h2 id="点到边的距离"><a href="#点到边的距离" class="headerlink" title="点到边的距离"></a>点到边的距离</h2><p>计算点到多边形最短距离的基本原理是：依次计算点到多边形每条边的距离，然后筛选出最短距离。</p><p><img src="http://pic.blackist.top/dev-201908281020-772.png" alt></p><p>如下图，假设AB为多边形的一条边，现在求点P到AB的距离。</p><p><img src="http://pic.blackist.top/dev-201908281021-296.png" alt></p><p>根据向量内积公式(\vec a \cdot \vec b=|a||b|\cos\theta)，我们可以推出：</p><p><img src="http://pic.blackist.top/dev-201908281029-861.png" alt></p><p>根据以上公式，我们可以求出t，进而求出点D的坐标，最终PD的长度就很容易求得了。</p><p>但是还有一些边界条件需要注意，即最终D点不是落在AB上，有以下三种情况：</p><ul><li>t &lt; 0，D在BA延长线上，此时最短距离取PA；</li><li>0 &lt;= t &lt;= 1，D在AB上，此时最短距离取PD；</li><li>t &gt; 1，D在AB延长线上，此时最短距离取PB；</li></ul><p><img src="http://pic.blackist.top/dev-201908281031-290.png" alt></p><p>Java实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pointToSegmentDist</span><span class="params">(<span class="keyword">double</span> px, <span class="keyword">double</span> py, <span class="keyword">double</span> ax, <span class="keyword">double</span> ay, <span class="keyword">double</span> bx, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ABx = bx - ax;</span><br><span class="line">    <span class="keyword">double</span> ABy = by - ay;</span><br><span class="line">    <span class="keyword">double</span> APx = px - ax;</span><br><span class="line">    <span class="keyword">double</span> APy = py - ay;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> AB_AP = ABx * APx + ABy * APy;</span><br><span class="line">    <span class="keyword">double</span> distAB2 = ABx * ABx + ABy * ABy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> Dx = ax, Dy = ay;</span><br><span class="line">    <span class="keyword">if</span> (distAB2 != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">double</span> t = AB_AP / distAB2;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            Dx = bx;</span><br><span class="line">            Dy = by;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Dx = ax + ABx * t;</span><br><span class="line">            Dy = ay + ABy * t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Dx = ax;</span><br><span class="line">            Dy = ay;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> PDx = Dx - px, PDy = Dy - py;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(PDx * PDx + PDy * PDy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="点是否包含在多边形内"><a href="#点是否包含在多边形内" class="headerlink" title="点是否包含在多边形内"></a>点是否包含在多边形内</h2><p>根据W. Randolph Franklin 提出的<a href="https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html" target="_blank" rel="noopener">PNPoly</a>算法，只需区区几行代码就解决了这个问题。</p><p>假设配送范围多边形的点横纵坐标分别存放在两个数组xs、ys里，(x,y)表示配送点的坐标，先贴代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">polygon</span><span class="params">(<span class="keyword">double</span>[] xs, <span class="keyword">double</span>[] ys, <span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> contained = <span class="keyword">false</span>; <span class="comment">// 点是否包含在多边形内</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> xMin = Arrays.stream(xs).min().getAsDouble();</span><br><span class="line">    <span class="keyword">double</span> xMax = Arrays.stream(xs).max().getAsDouble();</span><br><span class="line">    <span class="keyword">double</span> yMin = Arrays.stream(ys).min().getAsDouble();</span><br><span class="line">    <span class="keyword">double</span> yMax = Arrays.stream(ys).max().getAsDouble();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; xMax || x &lt; xMin || y &gt; yMax || y &lt; yMin) &#123;</span><br><span class="line">        contained = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 核心算法部分</span></span><br><span class="line">    <span class="keyword">int</span> N = xs.length;</span><br><span class="line">    <span class="keyword">double</span> dist = Double.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = N - <span class="number">1</span>; i &lt; N; j = i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((ys[j] &gt; y) != (ys[i] &gt; y))</span><br><span class="line">            &amp;&amp; (x &lt; (xs[j] - xs[i]) * (y - ys[i]) / (ys[j] - ys[i]) + xs[i])) &#123;</span><br><span class="line">            contained = !contained;</span><br><span class="line">        &#125;</span><br><span class="line">        dist = Math.min(dist, pointToSegmentDist(x, y, xs[i], ys[i], xs[j], ys[j]));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(contained ? <span class="string">"no 0"</span> : <span class="string">"yes"</span> + <span class="string">" "</span> + dist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们需要取得该数组在横坐标和纵坐标的最大值和最小值，根据这四个点算出一个四边型，判断目标坐标点是否在这个四边型之内，如果在这个四边型之外，那可以跳过后面较为复杂的计算，直接返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; xMax || x &lt; xMin || y &gt; yMax || y &lt; yMin) &#123;</span><br><span class="line">    contained = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是核心算法部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = N - <span class="number">1</span>; i &lt; N; j = i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (((ys[j] &gt; y) != (ys[i] &gt; y))</span><br><span class="line">    &amp;&amp; (x &lt; (xs[j] - xs[i]) * (y - ys[i]) / (ys[j] - ys[i]) + xs[i])) &#123;</span><br><span class="line">    contained = !contained;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次计算都涉及到相邻的两个点和待测试点，然后考虑两个问题：</p><ul><li><p>被测试点的纵坐标testy是否在本次循环所测试的两个相邻点纵坐标范围之内，即</p><p>ys[i] &lt;y &lt; ys[j]</p><p>或者</p><p>ys[j] &lt;y &lt; ys[i]。</p></li><li><p>待测点test是否在i,j两点之间的连线之下（相交判断）。</p></li></ul><p><strong>每次这两个条件同时满足的时候我们把返回的布尔量取反</strong>。</p><p>这个表达式的意思是说，随便画个多边形，随便定一个点，然后通过这个点水平划一条线，先数数看这条横线和多边形的边相交几次（可先排除那些不相交的边，即第一个判断条件），然后再数这条横线穿越多边形的次数是否为奇数，如果是奇数，那么该点在多边形内，如果是偶数，则在多边形外（射线法）。</p><h3 id="点在直线下-相交判断"><a href="#点在直线下-相交判断" class="headerlink" title="点在直线下 - 相交判断"></a>点在直线下 - 相交判断</h3><p>如下图，ab与过p点的水平线相交于c，</p><p><img src="http://pic.blackist.top/dev-201908281110-490.png" alt></p><p>则有：</p><p><img src="http://pic.blackist.top/dev-201908281111-204.png" alt></p><p>Java代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((ys[j] &gt; y) != (ys[i] &gt; y))</span><br><span class="line">&amp;&amp; (x &lt; (xs[j] - xs[i]) * (y - ys[i]) / (ys[j] - ys[i]) + xs[i])) &#123;</span><br><span class="line">contained = !contained;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="点在多边形内部-射线法"><a href="#点在多边形内部-射线法" class="headerlink" title="点在多边形内部 - 射线法"></a>点在多边形内部 - 射线法</h3><p>判断点是否在多边形内，可以从这个点做一条射线，计算它跟多边形边界的交点个数，如果交点个数为奇数，那么点在多边形内部，否则点在多边形外。参考<a href="https://www.cnblogs.com/anningwang/p/7581545.html" target="_blank" rel="noopener">https://www.cnblogs.com/anningwang/p/7581545.html</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html" target="_blank" rel="noopener">https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html</a></p><p><a href="https://www.cnblogs.com/anningwang/p/7581545.html" target="_blank" rel="noopener">https://www.cnblogs.com/anningwang/p/7581545.html</a></p><p><a href="https://jingsam.github.io/2016/09/26/polydist.html" target="_blank" rel="noopener">https://jingsam.github.io/2016/09/26/polydist.html</a></p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做了一个算法题【盒马配货】：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（题目大意）盒马店的配送范围由一些点组成的多边形确定，给定一个点判断其是否在配送范围内，若在，则此点不需要挪动，打印”no 0”；若不在，则给出此点需要挪动到配送范围的最短距离，打印”yes 距离”。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="https://blackist.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://blackist.org/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="坐标计算" scheme="https://blackist.org/tags/%E5%9D%90%E6%A0%87%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>JVM - 运行时内存区域</title>
    <link href="https://blackist.org/2019/07/07/java-jvm-jmm/"/>
    <id>https://blackist.org/2019/07/07/java-jvm-jmm/</id>
    <published>2019-07-07T12:38:34.000Z</published>
    <updated>2019-08-28T01:47:20.949Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，然后由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由<strong>JVM执行引擎</strong>执行。</p><p>那在整个程序执行过程中，JVM中怎么存取数据和相关信息呢？</p><p>事实上在JVM中是用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存。</p><a id="more"></a><h2 id="一、运行时数据区域包括哪些"><a href="#一、运行时数据区域包括哪些" class="headerlink" title="一、运行时数据区域包括哪些"></a>一、运行时数据区域包括哪些</h2><p><img src="http://pic.blackist.top/dev-201907071428-3.png" alt></p><p>根据《Java虚拟机规范》的规定，运行时数据区通常包括这几个部分：</p><ul><li><p><strong>程序计数器(Program Counter Register)</strong>：线程私有的，记录当前线程的行号指示器，为线程的切换提供保障；</p></li><li><p><strong>Java虚拟机栈(Java Vitual Machine Stack)</strong>：线程私有的，主要存放<em>局部变量表</em>，操作数栈，动态链接和方法出口等；</p></li><li><p><strong>本地方法栈(Native Method Stack)</strong></p></li><li><p><strong>方法区(Method Area)</strong>：线程共享的，主要存储<strong>类信息、常量池、静态变量、JIT编译后的代码</strong>等数据。方法区理论上来说是堆的逻辑组成部分；<strong>运行时常量池</strong>是方法区的一部分，用于存放编译期生成的各种字面量和符号引用；</p></li><li><p><strong>堆(Heap)</strong>：所有线程共享的，主要用来存储对象。其中，堆可分为：<strong>年轻代和老年代</strong>两块区域。使用NewRatio参数来设定比例。对于年轻代，一个Eden区和两个Suvivor区，使用参数SuvivorRatio来设定大小；</p></li></ul><h2 id="二、各个部分存储的信息和负责的职能"><a href="#二、各个部分存储的信息和负责的职能" class="headerlink" title="二、各个部分存储的信息和负责的职能"></a>二、各个部分存储的信息和负责的职能</h2><h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><p>这个内存区域是Java虚拟机规范中唯一一个没有规定任何OOM（OutOfMemoryError）情况的区域，这是这个区域最大的特点之一，这是因为程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。</p><p>这个区域主要是负责记录正在执行的虚拟机字节码指令地址，即当前线程执行的字节码的行号指示器（注意：JVM不是直接执行Java代码，而是执行.class文件，所以只要其他编程语言能翻译成.class文件一样能放入JVM中执行）。 <strong>JVM会给每个线程一个独立的程序计数器</strong>，计数器之间互不影响 ，且通过线程轮流切换并且分配处理器执行时间来实现JVM的多线程。不过当线程执行的是Native方法的时候这个计数器中的值为undefined。</p><h3 id="2、Java虚拟机栈"><a href="#2、Java虚拟机栈" class="headerlink" title="2、Java虚拟机栈"></a>2、Java虚拟机栈</h3><p>和程序计数器一样的是<strong>Java虚拟机栈是线程私有</strong>，生命周期和线程相同。虚拟机栈描述的是<strong>Java方法</strong>执行的内存模型：每个<strong>方法在执行的时候都会创建栈帧</strong>，用来存储局部变量表，操作数栈，动态链接，方法出口等信息，每个方法从调用到执行完成的过程，就对应一个栈帧在虚拟机中入栈到出栈的过程，其中64位长度的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。 这里需要理解一下的就是为什么要用栈这个结构呢，比如A方法中调用了B方法，虚拟机中是先让A方法的栈帧进入虚拟机栈执行，当执行到调用B方法的语句就让B栈帧进入，执行完之后B栈帧就出栈，A栈就继续执行。这里注意的是如果递归的方法递归的太深很容易抛出下面两种异常，所以递归虽然写起来方便，但是性能会有所下降，并且容易抛出异常。</p><p>Java虚拟机规范中，对这个区域规定了两种异常状况</p><p>i. 线程请求栈的深度大于虚拟机所允许栈的深度，将抛出Stack Overflow Error</p><p>ii. 如果虚拟机栈可以动态扩展且扩展时无法申请到足够的内存，会抛出OutOfMemoryError</p><h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>与虚拟机栈作用相似，不过是虚拟机栈为虚拟机执行Java方法提供，而本地方法为虚拟机使用到的Native方法服务，Native方法多是用C++写的。抛出的异常和虚拟机栈相同。</p><h3 id="4、Java堆"><a href="#4、Java堆" class="headerlink" title="4、Java堆"></a>4、Java堆</h3><p>Java堆是与前面的区域不同的是：这个区域是 <strong>被所有线程共享</strong> 的一块内存区域，用来<strong>存放对象实例，并为对象实例分配好内存</strong>。Java虚拟机规范中这样描述：所有对象实例以及数组都要在堆上分配。Java堆也是垃圾收集器管理的主要区域，也叫”GC堆“。由于现在的垃圾回收算法多是分代收集，所以Java堆里面又可分为：新生代和老年代。 并且根据Java虚拟机规范的规定：Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。有实例没有被分配，且堆无法再扩展的时候会抛出OutOfMemoryError异常，虚拟机调优其实也主要关注的是这个区域。</p><h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><p>与Java堆一样，<strong>线程共享</strong>，用来存储被虚拟机加载的<strong>类信息、常量、静态变量</strong>。这个区域Java虚拟机规范对其特别宽松，既可以像Java堆那样不需要连续内存，又可以选择固定大小和可扩展。还可以选择不实现垃圾收集，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。当无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h4 id="永久代和元空间"><a href="#永久代和元空间" class="headerlink" title="永久代和元空间"></a>永久代和元空间</h4><p>方法区是Java虚拟机规范中的定义，是一种规范，而永久代是HotSpot对方法区的一种实现，一个是标准一个是实现，即<strong>使用永久代来实现方法区</strong>；</p><ul><li>存储位置不同，永久代物理上是堆的一部分，和新生代，老年代地址是连续的，而元空间属于本地内存；</li><li>存储内容不同，<strong>元空间(一块区域)存储类的元信息</strong>，<strong>静态变量和常量池等并入堆中</strong>。相当于永久代的数据被分到了堆和元空间中。</li></ul><p>对于Java8， HotSpots取消了永久代， 取代永久代的就是元空间。虚拟机Hotspot已经将这部分存储空间<strong>从使用JVM内存换成使用本地内存</strong>，即这部分不再叫永久代，而是<strong>元空间</strong>。这个元空间实际上是JVM动态规定内存大小。</p><p>这个替换有什么优势呢？因为字符串常量池是存在永久代中，很容易出现性能问题，并且类和方法信息大小难确定，给永久代的的大小指定带来困难，而且GC会对永久代特殊处理，这就增加了GC的复杂性。从JDK1.7开始，<strong>字符串常量池就划分进了堆中</strong>，也使得元空间在内存划分的算法上更趋于合理。</p><h4 id="Class文件常量池"><a href="#Class文件常量池" class="headerlink" title="Class文件常量池"></a><strong>Class文件常量池</strong></h4><p>Class 文件常量池指的是编译生成的 class 字节码文件，其结构中有一项是常量池（Constant Pool Table），用于存放编译期生成的各种<strong>字面量和符号引用</strong>，这部分内容将<strong>在类加载后进入方法区的运行时常量池中存放</strong>。</p><p>这里的字面量是指<strong>字符串字面量和声明为 final 的（基本数据类型）常量值</strong>。</p><ul><li>字符串字面量：除了类中所有双引号括起来的字符串(包括方法体内的)，还包括所有用到的类名、方法的名字和这些类与方法的字符串描述、字段(成员变量)的名称和描述符；</li><li>声明为final的常量值：指的是类的<strong>成员变量</strong>，不包含本地变量，<strong>本地变量是属于方法的</strong>。这些都在常量池的 UTF-8 表中(逻辑上的划分)；</li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分，是一块内存区域。Class 文件常量池将在类加载后进入方法区的运行时常量池中存放。<strong>一个类加载到 JVM 中后对应一个运行时常量池</strong>，运行时常量池相对于 Class 文件常量池来说具备动态性，Class 文件常量只是一个静态存储结构，里面的引用都是符号引用。而运行时常量池可以在运行期间<strong>将符号引用解析为直接引用</strong>。可以说运行时常量池就是用来<strong>索引和查找字段和方法名称和描述符</strong>的。给定任意一个方法或字段的索引，通过这个索引最终可得到该方法或字段所属的类型信息和名称及描述符信息，这涉及到方法的调用和字段获取。</p><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p><strong>字符串常量池是全局</strong>的，JVM 中独此一份，因此也称为全局字符串常量池。</p><p>运行时常量池中的字符串字面量若是成员的，则在类的加载初始化阶段就使用到了字符串常量池；若是本地的，则在使用到的时候（执行此代码时）才会使用到字符串常量池。其实，“使用常量池”对应的字节码是一个 ldc 指令，在给 String 类型的引用赋值的时候会先执行这个指令，看常量池中是否存在这个字符串对象的引用，若有就直接返回这个引用，若没有，就在堆里创建这个字符串对象并在字符串常量池中记录下这个引用（jdk1.7)。</p><p>常量不一定只有编译期才能产生，运行期间也可以将新的常量放入池中。例如<strong>String的Intern()方法</strong>，同样抛出OutOfMemoryError异常。</p><h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><p>JVM 中除了字符串常量池，8种基本数据类型中除了两种浮点类型剩余的6种基本数据类型的包装类，都使用了缓冲池技术，但是 Byte、Short、Integer、Long、Character 这5种整型的包装类也只是在对应值在 [-128,127] 时才会使用缓冲池，超出此范围仍然会去创建新的对象。其中：</p><ul><li>在 jdk1.6（含）之前也是方法区的一部分，并且其中存放的是字符串的实例；</li><li>在 jdk1.7（含）之后是在堆内存之中，存储的是字符串对象的引用，字符串实例是在堆中；</li><li>jdk1.8 已移除永久代，字符串常量池是在本地内存当中，存储的也只是引用。</li></ul><h2 id="三、直接内存"><a href="#三、直接内存" class="headerlink" title="三、直接内存"></a>三、直接内存</h2><p>这个区域并不是属于运行时数据区域，但是这个区域也会被频繁使用，并且抛出OOM异常。这个区域主要是由于在JDK1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，通过一个储存在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</p><p>这样能避免在Java堆和Native堆中来回复制数据，从而在一些场景中显著提高性能。直接内存分配不会受到Java堆大小的限制，会受到本机总内存大小及处理器寻址空间的限制。会抛出OutOfMemoryError异常</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>只有程序计数器不会报出任何相关OOM异常，而Java虚拟机栈有可能会报出OOM或Stack Overflow异常。<strong>Java虚拟机栈主要是存储方法的一些信息</strong>，能让方法顺利的执行，而<strong>Java堆存储的是对象的信息</strong>。虚拟机的垃圾回收算法主要在这一块，并且平常调优的区域也是在这一块。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/xiaotian15/p/6971353.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaotian15/p/6971353.html</a></p><p><a href="https://www.tuicool.com/articles/Av6RZnU" target="_blank" rel="noopener">https://www.tuicool.com/articles/Av6RZnU</a></p><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，然后由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由&lt;strong&gt;JVM执行引擎&lt;/strong&gt;执行。&lt;/p&gt;
&lt;p&gt;那在整个程序执行过程中，JVM中怎么存取数据和相关信息呢？&lt;/p&gt;
&lt;p&gt;事实上在JVM中是用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://blackist.org/categories/Java/"/>
    
    
      <category term="开发" scheme="https://blackist.org/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="java" scheme="https://blackist.org/tags/java/"/>
    
      <category term="jvm" scheme="https://blackist.org/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM - 类加载过程</title>
    <link href="https://blackist.org/2019/07/06/java-jvm-classload-process/"/>
    <id>https://blackist.org/2019/07/06/java-jvm-classload-process/</id>
    <published>2019-07-06T05:53:54.000Z</published>
    <updated>2019-08-28T01:47:20.949Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开启Java程序员进阶之旅，比较难啃的JVM。</p><a id="more"></a><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>在聊 Java 类加载机制之前，需要先了解一下 Java 字节码，因为它和类加载机制息息相关。</p><p>计算机只认识 0 和 1，所以任何语言编写的程序都需要编译成机器码才能被计算机理解，然后执行，Java 也不例外。</p><p>Java 在诞生的时候喊出了一个非常牛逼的口号：“Write Once, Run Anywhere”，为了达成这个目的，Sun 公司发布了许多可以在不同平台（Windows、Linux）上运行的 Java 虚拟机（JVM）——负责载入和执行 Java 编译后的字节码。</p><p><img src="http://pic.blackist.top/dev-201907061328-272.png" alt></p><p>我们借助一段简单的代码来看一看，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.blackist.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"董亮亮的开发笔记"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码编译过后，通过十六进制工具 xxd JvmDemo.class命令查看这个字节码文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span>: cafe babe <span class="number">0000</span> <span class="number">0034</span> <span class="number">0022</span> <span class="number">0</span>a00 <span class="number">0600</span> <span class="number">1409</span>  .......<span class="number">4</span>."......</span><br><span class="line"><span class="number">00000010</span>: <span class="number">0015</span> <span class="number">0016</span> <span class="number">0800</span> <span class="number">170</span>a <span class="number">0018</span> <span class="number">0019</span> <span class="number">0700</span> <span class="number">1</span>a07  ................</span><br><span class="line"><span class="number">00000020</span>: <span class="number">001</span>b <span class="number">0100</span> <span class="number">063</span>c <span class="number">696</span>e <span class="number">6974</span> <span class="number">3</span>e01 <span class="number">0003</span> <span class="number">2829</span>  .....&lt;init&gt;...()</span><br><span class="line"><span class="number">00000030</span>: <span class="number">5601</span> <span class="number">0004</span> <span class="number">436</span>f <span class="number">6465</span> <span class="number">0100</span> <span class="number">0</span>f4c <span class="number">696</span>e <span class="number">654</span>e  V...Code...LineN</span><br><span class="line"><span class="number">00000040</span>: <span class="number">756</span>d <span class="number">6265</span> <span class="number">7254</span> <span class="number">6162</span> <span class="number">6</span>c65 <span class="number">0100</span> <span class="number">124</span>c <span class="number">6</span>f63  umberTable...Loc</span><br><span class="line"><span class="number">00000050</span>: <span class="number">616</span>c <span class="number">5661</span> <span class="number">7269</span> <span class="number">6162</span> <span class="number">6</span>c65 <span class="number">5461</span> <span class="number">626</span>c <span class="number">6501</span>  alVariableTable.</span><br></pre></td></tr></table></figure><p>这段字节码中的 <code>cafe babe</code> 被称为“魔数”，是 JVM 识别 .class 文件的标志。文件格式的定制者可以自由选择魔数值（只要没用过），比如说 .png 文件的魔数是 <code>89504e47</code>。</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>JVM结束生命周期的几种情况：</p><ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序执行过程中遇到异常或错误而异常终止</li><li>操作系统出现错误而导致JVM进程终止</li></ul><p>Java 的<strong>类加载过程</strong>可以分为 5 个阶段：载入、验证、准备、解析和初始化。这 5 个阶段一般是顺序发生的，但在动态绑定的情况下，解析阶段发生在初始化阶段之后。</p><p><img src="http://pic.blackist.top/dev-201907061107-828.png" alt></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>查找并加载类的二进制数据。</p><p>将类的.class文件中的二进制数据读入到内存，将其放在<strong>运行时数据区的方法区</strong>内，然后在堆去创建java.lang.Class对象，用来封装类在方法区内的数据结构。</p><p><img src="http://pic.blackist.top/dev-201907061321-381.png" alt></p><h4 id="加载-class的方式"><a href="#加载-class的方式" class="headerlink" title="加载.class的方式"></a>加载.class的方式</h4><ul><li>从本地加载</li><li>从网络上加载（URLClassLoader(URL[] urls)）</li><li><strong>从zip, jar等归档文件中加载.class文件</strong></li><li>从专有数据库提取.class文件</li><li>将Java源文件动态编译成.class文件</li></ul><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>确保被加载的类的正确性，符合JVM字节码规范，该阶段是保证 JVM 安全的重要屏障，下面是一些主要的检查。</p><ul><li>确保二进制字节流格式符合预期（比如说是否以 <code>cafe bene</code> 开头）。</li><li>是否所有方法都遵守访问控制关键字的限定。</li><li>方法调用的参数个数和类型是否正确。</li><li>确保变量在使用之前被正确初始化了。</li><li>检查变量是否被赋予恰当类型的值。</li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>JVM 会在该阶段对类变量（也称为静态变量， <code>static</code> 关键字修饰的）分配内存并初始化（对应数据类型的默认初始值，如 0、0L、null、false 等）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String blackist = <span class="string">"Blackist"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String note = <span class="string">"Note"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String bnote = <span class="string">"Note-of-Blackist"</span>;</span><br></pre></td></tr></table></figure><p>blackist不会被分配内存，而 note会；但 bnote的初始值不是“王二”而是 <code>null</code>。</p><p>需要注意的是， <code>static final</code> 修饰的变量被称作为常量，和类变量不同。常量一旦赋值就不会改变了，所以 bnote 在准备阶段的值为“沉默王二”而不是 <code>null</code>。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>该阶段将常量池中的符号引用转化为直接引用。</p><p><strong>符号引用</strong>以一组符号（任何形式的字面量，只要在使用时能够无歧义的定位到目标即可）来描述所引用的目标。</p><p>在编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如 <code>org.blackist.Quiz</code> 类引用了 <code>org.blackist.Bnote</code>类，编译时 Quiz类并不知道 Bnote类的实际内存地址，因此只能使用符号 <code>org.blackist.Bnote</code>。</p><p><strong>直接引用</strong>通过对符号引用进行解析，找到引用的实际内存地址。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类变量已经被赋过默认初始值，而在初始化阶段为类的静态变量赋予正确的初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="comment">// 准备阶段默认值为0，初始化阶段赋值3</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> foo = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 也可写为</span></span><br><span class="line">peivate <span class="keyword">static</span> <span class="keyword">int</span> foo;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">foo = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态代码块从上到下顺序执行，foo最终等于4</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">foo = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换句话说，初始化阶段是执行类构造器方法的过程。</p><h2 id="Java程序对类的使用"><a href="#Java程序对类的使用" class="headerlink" title="Java程序对类的使用"></a>Java程序对类的使用</h2><h3 id="主动使用（六种）"><a href="#主动使用（六种）" class="headerlink" title="主动使用（六种）"></a>主动使用（六种）</h3><ul><li>创建类的实例（new Test();）</li><li>访问某个类的或接口的静态变量，或对该静态变量赋值（int b = Test.a; Test.a = b;）</li><li>调用类的静态方法 （Test.foo()）</li><li>反射（ClassForName(“org.blackst.demo.Quiz”)）</li><li>初始化类的子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化子类，对父类进行了主动使用</span></span><br><span class="line">Child.a = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><ul><li>JVM启动时被标为启动类的类（如JavaTest，java  org.blackist.Test）</li></ul><p>所有JVM实现必须在每个类或接口被Java程序 <strong>首次主动使用</strong> 时才初始化。</p><h3 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h3><p>除了主动使用以外的使用，都不会导致类的初始化。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下程序：</p><p><img src="http://pic.blackist.top/dev-201907061030-765.png" alt></p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开启Java程序员进阶之旅，比较难啃的JVM。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://blackist.org/categories/Java/"/>
    
    
      <category term="开发" scheme="https://blackist.org/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="java" scheme="https://blackist.org/tags/java/"/>
    
      <category term="jvm" scheme="https://blackist.org/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 - 6大原则</title>
    <link href="https://blackist.org/2019/07/02/java-design-patterns-6principles/"/>
    <id>https://blackist.org/2019/07/02/java-design-patterns-6principles/</id>
    <published>2019-07-02T02:13:03.000Z</published>
    <updated>2019-07-02T15:55:08.055Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>关于设计模式的六大设计原则的资料网上很多，但是很多地方解释地都太过于笼统化，我也找了很多资料来看，发现CSDN上有几篇关于设计模式的六大原则讲述的比较通俗易懂，因此转载过来。</p><a id="more"></a><h2 id="一-单一职责原则"><a href="#一-单一职责原则" class="headerlink" title="一.单一职责原则"></a>一.单一职责原则</h2><p>　　原文链接：<a href="http://blog.csdn.net/lovelion/article/details/7536542" target="_blank" rel="noopener">http://blog.csdn.net/lovelion/article/details/7536542</a></p><p>　　单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。单一职责原则定义如下：</p><blockquote><p>单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p></blockquote><p>​      单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。</p><p>​      单一职责原则是实现<strong>高内聚、低耦合</strong>的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。</p><p>​      下面通过一个简单实例来进一步分析单一职责原则：</p><p>​      Sunny软件公司开发人员针对某CRM（Customer Relationship  Management，客户关系管理）系统中客户信息图形统计模块提出了如图1所示初始设计方案：</p><p><img src="http://pic.blackist.top/dev-201907020942-209.png" alt="图1  初始设计方案结构图"></p><p>​      在图1中，CustomerDataChart类中的方法说明如下：getConnection()方法用于连接数据库，findCustomers()用于查询所有的客户信息，createChart()用于创建图表，displayChart()用于显示图表。</p><p>​      在图1中，CustomerDataChart类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用findCustomers()方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，类CustomerDataChart可拆分为如下三个类：</p><p>​      (1) DBUtil：负责连接数据库，包含数据库连接方法getConnection()；</p><p>​      (2) CustomerDAO：负责操作数据库中的Customer表，包含对Customer表的增删改查等方法，如findCustomers()；</p><p>​      (3) CustomerDataChart：负责图表的生成和显示，包含方法createChart()和displayChart()。</p><p>​      使用单一职责原则重构后的结构如图2所示：</p><p><img src="https://images0.cnblogs.com/i/288799/201408/181908472844755.jpg" alt="img"></p><h2 id="二-开闭原则"><a href="#二-开闭原则" class="headerlink" title="二.开闭原则"></a>二.开闭原则</h2><p>　　原文链接：<a href="http://blog.csdn.net/lovelion/article/details/7537584" target="_blank" rel="noopener">http://blog.csdn.net/lovelion/article/details/7537584</a></p><p>　　开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。开闭原则由<strong>Bertrand  Meyer</strong>于1988年提出，其定义如下：</p><blockquote><p>开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p></blockquote><p>​      在开闭原则的定义中，<strong>软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类</strong>。</p><p>​      任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。</p><p>​      为了满足开闭原则，需要对系统进行抽象化设计，<strong>抽象化是开闭原则的关键</strong>。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</p><p>​      Sunny软件公司开发的CRM系统可以显示各种类型的图表，如饼状图和柱状图等，为了支持多种图表显示方式，原始设计方案如图1所示：</p><p><img src="http://pic.blackist.top/dev-201907020944-314.png" alt="图1 初始设计方案结构图"></p><p>​    在ChartDisplay类的display()方法中存在如下代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (type.equals(<span class="string">"pie"</span>)) &#123;</span><br><span class="line">    PieChart chart = <span class="keyword">new</span> PieChart();</span><br><span class="line">    chart.display();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"bar"</span>)) &#123;</span><br><span class="line">    BarChart chart = <span class="keyword">new</span> BarChart();</span><br><span class="line">    chart.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​      在该代码中，如果需要增加一个新的图表类，如折线图LineChart，则需要修改ChartDisplay类的display()方法的源代码，增加新的判断逻辑，违反了开闭原则。</p><p>​      在本实例中，由于在ChartDisplay类的display()方法中针对每一个图表类编程，因此增加新的图表类不得不修改源代码。可以通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码，满足开闭原则。具体做法如下：</p><p>​      (1) 增加一个抽象图表类AbstractChart，将各种具体图表类作为其子类；</p><p>​      (2)  ChartDisplay类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表。</p><p>​      重构后结构如图2所示：</p><p><img src="http://pic.blackist.top/dev-201907020952-241.png" alt="图2"></p><p><strong>图2 重构后的结构图</strong></p><p>​      在图2中，我们引入了抽象图表类AbstractChart，且ChartDisplay针对抽象图表类进行编程，并通过setChart()方法由客户端来设置实例化的具体图表对象，在ChartDisplay的display()方法中调用chart对象的display()方法显示图表。如果需要增加一种新的图表，如折线图LineChart，只需要将LineChart也作为AbstractChart的子类，在客户端向ChartDisplay中注入一个LineChart对象即可，无须修改现有类库的源代码。    </p><p>​       注意：因为xml和properties等格式的配置文件是纯文本文件，可以直接通过VI编辑器或记事本进行编辑，且无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码或C#代码没有做任何修改，该系统即可认为是一个符合开闭原则的系统。</p><h2 id="三-里氏替换原则"><a href="#三-里氏替换原则" class="headerlink" title="三.里氏替换原则"></a>三.里氏替换原则</h2><p>　　原文链接：<a href="http://blog.csdn.net/lovelion/article/details/7540445" target="_blank" rel="noopener">http://blog.csdn.net/lovelion/article/details/7540445</a></p><p>　　里氏代换原则由2008年图灵奖得主、美国第一位计算机科学女博士<strong>Barbara Liskov</strong>教授和卡内基·梅隆大学Jeannette Wing教授于1994年提出。其严格表述如下：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。这个定义比较拗口且难以理解，因此我们一般使用它的另一个通俗版定义：</p><blockquote><p>里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p></blockquote><p>​      里氏代换原则告诉我们，<strong>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。</strong>例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。</p><p>​      例如有两个类，一个类为BaseClass，另一个是SubClass类，并且SubClass类是BaseClass类的子类，那么一个方法如果可以接受一个BaseClass类型的基类对象base的话，如：method1(base)，那么它必然可以接受一个BaseClass类型的子类对象sub，method1(sub)能够正常运行。反过来的代换不成立，如一个方法method2接受BaseClass类型的子类对象sub为参数：method2(sub)，那么一般而言不可以有method2(base)，除非是重载方法。</p><p>​      里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此<strong>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象</strong>。</p><p>​      在使用里氏代换原则时需要注意如下几个问题：</p><p>​      (1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。</p><p>​      (2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。</p><p>​      (3) Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。</p><p>在Sunny软件公司开发的CRM系统中，客户(Customer)可以分为VIP客户(VIPCustomer)和普通客户(CommonCustomer)两类，系统需要提供一个发送Email的功能，原始设计方案如图1所示：</p><p><img src="http://pic.blackist.top/dev-201907020953-812.png" alt="图1"></p><p>​    无论是普通客户还是VIP客户，发送邮件的过程都是相同的，也就是说两个send()方法中的代码重复，而且在本系统中还将增加新类型的客户。为了让系统具有更好的扩展性，同时减少代码重复，使用里氏代换原则对其进行重构。</p><p>​      在本实例中，可以考虑增加一个新的抽象客户类Customer，而将CommonCustomer和VIPCustomer类作为其子类，邮件发送类EmailSender类针对抽象客户类Customer编程，根据里氏代换原则，能够接受基类对象的地方必然能够接受子类对象，因此将EmailSender中的send()方法的参数类型改为Customer，如果需要增加新类型的客户，只需将其作为Customer类的子类即可。重构后的结构如图2所示：</p><p><img src="http://pic.blackist.top/dev-201907020954-854.png" alt></p><p><strong>图2  重构后的结构图</strong></p><p>​      <strong>里氏代换原则是实现开闭原则的重要方式之一。</strong>在本实例中，在传递参数时使用基类对象，除此以外，在定义成员变量、定义局部变量、确定方法返回类型时都可使用里氏代换原则。针对基类编程，在程序运行时再确定具体子类。</p><p>　　另外补充一篇关于里氏替换原则的一篇博文：</p><p>　　<a href="http://blog.csdn.net/zhengzhb/article/details/7281833" target="_blank" rel="noopener">http://blog.csdn.net/zhengzhb/article/details/7281833</a></p><h2 id="四-依赖倒置原则"><a href="#四-依赖倒置原则" class="headerlink" title="四.依赖倒置原则"></a>四.依赖倒置原则</h2><p>　　原文链接：<a href="http://blog.csdn.net/lovelion/article/details/7562783" target="_blank" rel="noopener">http://blog.csdn.net/lovelion/article/details/7562783</a></p><p>　　如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。依赖倒转原则是<strong>Robert C. Martin</strong>在1996年为“C++Reporter”所写的专栏Engineering Notebook的第三篇，后来加入到他在2002年出版的经典著作“<strong>Agile Software Development, Principles, Patterns, and Practices</strong>”一书中。依赖倒转原则定义如下：</p><blockquote><p>依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p></blockquote><p>​      依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</p><p>​      在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p><p>​      在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过<strong>依赖注入(DependencyInjection, DI)</strong>的方式注入到其他对象中，<strong>依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象</strong>。常用的注入方式有三种，分别是：<strong>构造注入，设值注入（Setter注入）和接口注入</strong>。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</p><p>​      下面通过一个简单实例来加深对依赖倒转原则的理解：</p><p>​      Sunny软件公司开发人员在开发某CRM系统时发现：该系统经常需要将存储在TXT或Excel文件中的客户信息转存到数据库中，因此需要进行数据格式转换。在客户数据操作类中将调用数据格式转换类的方法实现格式转换和数据库插入操作，初始设计方案结构如图1所示：</p><p><img src="http://pic.blackist.top/dev-201907020956-327.png" alt="图1"></p><p>​            在编码实现图1所示结构时，Sunny软件公司开发人员发现该设计方案存在一个非常严重的问题，由于每次转换数据时数据来源不一定相同，因此需要更换数据转换类，如有时候需要将TXTDataConvertor改为ExcelDataConvertor，此时，需要修改CustomerDAO的源代码，而且在引入并使用新的数据转换类时也不得不修改CustomerDAO的源代码，系统扩展性较差，违反了开闭原则，现需要对该方案进行重构。</p><p>在本实例中，由于CustomerDAO针对具体数据转换类编程，因此在增加新的数据转换类或者更换数据转换类时都不得不修改CustomerDAO的源代码。我们可以通过引入抽象数据转换类解决该问题，在引入抽象数据转换类DataConvertor之后，CustomerDAO针对抽象类DataConvertor编程，而将具体数据转换类名存储在配置文件中，符合依赖倒转原则。根据里氏代换原则，程序运行时，具体数据转换类对象将替换DataConvertor类型的对象，程序不会出现任何问题。更换具体数据转换类时无须修改源代码，只需要修改配置文件；如果需要增加新的具体数据转换类，只要将新增数据转换类作为DataConvertor的子类并修改配置文件即可，原有代码无须做任何修改，满足开闭原则。重构后的结构如图2所示：</p><p><img src="http://pic.blackist.top/dev-201907020957-332.png" alt="图2"></p><p>​    </p><p>​      在上述重构过程中，我们使用了开闭原则、里氏代换原则和依赖倒转原则，在大多数情况下，这三个设计原则会同时出现，<strong>开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段</strong>，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。</p><h2 id="五-接口隔离原则"><a href="#五-接口隔离原则" class="headerlink" title="五.接口隔离原则"></a>五.接口隔离原则</h2><p>　　原文链接：<a href="http://blog.csdn.net/lovelion/article/details/7562842" target="_blank" rel="noopener">http://blog.csdn.net/lovelion/article/details/7562842</a></p><p>　　接口隔离原则定义如下：</p><blockquote><p>接口隔离原则(Interface  Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p></blockquote><p>​      根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。<strong>每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。</strong>这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同：</p><p>​      (1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“<strong>角色隔离原则</strong>”。</p><p>​      (2) 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指<strong>接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口</strong>。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“<strong>定制服务</strong>”，即为不同的客户端提供宽窄不同的接口。</p><p>​      下面通过一个简单实例来加深对接口隔离原则的理解：</p><p>Sunny软件公司开发人员针对某CRM系统的客户数据显示模块设计了如图1所示接口，其中方法dataRead()用于从文件中读取数据，方法transformToXML()用于将数据转换成XML格式，方法createChart()用于创建图表，方法displayChart()用于显示图表，方法createReport()用于创建文字报表，方法displayReport()用于显示文字报表。</p><p><img src="http://pic.blackist.top/dev-201907020958-882.png" alt="图1"></p><p>​      在实际使用过程中发现该接口很不灵活，例如如果一个具体的数据显示类无须进行数据转换（源文件本身就是XML格式），但由于实现了该接口，将不得不实现其中声明的transformToXML()方法（至少需要提供一个空实现）；如果需要创建和显示图表，除了需实现与图表相关的方法外，还需要实现创建和显示文字报表的方法，否则程序编译时将报错。</p><p>​      在图1中，由于在接口CustomerDataDisplay中定义了太多方法，即该接口承担了太多职责，一方面导致该接口的实现类很庞大，在不同的实现类中都不得不实现接口中定义的所有方法，灵活性较差，如果出现大量的空方法，将导致系统中产生大量的无用代码，影响代码质量；另一方面由于客户端针对大接口编程，将在一定程序上破坏程序的封装性，客户端看到了不应该看到的方法，没有为客户端定制接口。因此需要将该接口按照接口隔离原则和单一职责原则进行重构，将其中的一些方法封装在不同的小接口中，确保每一个接口使用起来都较为方便，并都承担某一单一角色，每个接口中只包含一个客户端（如模块或类）所需的方法即可。</p><p>​      通过使用接口隔离原则，本实例重构后的结构如图2所示：</p><p><img src="http://pic.blackist.top/dev-201907020959-680.png" alt="图2"></p><p>​     <strong>在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。</strong>一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</p><h2 id="六-迪米特法则"><a href="#六-迪米特法则" class="headerlink" title="六.迪米特法则"></a>六.迪米特法则</h2><p>　　原文链接：<a href="http://blog.csdn.net/lovelion/article/details/7563445" target="_blank" rel="noopener">http://blog.csdn.net/lovelion/article/details/7563445</a></p><p>　　迪米特法则来自于1987年美国东北大学(Northeastern University)一个名为“Demeter”的研究项目。迪米特法则又称为最少知识原则(LeastKnowledge Principle, LKP)，其定义如下：</p><blockquote><p>迪米特法则(Law of  Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。</p></blockquote><p>​      如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。<strong>迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</strong></p><p>​      迪米特法则还有几种定义形式，包括<strong>：**</strong>不要和“陌生人”说话<strong>、</strong>只与你的直接朋友通信**等，在迪米特法则中，对于一个对象，其朋友包括以下几类：</p><p>​      (1) 当前对象本身(this)；</p><p>​     (2) 以参数形式传入到当前对象方法中的对象；</p><p>​      (3) 当前对象的成员对象；</p><p>​      (4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；</p><p>​      (5) 当前对象所创建的对象。</p><p>​      任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</p><p>​      迪米特法则要求我们在设计系统时，<strong>应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用</strong>。简言之，就是<strong>通过引入一个合理的第三者来降低现有对象之间的耦合度</strong>。</p><p>​      在将迪米特法则运用到系统设计中时，要注意下面的几点：<strong>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及</strong>；<strong>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限</strong>；<strong>在类的设计上，只要有可能，一个类型应当设计成不变类</strong>；<strong>在对其他类的引用上，一个对象对其他对象的引用应当降到最低</strong>。</p><p>​      下面通过一个简单实例来加深对迪米特法则的理解：</p><p>Sunny软件公司所开发CRM系统包含很多业务操作窗口，在这些窗口中，某些界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应，例如，当一个按钮(Button)被单击时，对应的列表框(List)、组合框(ComboBox)、文本框(TextBox)、文本标签(Label)等都将发生改变，在初始设计方案中，界面控件之间的交互关系可简化为如图1所示结构：</p><p><img src="http://pic.blackist.top/dev-201907021001-129.png" alt="图1"></p><p>​      在本实例中，可以通过引入一个专门用于控制界面控件交互的中间类(Mediator)来降低界面控件之间的耦合度。引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码，重构后结构如图2所示：</p><p><img src="http://pic.blackist.top/dev-201907021001-501.png" alt="图2"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/LoveLion/article/category/738450/7" target="_blank" rel="noopener">http://blog.csdn.net/LoveLion/article/category/738450/7</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于设计模式的六大设计原则的资料网上很多，但是很多地方解释地都太过于笼统化，我也找了很多资料来看，发现CSDN上有几篇关于设计模式的六大原则讲述的比较通俗易懂，因此转载过来。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://blackist.org/categories/Java/"/>
    
    
      <category term="开发" scheme="https://blackist.org/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="java" scheme="https://blackist.org/tags/java/"/>
    
      <category term="设计模式" scheme="https://blackist.org/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java中&#39;==&#39; 和 equals()</title>
    <link href="https://blackist.org/2019/06/27/java-oo-equals/"/>
    <id>https://blackist.org/2019/06/27/java-oo-equals/</id>
    <published>2019-06-27T04:51:59.000Z</published>
    <updated>2019-06-29T13:53:18.287Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“判断两个事物是否相等”，是编程中最常见的操作之一，在Java中，判断是否相等有两种方法，一种是使用“==”判断符，另一种是使用“equals()”方法，你是否曾因混用二者导致不可思议的bug？本篇文章将带你深入二者背后的判断原理。</p><a id="more"></a><h1 id="相等判断符”-”"><a href="#相等判断符”-”" class="headerlink" title="相等判断符”==”"></a>相等判断符”==”</h1><blockquote><p>“==”相等判断符用于比较基本数据类型和引用类型数据。当比较基本数据类型的时候比较的是数值，当比较引用类型数据时比较的是引用(指针)。</p></blockquote><h2 id="“-”判断基本类型数据"><a href="#“-”判断基本类型数据" class="headerlink" title="“==”判断基本类型数据"></a>“==”判断基本类型数据</h2><p>基本数据类型指的是Java中的八大数据类型：byte，short，int，long，float，double，char，boolean。</p><p>这八大基本数据类型有个共同的特点是它们在内存中是有具体值的, 比如说一个 int 类型的数据”2”，它在8位数据总线的机器上保存形式为 0000 0010。（8位机器是假设的）</p><p>当使用 == 比较两个基本数据类型的时候, 就是在比较它们各自在内存中的值。</p><p>为了照顾到要刨根问底的同学，再补充一下两个数值是怎么比较的：cpu 在比较的时候会将两个值作差，然后查看标志寄存器。标志寄存器存放的是运算的结果，里面有一个是否为0的标志位，如果该位为1，证明二者之差为0，二者相等。</p><h2 id="“-”判断引用类型数据"><a href="#“-”判断引用类型数据" class="headerlink" title="“==”判断引用类型数据"></a>“==”判断引用类型数据</h2><p>引用数据类型在字面上也是很好理解的, 它就是一个引用, 指向堆内存中一个具体的对象。</p><p>比如说<code>Student stu = new Student();</code> 这里的 stu 就是一个引用，它指向的是当前 new 出来的 <strong>Student</strong> 对象. 当我们想要操作这个 <strong>Student</strong> 对象时, 只需要操作引用即可, 比如说<code>int age = stu.getAge();</code>。</p><p>所以用”==”判断两个引用数据类型是否相等的时候，实际上是在判断两个引用<strong>是否指向同一个对象</strong>。</p><p>看下面的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s1 = &quot;hello&quot;;    //s1指向字符串常量池中的&quot;hello&quot;字符串对象</span><br><span class="line">    String s2 = &quot;hello&quot;;    //s2也指向字符串常量池中的&quot;hello&quot;字符串对象</span><br><span class="line">    System.out.println(s1 == s2);   //true</span><br><span class="line"></span><br><span class="line">    String s3 = new String(&quot;hello&quot;);   //s3指向的是堆内存中的字符串对象 </span><br><span class="line">    System.out.println(s1 == s3);    //false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子可以看到，由于引用”s1”和”s2”指向的都是常量池中的”hello”字符串，所以返回true。（后面我会发布一篇详细讲述Java字符串的文章，涉及字符串初始化和字符串常量池等知识）</p><p>而”s3”指向的是新创建字符串对象，因为只要动用了<code>new</code>关键字, 就会在堆内存创建一个新的对象。</p><p>也就是说 s1 和 s3 指向的是不同的字符串对象，所以返回false。</p><h1 id="相等判断方法equals"><a href="#相等判断方法equals" class="headerlink" title="相等判断方法equals()"></a>相等判断方法equals()</h1><blockquote><p>equals()和 == 有着本质的区别，== 可以看作是对“操作系统比较数据手段”的封装，而equals()则是每个对象自带的比较方法，它是Java自定义的比较规则。</p></blockquote><p>equals()和 == 的本质区别更通俗的说法是：==的比较规则是定死的，就是比较两个数据的值。</p><p>而 equals() 的比较规则是不固定的，可以由用户自己定义。</p><p>看下面的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String s1 = &quot;hello&quot;;</span><br><span class="line">    String s3 = new String(&quot;hello&quot;);    </span><br><span class="line">    System.out.println(s1.equals(s3));    //true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回想前面的案例：用 == 比较的时候, 上面 s1 和 s3 比较出的结果为false。而当用 equals() 比较的时候，得出的结果为 true。</p><p>想知道原因我们还得看源码，下面是 String 类中的 equals() 方法的源码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    if (this == anObject) &#123;    //先比较两个字符串的引用是否相等(是否指向同一个对象), 是直接返回true</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (anObject instanceof String) &#123;    //两个引用不等还会继续比较</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        int n = value.length;</span><br><span class="line">        if (n == anotherString.value.length) &#123;</span><br><span class="line">            char v1[] = value;    //字符串类是用字符数组实现的, 先要拿到两个字符串的字符数组</span><br><span class="line">            char v2[] = anotherString.value;</span><br><span class="line">            int i = 0;</span><br><span class="line">            while (n-- != 0) &#123;    //然后对两个数组逐个字符地进行比较</span><br><span class="line">                if (v1[i] != v2[i])</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码可以看到, 当调用 String 类型数据的 equals() 方法时，首先会判断两个字符串的引用是否相等，也就是说两个字符串引用是否指向同一个对象，是则返回true。</p><p>如果不是指向同一个对象，则把两个字符串中的字符挨个进行比较。由于 s1 和 s3 字符串都是 “hello”，是可以匹配成功的，所以最终返回 true。</p><h3 id="HashMap中containsKey-的实现"><a href="#HashMap中containsKey-的实现" class="headerlink" title="HashMap中containsKey()的实现"></a>HashMap<string, object>中containsKey()的实现</string,></h3><p>比较的是key的hash code和参数字符串的hash code。</p><h1 id="思考：为什么要设计equals-方法"><a href="#思考：为什么要设计equals-方法" class="headerlink" title="思考：为什么要设计equals()方法?"></a>思考：为什么要设计equals()方法?</h1><p>通过上面的讲解，相信你已经知道 == 和 equals() 的区别了：一个的比较规则是定死的，一个是可以由编程人员自己定义的。</p><p>可是为什么会有 equals() 方法, 而且还可以被自由定制呢?</p><p>这个问题要落到Java语言的核心 —— 面向对象思想了。</p><p>Java 不同于面向过程的C语言，Java是一款面向对象的高级语言。如果是面向过程编程，直接操作内存上存储的数据的话，用 == 所定义的规则来判断两个数据是否相等已经足够了。</p><p>而Java中万物皆对象，我们经常要面临的问题是这两个对象是否相等，而不是这两串二进制数是否相等，仅有 == 是完全不够用的。</p><p>由于Java程序员们会创建各种满足它们业务需求的对象，<strong>系统无法提前知道两个对象在什么条件下算相等，Java干脆把判断对象是否相等的权力交给编程人员</strong>。</p><p>具体的措施是：所有的类都必须继承 Object 类，而 Object 类中写有equals()方法。编程人员可以通过重写 equals() 方法来实现自己的比较策略，也可以不重写，使用Object类的equals()比较策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Object类中的equals()方法源码</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 Object 类的 equals() 源码可以看到，如果编程人员没有显示地重写 equals() 方法，则默认比较两个引用是否指向同一个对象。</p><blockquote><p>补充: 关于基本数据类型包装类的比较</p></blockquote><p>由于 Java 中万物皆对象，就连基本数据类型也有其对应的包装类，那么它们对应的比较策略是什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int a = 3;</span><br><span class="line">    Integer b = new Integer(3);</span><br><span class="line">    System.out.println(b.equals(a));    //true, 自动装箱</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到尽管两个引用不同, 但是输出的结果仍为 true, 证明 Integer 包装类重写了 equals() 方法，追踪其源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Integer类中的equals方法</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    if (obj instanceof Integer) &#123;</span><br><span class="line">        return value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码看到，基本类型包装类在重写equals()后，比较的还是基本数据类型的值。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>通过探索 == 和 equals() 的区别，我们摸清楚了二者别后的比较策略，同时也对 Java 中 equals() 方法的设计进行了思考，相信大家在今后的 Java 编程实战中不会再为相等判断而烦恼了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzU3NzczMTAzMg==&amp;mid=2247484502&amp;idx=1&amp;sn=3a1c33f1775f8af94edd93c03413f432&amp;chksm=fd0164e1ca76edf75b1aaf63ccfa06ea9d43cb3cb7459227b7add1c25c9966efffde16dc9f45&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;key=f9a007895c9d38fdc97b2511d304b22f97950d025d0ab083a0988ec7cf2b231d0784acf364b69e05d4fe91447ef43637a0cf1b239f86bcb0c8683f102ea13775c7c173047a60c206c8eb92b24c680103&amp;ascene=1&amp;uin=MTM3MzI2NTQzNA%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=77Xn2iRJGL%2Bq0VUqT2p92TrsIaljOa8bijuNJ33II0J4pt7IRVYbqeUIuau8VVPc" target="_blank" rel="noopener"><a href="https://mp.weixin.qq.com/s?__biz=MzU3NzczMTAzMg==&amp;mid=2247484502&amp;idx=1&amp;sn=3a1c33f1775f8af94edd93c03413f432&amp;chksm=fd0164e1ca76edf75b1aaf63ccfa06ea9d43cb3cb7459227b7add1c25c9966efffde16dc9f45&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;key=f9a007895c9d38fdc97b2511d304b22f97950d025d0ab083a0988ec7cf2b231d0784acf364b69e05d4fe91447ef43637a0cf1b239f86bcb0c8683f102ea13775c7c173047a60c206c8eb92b24c680103&amp;ascene=1&amp;uin=MTM3MzI2NTQzNA%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=77Xn2iRJGL%2Bq0VUqT2p92TrsIaljOa8bijuNJ33II0J4pt7IRVYbqeUIuau8VVPc" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU3NzczMTAzMg==&amp;mid=2247484502&amp;idx=1&amp;sn=3a1c33f1775f8af94edd93c03413f432&amp;chksm=fd0164e1ca76edf75b1aaf63ccfa06ea9d43cb3cb7459227b7add1c25c9966efffde16dc9f45&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;key=f9a007895c9d38fdc97b2511d304b22f97950d025d0ab083a0988ec7cf2b231d0784acf364b69e05d4fe91447ef43637a0cf1b239f86bcb0c8683f102ea13775c7c173047a60c206c8eb92b24c680103&amp;ascene=1&amp;uin=MTM3MzI2NTQzNA%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=77Xn2iRJGL%2Bq0VUqT2p92TrsIaljOa8bijuNJ33II0J4pt7IRVYbqeUIuau8VVPc</a></a></p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“判断两个事物是否相等”，是编程中最常见的操作之一，在Java中，判断是否相等有两种方法，一种是使用“==”判断符，另一种是使用“equals()”方法，你是否曾因混用二者导致不可思议的bug？本篇文章将带你深入二者背后的判断原理。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://blackist.org/categories/Java/"/>
    
    
      <category term="开发" scheme="https://blackist.org/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="java" scheme="https://blackist.org/tags/java/"/>
    
      <category term="面向对象" scheme="https://blackist.org/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Hash在Java中的应用</title>
    <link href="https://blackist.org/2019/06/26/java-hash/"/>
    <id>https://blackist.org/2019/06/26/java-hash/</id>
    <published>2019-06-26T06:07:15.000Z</published>
    <updated>2019-06-29T13:53:18.287Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>雅虎的 Chief Scientist ，Udi Manber 曾说过，在 yahoo 所应用的算法中，最重要的三个是：Hash，Hash 和 Hash。其实从上文中所举的git用sha1判断文件更改，密码用MD5生成摘要后加盐等等对Hash的应用可看出，Hash的在计算机世界扮演着多么重要的角色。</p><a id="more"></a><h3 id="1-HashMap的复杂度"><a href="#1-HashMap的复杂度" class="headerlink" title="1 HashMap的复杂度"></a>1 HashMap的复杂度</h3><p>在介绍HashMap的实现之前，先考虑一下，HashMap与ArrayList和LinkedList在数据复杂度上有什么区别。下图是他们的性能对比图：</p><table><thead><tr><th>获取</th><th>查找</th><th>添加/删除</th><th>空间</th><th></th></tr></thead><tbody><tr><td>ArrayList</td><td>O(1)</td><td>O(1)</td><td>O(N)</td><td>O(N)</td></tr><tr><td>LinkedList</td><td>O(N)</td><td>O(N)</td><td>O(1)</td><td>O(N)</td></tr><tr><td>HashMap</td><td>O(N/Bucket_size)</td><td>O(N/Bucket_size)</td><td>O(N/Bucket_size)</td><td>O(N)</td></tr></tbody></table><p>可以看出HashMap整体上性能都非常不错，但是不稳定，为O(N/Buckets)，N就是以数组中没有发生碰撞的元素，Buckets是因碰撞产生的链表。</p><blockquote><p>注：发生碰撞实际上是非常稀少的，所以N/Bucket_size约等于1</p></blockquote><p>HashMap是对Array与Link的折衷处理，Array与Link可以说是两个速度方向的极端，Array注重于数据的获取，而处理修改（添加/删除）的效率非常低；Link由于是每个对象都保持着下一个对象的指针，查找某个数据需要遍历之前所有的数据，所以效率比较低，而在修改操作中比较快。</p><h3 id="2-HashMap的实现"><a href="#2-HashMap的实现" class="headerlink" title="2 HashMap的实现"></a>2 HashMap的实现</h3><p>本文以JDK8的API实现进行分析</p><h4 id="2-1-对key进行Hash计算"><a href="#2-1-对key进行Hash计算" class="headerlink" title="2.1 对key进行Hash计算"></a>2.1 对key进行Hash计算</h4><p>在JDK8中，由于使用了红黑树来处理大的链表开销，所以hash这边可以更加省力了，只用计算hashCode并移动到低位就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    //计算hashCode，并无符号移动到低位</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子: 363771819^(363771819 &gt;&gt;&gt; 16)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0001 0101 1010 1110 1011 0111 1010 1011(363771819)</span><br><span class="line">0000 0000 0000 0000 0001 0101 1010 1110(5550) XOR</span><br><span class="line">--------------------------------------- =</span><br><span class="line">0001 0101 1010 1110 1010 0010 0000 0101(363766277)</span><br></pre></td></tr></table></figure><p>这样做可以实现了高地位更加均匀地混到一起。</p><p>下面给出在Java中几个常用的哈希码(hashCode)的算法。</p><ol><li>Object类的hashCode. 返回对象的经过处理后的内存地址，由于每个对象的内存地址都不一样，所以哈希码也不一样。这个是native方法，取决于JVM的内部设计，一般是某种C地址的偏移。</li><li>String类的hashCode. 根据String类包含的字符串的内容，根据一种特殊算法返回哈希码，只要字符串的内容相同，返回的哈希码也相同。</li><li>Integer等包装类，返回的哈希码就是Integer对象里所包含的那个整数的数值，例如Integer i1=new Integer(100), i1.hashCode的值就是100 。由此可见，2个一样大小的Integer对象，返回的哈希码也一样。</li><li>int，char这样的基础类，它们不需要hashCode，如果需要存储时，将进行自动装箱操作，计算方法同上。</li></ol><h4 id="2-2-获取到数组的index的位置"><a href="#2-2-获取到数组的index的位置" class="headerlink" title="2.2  获取到数组的index的位置"></a>2.2  获取到数组的index的位置</h4><p>计算了Hash，我们现在要把它插入数组中了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (tab.length - 1) &amp; hash；</span><br></pre></td></tr></table></figure><p>通过位运算，确定了当前的位置，因为HashMap数组的大小总是2^n，所以实际的运算就是 (0xfff…ff) &amp; hash ，这里的tab.length-1相当于一个mask，滤掉了大于当前长度位的hash，使每个i都能插入到数组中。</p><h4 id="2-3-生成包装类"><a href="#2-3-生成包装类" class="headerlink" title="2.3 生成包装类"></a>2.3 生成包装类</h4><p>这个对象是一个包装类，Node<k,v>，内部有key,value,hash还有next，可以看出来它是一个链表。</k,v></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">        //getter and setter .etc.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-插入包装类到数组"><a href="#2-4-插入包装类到数组" class="headerlink" title="2.4  插入包装类到数组"></a>2.4  插入包装类到数组</h4><p>(1). 如果输入当前的位置是空的，就插进去，如图，左为插入前，右为插入后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0           0</span><br><span class="line">|           |</span><br><span class="line">1 -&gt; null   1 - &gt; null</span><br><span class="line">|           |</span><br><span class="line">2 -&gt; null   2 - &gt; null</span><br><span class="line">|           | </span><br><span class="line">..-&gt; null   ..- &gt; null</span><br><span class="line">|           | </span><br><span class="line">i -&gt; null   i - &gt; new node</span><br><span class="line">|           |</span><br><span class="line">n -&gt; null   n - &gt; null</span><br></pre></td></tr></table></figure><p>(2). 如果当前位置已经有了node，且它们发生了碰撞，则新的放到前面，旧的放到后面，这叫做链地址法处理冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0           0</span><br><span class="line">|           |</span><br><span class="line">1 -&gt; null   1 - &gt; null</span><br><span class="line">|           |</span><br><span class="line">2 -&gt; null   2 - &gt; null</span><br><span class="line">|           | </span><br><span class="line">..-&gt; null   ..- &gt; null</span><br><span class="line">|           | </span><br><span class="line">i -&gt; old    i - &gt; new - &gt; old</span><br><span class="line">|           |</span><br><span class="line">n -&gt; null   n - &gt; null</span><br></pre></td></tr></table></figure><p>我们可以发现，失败的hashCode算法会导致HashMap的性能由数组下降为链表，所以想要避免发生碰撞，就要提高hashCode结果的均匀性。</p><h3 id="3-扩容"><a href="#3-扩容" class="headerlink" title="3 扩容"></a>3 扩容</h3><p>如果当表中的75%已经被占用，即视为需要扩容了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(threshold = capacity * load factor ) &lt; size</span><br></pre></td></tr></table></figure><p>它主要有两个步骤：</p><h4 id="3-1-容量加倍"><a href="#3-1-容量加倍" class="headerlink" title="3.1 容量加倍"></a>3.1 容量加倍</h4><p>左移1位，就是扩大到两倍，用位运算取代了乘法运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newCap = oldCap &lt;&lt; 1;</span><br><span class="line">newThr = oldThr &lt;&lt; 1;</span><br></pre></td></tr></table></figure><h4 id="3-2-遍历计算Hash"><a href="#3-2-遍历计算Hash" class="headerlink" title="3.2 遍历计算Hash"></a>3.2 遍历计算Hash</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        //如果发现当前有Bucket</span><br><span class="line">        if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">            oldTab[j] = null;</span><br><span class="line">            //如果这里没有碰撞</span><br><span class="line">            if (e.next == null)</span><br><span class="line">                //重新计算Hash，分配位置</span><br><span class="line">                newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">            //这个见下面的新特性介绍，如果是树，就填入树</span><br><span class="line">            else if (e instanceof TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">            //如果是链表，就保留顺序....目前就看懂这点</span><br><span class="line">            else &#123; // preserve order</span><br><span class="line">                Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                Node&lt;K,V&gt; next;</span><br><span class="line">                do &#123;</span><br><span class="line">                    next = e.next;</span><br><span class="line">                    if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                        if (loTail == null)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        else</span><br><span class="line">                            loTail.next = e;</span><br><span class="line">                        loTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        if (hiTail == null)</span><br><span class="line">                            hiHead = e;</span><br><span class="line">                        else</span><br><span class="line">                            hiTail.next = e;</span><br><span class="line">                        hiTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; while ((e = next) != null);</span><br><span class="line">                if (loTail != null) &#123;</span><br><span class="line">                    loTail.next = null;</span><br><span class="line">                    newTab[j] = loHead;</span><br><span class="line">                &#125;</span><br><span class="line">                if (hiTail != null) &#123;</span><br><span class="line">                    hiTail.next = null;</span><br><span class="line">                    newTab[j + oldCap] = hiHead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由此可以看出扩容需要遍历并重新赋值，成本非常高，所以选择一个好的初始容量非常重要。</p><h3 id="4-扩容如何提升性能？"><a href="#4-扩容如何提升性能？" class="headerlink" title="4 扩容如何提升性能？"></a>4 扩容如何提升性能？</h3><ul><li>解决扩容损失：如果知道大致需要的容量，把初始容量设置好以解决扩容损失；<br> 比如我现在有1000个数据，需要 1000/0.75 = 1333 个坑位，又 1024 &lt; 1333 &lt; 2048，所以最好使用2048作为初始容量。</li><li>解决碰撞损失：使用高效的HashCode与loadFactor，这个…由于JDK8的高性能出现，这儿问题也不大了。</li></ul><h3 id="5-HashMap与HashTable的主要区别"><a href="#5-HashMap与HashTable的主要区别" class="headerlink" title="5 HashMap与HashTable的主要区别"></a>5 HashMap与HashTable的主要区别</h3><p>在很多的Java基础书上都已经说过了，他们的主要区别其实就是Table全局加了线程同步保护</p><ul><li>HashTable线程更加安全，代价就是因为它粗暴的添加了同步锁，所以会有性能损失。</li><li>其实有更好的concurrentHashMap可以替代HashTable，一个是方法级，一个是Class级。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/bf1d7eee28d0" target="_blank" rel="noopener">https://www.jianshu.com/p/bf1d7eee28d0</a></p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;雅虎的 Chief Scientist ，Udi Manber 曾说过，在 yahoo 所应用的算法中，最重要的三个是：Hash，Hash 和 Hash。其实从上文中所举的git用sha1判断文件更改，密码用MD5生成摘要后加盐等等对Hash的应用可看出，Hash的在计算机世界扮演着多么重要的角色。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://blackist.org/categories/Java/"/>
    
    
      <category term="开发" scheme="https://blackist.org/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="java" scheme="https://blackist.org/tags/java/"/>
    
      <category term="hash" scheme="https://blackist.org/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>校友录设计</title>
    <link href="https://blackist.org/2019/06/23/javaweb-ar-introduce/"/>
    <id>https://blackist.org/2019/06/23/javaweb-ar-introduce/</id>
    <published>2019-06-23T09:11:19.000Z</published>
    <updated>2019-07-02T15:49:40.018Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>校友录网站。作为毕业设计，为母校设计校友交流平台。基于javaWeb，由Maven构建管理，采用Spring+SpringMVC+MyBatis框架，用EhCache做数据缓存。门户网站采用BootStrap设计界面，后台管理网站用AmazeUI设计界面。</p><a id="more"></a><p>项目地址：<a href="https://github.com/blackist/ar" target="_blank" rel="noopener">https://github.com/blackist/ar</a></p><p><strong>摘要</strong></p><p>校友作为高校的一种重要资源，在促进高校专业教学改革、募集高校筹资办学途径、促进校企合作、加强毕业生感情交流、提升大学生就业质量等方面发挥着重要作用。然而目前我校并没有一个系统可以追溯毕业生的情况。因此，校友们需要一个平台，来了解母校的新闻，校友们的近况，同时也能够让院校充分了解毕业生的就业状况。</p><p>为了给校友们的提供一个了解母校动态的平台，本设计首先确定以毕业生以及高校为主要用户对象，采用目前业内流行的SpringMVC+Spring+MyBatis轻量级JavaEE框架，用Maven构建和管理，开发基于B/S结构的校友录系统。其次，通过系统建模对系统的各项功能进行了分析，确定了校友录系统的功能模块，并阐述了数据库的设计过程。再次对系统的功能模块进行了详细的设计，并对系统功能模块的界面进行了展示。最后对论文所阐述的内容进行总结，并分析了校友录系统对毕业生和院校带来的便利。</p><p>校友录系统是在对师生、院校进行充分的调研分析之后设计的，校友更多关注的是院校新闻、班级动态、校友信息以及社团学生会等团体，院校更多关注的是毕业生的就业情况、对本校毕业生招聘信息的推送。为满足院校和毕业生的需求，校友录系统设计了新闻中心模块、班记录模块、校友组织模块、校友论坛模块、职业招聘模块、校园服务模块。</p><p>校友录系统不仅能够很好地满足校友了解母校、校友动态的需求，也提供职业招聘、校园服务功能，使院校能够更好地了解毕业生就业情况、为毕业生提供就业服务。</p><p><strong>关键词</strong> 毕业；校友录；就业；JavaEE</p><p><strong>Abstract</strong></p><p>Youth is the best time in life, and this period of youth spent in the university will undoubtedly become the most valuable memories of our lives.Although time goes by fast, university life, the impressive community, the memorable alumni, the unforgettable teaching building, will be a subsequent stream of water in the memories. After graduation, we left school, along with the alumni miss and the alma mater’s attention. Thus, alumni desire for a platform to follow the news of alma mater, the status of alumni, and the dynamics of the group that they have joined.</p><p>​    In order to provide a sustenance for alumni’s emotions, this design, taking graduates and colleges as the main user object, using the current industry-popular SpringMVC + Spring + MyBatis lightweight JavaEE framework, develops the computer-based web pages Version of the simple and elegant Alumni Record System ( AR), built and managed by Maven.</p><p>​    AR is designed after a full investigation and analysis is conducted in the teachers, students and institutions. Alumni pay more attention to the school news, class dynamics, alumni information, community students and other groups. Institutions concern more about the graduates’ employment situation, new enrollment situation and delivery of recruit information about school graduates. AR designs the news center module, class record module, alumni organization module and alumni forum module. And album function is added into the class record and alumni organization, which aims to meet the needs of alumni better. At the same time, AR includes professional recruitment module, campus service module, so that institutions can understand the employment situation of graduates and help graduates better.</p><p>AR system not only can meet alumni to understand the alma mater, alumni dynamic needs, but also provide professional recruitment, campus service function, so that institutions can better understand the employment situation of graduates, to provide employment services for graduates.</p><p><strong>Keywords</strong>  graduation  alumni-record  employment  javaee</p><p><strong>目</strong>       <strong>录</strong></p><p><a href="#_Toc482890209">摘要… I</a></p><p><a href="#_Toc482890210">Abstract II</a></p><p><a href="#_Toc482890211">1 绪论… 1</a></p><p><a href="#_Toc482890212">1.1 课题背景… 1</a></p><p><a href="#_Toc482890213">1.2 课题意义… 1</a></p><p><a href="#_Toc482890214">1.3 课题内容… 1</a></p><p><a href="#_Toc482890215">1.4 论文的组织结构… 1</a></p><p><a href="#_Toc482890216">2 系统需求分析… 3</a></p><p><a href="#_Toc482890217">2.1 需求分析… 3</a></p><p><a href="#_Toc482890218">2.2 功能分析… 4</a></p><p><a href="#_Toc482890219">2.2.1 院校新闻发布功能… 4</a></p><p><a href="#_Toc482890220">2.2.2 班级管理功能… 5</a></p><p><a href="#_Toc482890221">3.2.3 院校组织管理功能… 6</a></p><p><a href="#_Toc482890222">3.2.4 校友论坛功能… 6</a></p><p><a href="#_Toc482890223">3.2.5 院校职业招聘功能… 7</a></p><p><a href="#_Toc482890224">3.2.6 校园服务功能… 7</a></p><p><a href="#_Toc482890225">3.2.7 用户个人中心功能… 8</a></p><p><a href="#_Toc482890226">2.4 技术路线… 9</a></p><p><a href="#_Toc482890227">3 系统总体设计… 11</a></p><p><a href="#_Toc482890228">3.1 系统总体设计… 11</a></p><p><a href="#_Toc482890229">3.1.1 系统登录… 11</a></p><p><a href="#_Toc482890230">3.1.2 新闻中心… 11</a></p><p><a href="#_Toc482890231">3.1.3 班级录… 11</a></p><p><a href="#_Toc482890232">3.1.4 校友组织… 11</a></p><p><a href="#_Toc482890233">3.1.5 校友论坛… 11</a></p><p><a href="#_Toc482890234">3.1.6 职位招聘… 12</a></p><p><a href="#_Toc482890235">3.1.7 校园服务… 12</a></p><p><a href="#_Toc482890236">3.1.8 个人中心… 12</a></p><p><a href="#_Toc482890237">3.2 系统功能设计… 12</a></p><p><a href="#_Toc482890238">3.2.1 新闻中心… 12</a></p><p><a href="#_Toc482890239">3.2.2 班记录… 13</a></p><p><a href="#_Toc482890240">3.2.3 校友组织… 14</a></p><p><a href="#_Toc482890241">3.2.4 校友论坛… 14</a></p><p><a href="#_Toc482890242">3.2.5 职业招聘… 15</a></p><p><a href="#_Toc482890243">3.2.6 校园服务… 16</a></p><p><a href="#_Toc482890244">3.2.8 个人中心… 16</a></p><p><a href="#_Toc482890245">3.3 数据库设计… 17</a></p><p><a href="#_Toc482890246">3.3.1 概念模型设计… 17</a></p><p><a href="#_Toc482890247">3.3.2 逻辑结构设计… 25</a></p><p><a href="#_Toc482890248">4 系统详细设计… 37</a></p><p><a href="#_Toc482890249">4.1 班级录… 37</a></p><p><a href="#_Toc482890250">4.1.1 班级首页… 38</a></p><p><a href="#_Toc482890251">4.1.2 班级动态… 40</a></p><p><a href="#_Toc482890252">4.1.3 班级通讯录… 42</a></p><p><a href="#_Toc482890253">4.1.4 班级相册… 43</a></p><p><a href="#_Toc482890254">4.2 职业招聘… 44</a></p><p><a href="#_Toc482890255">4.2.1 发布招聘… 44</a></p><p><a href="#_Toc482890256">4.2.2 查询招聘… 45</a></p><p><a href="#_Toc482890257">4.2.3 招聘详情… 46</a></p><p><a href="#_Toc482890258">4.2.4 投递简历… 47</a></p><p><a href="#_Toc482890259">4.3 校友论坛… 48</a></p><p><a href="#_Toc482890260">4.3.1 论坛广场… 48</a></p><p><a href="#_Toc482890261">4.3.2 发布新帖… 49</a></p><p><a href="#_Toc482890262">4.3.3 帖子详情… 49</a></p><p><a href="#_Toc482890263">结论… 51</a></p><p><a href="#_Toc482890264">致谢… 52</a></p><p><a href="#_Toc482890265">参考文献… 53</a></p><p>1 绪论</p><p>1.1 课题背景</p><p>青春是人生最美好的时光，而在大学度过的这一段青春岁月无疑将成为我们人生中最为宝贵的回忆。大学生活如白驹过隙匆匆流逝，却又将在而后的回忆里细水长流，忘不掉的社团，忘不掉的校友， 忘不掉的教学楼。毕业后，我们离开学校，一同带走的还有对校友的思念和对母校的关注。因此，校友们需要一个平台，来了解母校的新闻，校友们的近况，自己曾加入的团体的动态等等。</p><p>同时，院校对毕业生的培养与关怀也不会停止，院校希望了解毕业生的就业情况，并为毕业生提供就业服务，包括向毕业生投送招聘信息，接收毕业生所在单位的招聘信息。并且，校友作为高校的一种重要资源，在促进高校专业教学改革、募集高校筹资办学途径、促进校企合作、加强毕业生感情交流、提升大学生就业质量等方面发挥着重要作用。这也有助于改善教学方案，从而使本校毕业生更好地适应社会需求。</p><p>1.2 课题意义</p><p>中国同学录网的调查显示，用户最关心的是班级信息、班级留言、同学联系方式和同学照片等。不同用户对系统的需求不同，但是基本功能需求是一致的，包括：对班级管理，用户可以创建自己所在的班级；对班级留言的管理，用户可以在班级里查看、添加或修改留言；对班级通讯录的管理，用户可以查看班级成员的相关信息。</p><p>此系统还可以让校友了解母校的新闻，校友们的近况，自己曾加入的团体的动态，也提供了职业招聘功能，此功能是院校和毕业生交互的重要平台。院校可在职业招聘模块发布招聘信息，毕业生可以浏览招聘信息、投递简历、在线制作简历，毕业生可以发布自己所在单位的招聘信息，经管理员审核后发布到招聘广场，为其他毕业校友提供有力的就业帮助。校友的信息反馈在促进高校专业教学改革、募集高校筹资办学途径、促进校企合作、加强毕业生感情交流、提升大学生就业质量等方面发挥着重要作用。</p><p>1.3 课题内容</p><p>此系统是在对师生、院校进行充分的调研分析之后设计的，校友更多关注的是院校新闻、班级动态、校友信息以及社团学生会等团体，院校更多关注的是毕业生的就业情况、新生的招生情况以及对本校毕业生招聘信息的投送。此系统设计了新闻中心模块、班记录模块、校友组织模块、校友论坛模块，并在班记录和校友组织中加入相册功能，更好地满足校友的需求。同时，此系统包含职业招聘模块、校园服务模块，使院校更好地了解毕业生就业情况、为毕业生提供帮助。</p><p>1.4 论文的组织结构</p><p>论文主要内容包括五大部分，主要包括：</p><p>第一章 绪论。本章介绍了课题背景、课题意义以及本课题研究的主要内容。</p><p>第二章 系统需求分析。本章介绍了本系统的业务需求分析、系统功能分析以及相关业务的流程，开发过程中具体的开发环境、开发工具、相关技术。</p><p>第三章 系统总体设计。本章介绍了本系统的总体设计、系统各项功能的设计以及数据库的设计。</p><p>第四章 系统详细设计。本章介绍了系统的详细设计，包括各项系统功能的界面设计、代码逻辑设计以及实现。 </p><p>2 系统需求分析</p><p>2.1 需求分析</p><p>中国同学录网的调查显示，用户最关心的是班级信息、班级留言、同学联系方式和同学照片等。不同用户对系统的需求不同，但是基本功能需求是一致的，包括：对班级管理，用户可以查询并加入自己所在的班级；对班级留言的管理，用户可以在班级里查看、添加或修改留言；对班级通讯录的管理，用户可以查看班级成员的相关信息。考虑到网络的现况和同学们以及毕业生跟踪调查的各种需求，系统应该具有各方面的交流能力和实时的用户反馈信息，能够实现留言、上传照片、评论等功能，同时具有方便的后台管理功能。同学录系统能够实现同学们生活中的交流，拥有自己的空间，与此同时，校方管理员能够了解毕业生的就业情况，并为毕业生提供就业服务，包括向毕业生投送招聘信息，接收毕业生所在单位的招聘信息。这也有助于改善教学方案，从而更好地让本校毕业生适应社会需求。系统主要功能有：</p><p>（1）系统用户的登录、注册。注册，由管理员将历届学生的学号、姓名导入数据库，学号作为用户的用户名；登录，输入用户输入用户名（学号）和密码登录系统；</p><p>（2）校园新闻发布中心功能：新闻发布，后台管理发布图文信息到门户网站，可置顶、编辑、删除新闻信息；新闻评论，用户可以对新闻信息发表评论，回复评论，动态加载地评论；新闻热度，用户喜欢可以新闻信息，系统根据信息的喜欢量、浏览流量推送新闻信息；</p><p>（3）同学交流的班级录功能。班级检索，按入学年份查询，按照班级名称、校友姓名查询，综合检索班级；班级排名，根据班级人数、活跃时间对班级进行热度排名；班级主页，每个班级有自己的空间，包括班级主页、班级动态、班级留言、班级成员、班级通讯录、班级相册、班级事务管理等；班级管理，班级的新增、管理员的设置由后台管理员完成；</p><p>（4） 校友互动的团体组织功能。校友总会，院校总会；院系分会，各学院的校友组织；社团分会，院校内的各种社团、协会的组织；学生协会，院校内的各学生协会组织；组织主页，个组织有自己的空间，包括组织主页、动态消息、留言、成员列表、通讯录、相册、活动、组织事务管理；</p><p>（5）校友话题参与的论坛功能。帖子浏览，按作者、主题检索帖子，查看详情，对帖子发表评论，回复评论、删除用户自己的评论，ajax动态加载评论；热帖推送，用户可以喜欢帖子，系统根据帖子的喜欢数量和浏览量进行推送；发布新帖，用户登录后可以发布帖子；贴子管理，管理员可审核、置顶、删除帖子；</p><p>（6） 职位招聘信息推送功能。招聘广场，浏览招聘信息，根据公司名称、职位名称、工作地点检索并查看招聘信息；简历投送，用户可以向喜欢的招聘信息投送个人简历；简历管理，用户可以新增简历、编辑简历、删除简历；单位管理，用户可以登记、编辑自己所在单位的信息；发布招聘，用户登记单位信息后可以发布招聘信息，由管理员审核后推送到招聘广场； </p><p>（7）招生就业的校园服务。校内服务，包括走进校园、校园行指南、学报编辑部、图书馆、档案馆、信息公开网等信息；招生就业服务，包括本科招生、成教招生、就业网、人才招聘、本站招聘等信息；</p><p>（8）用户个人管理中心。个人资料，基本资料、 详细资料、 工作信息、 头像设置；账户设置，密码修改、邮箱绑定；我的班级，用户加入的班级相关信息；我的论坛，用户早论坛的相关信息；我的招聘，用户发布的招聘信息，用户投递的简历信息，用户个人简历管理。</p><p>2.2 功能分析</p><p>基于对校友录系统的需求分析，校友录系统有新闻中心功能，管理员发布管理图文信息，用户可以浏览、评论新闻信息。校友录系统设置班记录功能，给班级同学提供班级空间，班级空间内有交流平台、班级相册，这是同学比较关心的功能。同时，校友录系统具有校友组织功能，校友可以加入校内的组织和团体，组织有自己的空间给组织成员提供交流平台。为给广大校友提供更大的交流平台，校友录系统提供校友论坛功能，校友可以浏览话题并参与讨论。为满足院校对招聘信息推送的需求，校友录系统应加入职业招聘模块，院校管理员发布招聘信息，用户浏览并投递简历，用户也可以发布自己所在单位的招聘信息，经管理员审核后发不到招聘广场。为更好地微笑有提供入学、就业服务，校友录系统设有校园服务，为校友提供校园指南和就业服务。最后，校友录系统为用户提供个人中心功能，对个人信息以及在站内的应用进行管理。</p><h3 id="2-2-1-院校新闻发布功能"><a href="#2-2-1-院校新闻发布功能" class="headerlink" title="2.2.1 院校新闻发布功能"></a>2.2.1 院校新闻发布功能</h3><p>1.新闻中心用例分析</p><p>新闻中心包括新闻发布，后台管理发布图文信息到门户网站，可置顶、编辑、删除新闻信息。新闻评论，用户可以对新闻信息发表评论，回复评论，动态加载评论。新闻热度，用户喜欢可以新闻信息，系统根据信息的喜欢量、浏览流量推送新闻信息。新闻中心用例如图2-1所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image002.jpg" alt="img"></p><p>图2-1 新闻中心用例图</p><h3 id="2-2-2-班级管理功能"><a href="#2-2-2-班级管理功能" class="headerlink" title="2.2.2 班级管理功能"></a>2.2.2 班级管理功能</h3><p>1、班记录用例分析</p><p>班记录包括班级检索，按入学年份查询，按照班级名称、校友姓名查询，综合检索班级；班级排名，根据班级人数、活跃时间对班级进行热度排名；班级主页，每个班级有自己的空间，包括班级主页、班级动态、班级留言、班级成员、班级通讯录、班级相册、班级事务管理等；班级管理，班级的新增、管理员的设置由后台管理员完成。班记录用例如图2-2所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image004.jpg" alt="img"></p><p>图2-2 班记录用例图</p><h3 id="2-2-3-院校组织管理功能"><a href="#2-2-3-院校组织管理功能" class="headerlink" title="2.2.3 院校组织管理功能"></a>2.2.3 院校组织管理功能</h3><p>1.校友组织用例分析</p><p>校友组织包括：校友总会，院校总会；院系分会，各学院的校友组织；社团分会，院校内的各种社团、协会的组织；学生协会，院校内的各学生协会组织；组织主页，个组织有自己的空间，包括组织主页、动态消息、留言、成员列表、通讯录、相册、活动、组织事务管理；校友组织用例如图2-3所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image006.jpg" alt="img"></p><p>图2-3 校友组织用例</p><h3 id="2-2-4-校友论坛功能"><a href="#2-2-4-校友论坛功能" class="headerlink" title="2.2.4 校友论坛功能"></a>2.2.4 校友论坛功能</h3><p>1.校友论坛用例分析</p><p>校友论坛包括：帖子浏览，按作者、主题检索帖子，查看详情，对帖子发表评论，回复评论、删除用户自己的评论，ajax动态加载评论；热帖推送，用户可以喜欢帖子，系统根据帖子的喜欢数量和浏览量进行推送；发布新帖，用户登录后可以发布帖子；贴子管理，管理员可审核、置顶、删除帖子；校友论坛用例如图2-4所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image008.jpg" alt="img"></p><p>图2-4 校友论坛用例图</p><h3 id="2-2-5-院校职业招聘功能"><a href="#2-2-5-院校职业招聘功能" class="headerlink" title="2.2.5 院校职业招聘功能"></a>2.2.5 院校职业招聘功能</h3><p>1.业招聘用例分析</p><p>职位招聘包括：招聘广场。浏览招聘信息，根据公司名称、职位名称、工作地点检索并查看招聘信息；简历投送，用户可以向喜欢的招聘信息投送个人简历；简历管理，用户可以新增简历、编辑简历、删除简历；单位管理，用户可以登记、编辑自己所在单位的信息；发布招聘，用户登记单位信息后可以发布招聘信息，由管理员审核后推送到招聘广场。职业招聘用例如图2-5所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image010.jpg" alt="img"></p><p>图2-5 职业招聘用例图</p><h3 id="2-2-6-校园服务功能"><a href="#2-2-6-校园服务功能" class="headerlink" title="2.2.6 校园服务功能"></a>2.2.6 校园服务功能</h3><p>1.校园服务用例分析</p><p>校园服务：校内服务，包括走进校园、校园行指南、学报编辑部、图书馆、档案馆、信息公开网等信息；招生就业服务，包括本科招生、成教招生、就业网、人才招聘、本站招聘等信息。校园服务用例如图2-6所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image012.jpg" alt="img"></p><p>图2-6 职业招聘用例图</p><h3 id="2-2-7-用户个人中心功能"><a href="#2-2-7-用户个人中心功能" class="headerlink" title="2.2.7 用户个人中心功能"></a>2.2.7 用户个人中心功能</h3><p>1.个人中心用例分析</p><p>个人中心：个人资料，基本资料、 详细资料、 工作信息、 头像设置；账户设置，密码修改、邮箱绑定；我的班级，用户加入的班级相关信息；我的论坛，用户早论坛的相关信息；我的招聘，用户发布的招聘信息，用户投递的简历信息，用户个人简历管理。个人中心用例如图2-7所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image014.jpg" alt="img"></p><p>图2-7 个人中心用例图</p><p>2.4 技术路线</p><p>本系统采用业内流行的SpringMVC+Spring+MyBatis框架（简称SSM），由项目构建工具Maven构建，并使用Git版本控制系统辅助项目开发。</p><p>Git是一个便捷的分布式版本控制工具，本项目用Git进行管理，可以轻松地备份项目，控制项目的版本，并且能够更安全地开发、调试。</p><p>Maven可以通过项目对象模型配置文件（pom.xml）轻松地构建项目，不用将jar包添加到项目，缩小了项目的体积。本系统使用Maven构建父模块ar-parent，并聚合了三个子模块ar-common、ar-manage、ar-portal。ar-common是项目的公共基础模块，java应用类的模型，包含实体类、工具类、数据访问对象等，依赖Spring、MyBatis等。ar-manage是本系统的后台管理模块，web应用类的模型，依赖ar-common、Spring、SpringMVC等。Ar-poratl是本系统的门户网站模块，依赖ar-common、ar-manage、Spring、SpringMVC等。Maven可以将web应用类项目打包成war并发布到tomcat服务器运行测试。</p><p>本系统充分利用Spring的IoC（控制反转）和AOP（面向切面）特性，将创建用户的SpringMVC控制器Controller、业务逻辑类Service、数据访问类Mapper交由Spring Container管理，生成对应的bean（也称组件）, 并把实现类的类名作为bean的id。当控制器、业务逻辑类、数据访问类需要Spring Container中bean对应的实现类时，Spring Container通过依赖注入机制为其注入对应的bean。通过这种配置，系统实现了控制器和业务逻辑类分离，业务逻辑类和数据访问类分离。SpringMVC中的DispatcherServlet接收请求，并交由控制器Controller处理，Controller接收参数、调用业务逻辑类中的方法，通过ModelAndView视图模型返回jsp页面、json数据。</p><p>本系统的视图层采用jsp、HTML，通过事件触发机制向服务器端发送请求，并采用Bootstrap、AmazeUI、HTML5、CSS3等前台样式，通过c标签、javascript、jquery处理前台数据。</p><p>技术路线如图2-8所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image016.jpg" alt="img"></p><p>图2-8 技术路线图</p><p>3 系统总体设计</p><p>3.1 系统总体设计</p><p>根据系统功能分析，本系统应该具备的功能包括：登录注册、新闻中心、班级录、校友组织、校友论坛、职位招聘、校园服务、个人中心等功能。</p><h3 id="3-1-1-系统登录"><a href="#3-1-1-系统登录" class="headerlink" title="3.1.1 系统登录"></a>3.1.1 系统登录</h3><p>（1）注册：由管理员将历届学生的学号、姓名导入数据库，学号作为用户的用户名；</p><p>（2）登录：输入用户输入用户名（学号）和密码登录系统。</p><h3 id="3-1-2-新闻中心"><a href="#3-1-2-新闻中心" class="headerlink" title="3.1.2 新闻中心"></a>3.1.2 新闻中心</h3><p>（1）新闻发布：后台管理发布图文信息到门户网站，可置顶、编辑、删除新闻信息；</p><p>（2）新闻评论：用户可以对新闻信息发表评论，回复评论，动态加载评论；</p><p>（3）新闻热度：用户喜欢可以新闻信息，系统根据信息的喜欢量、浏览流量推送新闻信息。</p><h3 id="3-1-3-班级录"><a href="#3-1-3-班级录" class="headerlink" title="3.1.3 班级录"></a>3.1.3 班级录</h3><p>（1）班级检索：按入学年份查询，按照班级名称、校友姓名查询，综合检索班级；</p><p>（2）班级排名：根据班级人数、活跃时间对班级进行热度排名；</p><p>（3）班级主页：每个班级有自己的空间，包括班级主页、班级动态、班级留言、班级成员、班级通讯录、班级相册、班级事务管理等；</p><p>（4）班级管理：班级的新增、管理员的设置由后台管理员完成。</p><h3 id="3-1-4-校友组织"><a href="#3-1-4-校友组织" class="headerlink" title="3.1.4 校友组织"></a>3.1.4 校友组织</h3><p>（1）校友总会：院校总会；</p><p>（2）院系分会：各学院的校友组织；</p><p>（3）社团分会：院校内的各种社团、协会的组织；</p><p>（4）学生协会：院校内的各学生协会组织；</p><p>（5）组织主页：个组织有自己的空间，包括组织主页、动态消息、留言、成员列表、通讯录、相册、活动、组织事务管理。</p><h3 id="3-1-5-校友论坛"><a href="#3-1-5-校友论坛" class="headerlink" title="3.1.5 校友论坛"></a>3.1.5 校友论坛</h3><p>（1）帖子浏览：按作者、主题检索帖子，查看详情；</p><p>（2）评论帖子：对帖子发表评论，回复评论、删除用户自己的评论，ajax动态加载评论；</p><p>（3）热帖推送：用户可以喜欢帖子，系统根据帖子的喜欢数量和浏览量进行推送；</p><p>（4）发布新帖：用户登录后可以发布帖子； </p><p>（5）贴子管理：管理员可审核、置顶、删除帖子。</p><h3 id="3-1-6-职位招聘"><a href="#3-1-6-职位招聘" class="headerlink" title="3.1.6 职位招聘"></a>3.1.6 职位招聘</h3><p>（1）招聘广场：浏览招聘信息，根据公司名称、职位名称、工作地点检索并查看招聘信息；</p><p>（2）简历投送：用户可以向喜欢的招聘信息投送个人简历；</p><p>（3）简历管理：用户可以新增简历、编辑简历、删除简历；</p><p>（4）单位管理：用户可以登记、编辑自己所在单位的信息；</p><p>（5）发布招聘：用户登记单位信息后可以发布招聘信息，由管理员审核后推送到招聘广场。</p><h3 id="3-1-7-校园服务"><a href="#3-1-7-校园服务" class="headerlink" title="3.1.7 校园服务"></a>3.1.7 校园服务</h3><p>（1）校内服务：包括走进校园、校园行指南、学报编辑部、图书馆、档案馆、信息公开网等信息；</p><p>（2）招生就业服务：包括本科招生、成教招生、就业网、人才招聘、本站招聘等信息。</p><h3 id="3-1-8-个人中心"><a href="#3-1-8-个人中心" class="headerlink" title="3.1.8 个人中心"></a>3.1.8 个人中心</h3><p>（1）个人资料：基本资料、 详细资料、 工作信息、 头像设置；</p><p>（2）账户设置：密码修改、邮箱绑定； </p><p>（3）我的班级：用户加入的班级相关信息；</p><p>（4）我的论坛：用户早论坛的相关信息；</p><p>（5）我的招聘：用户发布的招聘信息，用户投递的简历信息，用户个人简历管理。</p><p>3.2 系统功能设计</p><p>3.2.1 新闻中心</p><p>新闻发布，后台管理发布图文信息到门户网站，可置顶、编辑、删除新闻信息；新闻评论，用户可以对新闻信息发表评论，回复评论，动态加载评论；新闻热度，用户喜欢可以新闻信息，系统根据信息的喜欢量、浏览流量推送新闻信息。新闻中心功能如图3-1所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image018.jpg" alt="img"></p><p>图3-1 新闻中心功能图</p><p>3.2.2 班记录</p><p>班级录功能包括:班级检索，按入学年份查询，按照班级名称、校友姓名查询，综合检索班级；班级排名，根据班级人数、活跃时间对班级进行热度排名；班级主页，每个班级有自己的空间，包括班级主页、班级动态、班级留言、班级成员、班级通讯录、班级相册、班级事务管理等；班级管理，班级的新增、管理员的设置由后台管理员完成。班级录功能如图3-2所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image020.jpg" alt="img"></p><p>图3-2 班记录功能图</p><h3 id="3-2-3-校友组织"><a href="#3-2-3-校友组织" class="headerlink" title="3.2.3 校友组织"></a>3.2.3 校友组织</h3><p>校友组织包括：校友总会，院校总会；院系分会，各学院的校友组织；社团分会，院校内的各种社团、协会的组织；学生协会，院校内的各学生协会组织；组织主页，个组织有自己的空间，包括组织主页、动态消息、留言、成员列表、通讯录、相册、活动、组织事务管理。校友组织功能如图3-3所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image021.png" alt="img"></p><p>图3-3 校友组织功能功能图</p><p>3.2.4 校友论坛</p><p>校友论坛：帖子浏览，按作者、主题检索帖子，查看详情，对帖子发表评论，回复评论、删除用户自己的评论，ajax动态加载评论；热帖推送，用户可以喜欢帖子，系统根据帖子的喜欢数量和浏览量进行推送；发布新帖，用户登录后可以发布帖子；贴子管理，管理员可审核、置顶、删除帖子。校友论坛功能如图3-4所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image023.jpg" alt="img"></p><p>图3-4 校友论坛功能图</p><h3 id="3-2-5-职业招聘"><a href="#3-2-5-职业招聘" class="headerlink" title="3.2.5 职业招聘"></a>3.2.5 职业招聘</h3><p>职位招聘：招聘广场。浏览招聘信息，根据公司名称、职位名称、工作地点检索并查看招聘信息；简历投送，用户可以向喜欢的招聘信息投送个人简历；简历管理，用户可以新增简历、编辑简历、删除简历；单位管理，用户可以登记、编辑自己所在单位的信息；发布招聘，用户登记单位信息后可以发布招聘信息，由管理员审核后推送到招聘广场。职业招聘功能如图3-5所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image025.jpg" alt="img"></p><p>图3-5 职业招聘功能图</p><h3 id="3-2-6-校园服务"><a href="#3-2-6-校园服务" class="headerlink" title="3.2.6 校园服务"></a>3.2.6 校园服务</h3><p>校园服务包括：校内服务，包括走进校园、校园行指南、学报编辑部、图书馆、档案馆、信息公开网等信息；招生就业服务，包括本科招生、成教招生、就业网、人才招聘、本站招聘等信息。校园服务功能如图3-6所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image027.jpg" alt="img"></p><p>图3-6 校园服务功能图</p><h3 id="3-2-7-个人中心"><a href="#3-2-7-个人中心" class="headerlink" title="3.2.7 个人中心"></a>3.2.7 个人中心</h3><p>个人中心：个人资料，基本资料、 详细资料、 工作信息、 头像设置；账户设置，密码修改、邮箱绑定；我的班级，用户加入的班级相关信息；我的论坛，用户在论坛的相关信息；我的招聘，用户发布的招聘信息，用户投递的简历信息，用户个人简历管理。个人中心功能如图3-7所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image029.jpg" alt="img"></p><p>图3-7 个人中心功能图</p><p>3.3 数据库设计</p><p>3.3.1 概念模型设计</p><p>根据系统总体设计和功能设计，设计出系统涉及到的实体信息，包括用户实体，个人信息实体，职业信息实体，简历实体，地址实体，留言实体，评论回复实体，年级实体，组织实体，活动实体，相册实体，图片实体，信息实体，评论实体，分享实体，收藏实体，订阅实体，招聘信息实体，招聘单位实体，附件实体，角色实体，权限实体，字典实体，字典数据实体，各实体信息的概念模型如下所示。</p><p>（1）用户实体模型如图3-8所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image031.jpg" alt="img"></p><p>图3-8 用户实体模型</p><p>（2）职业信息实体模型如图3-9所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image033.jpg" alt="img"></p><p>图3-9 职业信息实体模型</p><p>（3）简历实体模型如图3-10所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image035.jpg" alt="img"></p><p>图3-10 简历实体模型</p><p>（4）地址实体模型如图3-11所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image037.jpg" alt="img"></p><p>图3-11 地址实体模型</p><p>（5）留言实体模型如图3-12所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image039.jpg" alt="img"></p><p>图3-12  留言实体模型</p><p>（6）评论回复实体模型如图3-13所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image041.jpg" alt="img"></p><p>图3-13  回复实体模型</p><p>（7）年级实体模型如图3-14所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image043.jpg" alt="img"></p><p>图3-14 年级实体</p><p>（8）组织实体模型如图3-15所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image045.jpg" alt="img"></p><p>图3-15  组织实体模型</p><p>（9）相册实体模型如图3-16所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image047.jpg" alt="img"></p><p>图3-16 相册实体模型</p><p>（10）活动实体模型如图3-17所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image049.jpg" alt="img"></p><p>图3-17 活动实体模型</p><p>（11）字典数据实体模型如图3-18所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image051.jpg" alt="img"></p><p>图3-18 字典数据实体模型</p><p>（12）图片实体模型如图3-19所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image053.jpg" alt="img"></p><p>图3-19 图片实体模型</p><p>（13）信息实体模型如图3-20所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image055.jpg" alt="img"></p><p>图3-20 信息实体模型</p><p>（14）评论实体模型如图3-21所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image057.jpg" alt="img"></p><p>图3-21 评论实体模型</p><p>（15）分享实体模型如图3-22所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image059.jpg" alt="img"></p><p>图3-22 分享实体模型</p><p>（16）收藏实体模型如图3-23所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image061.jpg" alt="img"></p><p>图3-23 收藏实体模型</p><p>（17）订阅实体模型如图3-24所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image063.jpg" alt="img"></p><p>图3-24 订阅实体模型</p><p>（18）招聘信息实体模型如图3-25所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image065.jpg" alt="img"></p><p>图3-25 招聘实体模型</p><p>（19）招聘单位实体模型如图3-26所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image067.jpg" alt="img"></p><p>图3-26 招聘单位实体模型</p><p>（20）附件实体模型如图3-27所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image069.jpg" alt="img"></p><p>图3-27 附件实体模型</p><p>（21）角色实体模型如图3-28所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image071.jpg" alt="img"></p><p>图3-28  角色实体模型</p><p>（22）权限实体模型如图3-29所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image073.jpg" alt="img"></p><p>图3-29  权限实体模型</p><p>（23）字典实体模型如图3-30所示</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image075.jpg" alt="img"></p><p>图3-30 字典表模型</p><p>（24）简历投递实体模型如图3-31所示</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image077.jpg" alt="img"></p><p>图3-31 简历投递模型</p><p>3.3.2 逻辑结构设计</p><p>根据系统的概念模型设计，设计出适应大多数数据库的数据表逻辑结构，共设计31张表，如表3-1所示。</p><p>表3-1 数据表汇总</p><table><thead><tr><th>序号</th><th>名称</th><th>用途与约束</th></tr></thead><tbody><tr><td>1</td><td>user</td><td>用户表</td></tr><tr><td>2</td><td>user_info</td><td>用户个人信息表</td></tr><tr><td>3</td><td>user_job</td><td>用户工作信息表</td></tr><tr><td>4</td><td>user_resume</td><td>用户个人简历</td></tr><tr><td>5</td><td>resume_post</td><td>简历投递信息</td></tr><tr><td>6</td><td>user_origin</td><td>用户加入组织信息表</td></tr><tr><td>7</td><td>user_role</td><td>用户角色设定表</td></tr><tr><td>8</td><td>role</td><td>角色表</td></tr></tbody></table><p>续表3-1</p><table><thead><tr><th>序号</th><th>名称</th><th>用途与约束</th></tr></thead><tbody><tr><td>9</td><td>role_right</td><td>角色权限分配表</td></tr><tr><td>10</td><td>right</td><td>权限表</td></tr><tr><td>11</td><td>Address</td><td>地址信息表</td></tr><tr><td>12</td><td>message</td><td>消息表</td></tr><tr><td>13</td><td>reply</td><td>回复表</td></tr><tr><td>14</td><td>grade</td><td>年级表</td></tr><tr><td>15</td><td>origin</td><td>组织表</td></tr><tr><td>16</td><td>activity</td><td>活动表</td></tr><tr><td>17</td><td>album</td><td>相册信息表</td></tr><tr><td>18</td><td>album_image</td><td>相册图片信息表</td></tr><tr><td>19</td><td>image</td><td>图片信息表</td></tr><tr><td>20</td><td>information</td><td>信息表</td></tr><tr><td>21</td><td>comment</td><td>评论表</td></tr><tr><td>22</td><td>share</td><td>信息分享表</td></tr><tr><td>23</td><td>collect</td><td>信息收藏表</td></tr><tr><td>24</td><td>subscription</td><td>信息订阅表</td></tr><tr><td>25</td><td>recruit</td><td>招聘信息表</td></tr><tr><td>26</td><td>recruit_unit</td><td>招聘单位信息表</td></tr><tr><td>27</td><td>attachment</td><td>附件信息表</td></tr><tr><td>28</td><td>attachment_info</td><td>信息附件关系表</td></tr><tr><td>29</td><td>dictionary</td><td>数据字典表</td></tr><tr><td>30</td><td>dictionary_data</td><td>数据字典数据表</td></tr><tr><td>31</td><td>log</td><td>日志表</td></tr></tbody></table><p>表3-2 用户表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>account</td><td>char(20)</td><td>用户名</td><td></td></tr><tr><td>is_admin</td><td>char(1)</td><td>管理员标识</td><td></td></tr><tr><td>email</td><td>varchar(20)</td><td>用户邮箱</td><td></td></tr><tr><td>password</td><td>char(32)</td><td>用户密码</td><td></td></tr><tr><td>head_image_id</td><td>int(8)</td><td>头像图片标识</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>用户注册时间</td></tr></tbody></table><p>续表3-2</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>state</td><td>char(5)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-3 用户个人信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>user_info_id</td><td>int(8)</td><td>主键</td><td>自动增长</td></tr><tr><td>ture_name</td><td>Nvarchar(20)</td><td>用户名</td><td></td></tr><tr><td>age</td><td>char(5)</td><td>年龄</td><td></td></tr><tr><td>sex</td><td>char(5)</td><td>性别</td><td></td></tr><tr><td>birthday</td><td>datetime</td><td>生日</td><td></td></tr><tr><td>introduce</td><td>varchar(200)</td><td>个人简介</td><td></td></tr><tr><td>phone</td><td>varchar(20)</td><td>联系电话</td><td></td></tr><tr><td>email</td><td>varchar(50)</td><td>邮箱</td><td></td></tr><tr><td>qq</td><td>varchar(20)</td><td>QQ</td><td></td></tr><tr><td>microblog</td><td>varchar(50)</td><td>微博</td><td></td></tr><tr><td>wechat</td><td>varchar(20)</td><td>微信</td><td></td></tr><tr><td>address</td><td>Nvarchar(50)</td><td>住址</td><td></td></tr><tr><td>user_id</td><td>int</td><td>用户id</td><td>外键</td></tr><tr><td>state</td><td>char(2)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态时间</td></tr></tbody></table><p>表3-4 职业信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>job_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>job_name</td><td>Varchar(20)</td><td>职业名称</td><td></td></tr><tr><td>job_unit</td><td>Varchar(20)</td><td>就业单位</td><td></td></tr><tr><td>date_start</td><td>date</td><td>就职时间</td><td></td></tr><tr><td>date_end</td><td>date</td><td>离职时间</td><td></td></tr><tr><td>job_desc</td><td>varhar(200)</td><td>职业简述</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>工作登记时间</td><td></td></tr><tr><td>user_id</td><td>int</td><td>就业者</td><td>外键</td></tr><tr><td>state</td><td>char(1)</td><td>此条记录的状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>记录状态</td></tr></tbody></table><p>表3-5 个人简历表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>resume_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>resume_title</td><td>varchar(20)</td><td>简历标题</td><td></td></tr><tr><td>prof_type</td><td>vatchar(20)</td><td>职业类别</td><td></td></tr><tr><td>exp_salary</td><td>varchar(10)</td><td>期望薪资</td><td></td></tr><tr><td>name</td><td>varchar(10)</td><td>姓名</td><td></td></tr><tr><td>sex</td><td>char(1)</td><td>性别</td><td></td></tr><tr><td>domicile</td><td>varchar(20)</td><td>现在居住地</td><td></td></tr><tr><td>contact</td><td>varchar(30)</td><td>联系方式</td><td></td></tr><tr><td>introduce</td><td>varchar(200)</td><td>个人简介</td><td></td></tr><tr><td>userId</td><td>int</td><td>用户id</td><td>外键</td></tr><tr><td>statusValue</td><td>char(5)</td><td>状态值</td><td>a     x       t</td></tr></tbody></table><p>表3-6 简历投递表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>recruit_id</td><td>int</td><td>招聘信息id</td><td>外键</td></tr><tr><td>resume_id</td><td>int</td><td>简历id</td><td>外键</td></tr><tr><td>create_time</td><td>datetime</td><td>投递日期</td><td></td></tr><tr><td>state</td><td>char(2)</td><td>投递状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-7 角色权限配置表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>user_id</td><td>int</td><td>用户id</td><td>外键</td></tr><tr><td>role_id</td><td>int</td><td>角色id</td><td>外键</td></tr></tbody></table><p>表3-8 权限信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>role_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>role_name</td><td>varchar(20)</td><td>角色名称</td><td></td></tr><tr><td>role_value</td><td>varchar(20)</td><td>角色类型</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>创建时间</td><td></td></tr><tr><td>state</td><td>char(2)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-9 角色权限表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>role_id</td><td>int</td><td>角色id</td><td>自动增长</td></tr><tr><td>right_id</td><td>int</td><td>权限id</td></tr></tbody></table><p>表3-10 权限信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>right_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>right_name</td><td>varchar(20)</td><td>权限名称</td><td></td></tr><tr><td>right_pos</td><td>int</td><td>权限位</td><td></td></tr><tr><td>right_code</td><td>bigint</td><td>权限码</td><td></td></tr><tr><td>right_URL</td><td>varchar(50)</td><td>权限路径</td><td></td></tr><tr><td>is_public</td><td>char</td><td>是否是公共资源</td><td></td></tr><tr><td>state</td><td>char(2)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-11 地址表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>addr_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>province</td><td>varchar(10)</td><td>省份</td><td></td></tr><tr><td>city</td><td>varchar(10)</td><td>市</td><td></td></tr><tr><td>district</td><td>varchar(10)</td><td>区</td><td></td></tr><tr><td>detail</td><td>varchar(50)</td><td>详细地址</td><td></td></tr><tr><td>zip_code</td><td>char(6)</td><td>邮编</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>创建日期</td><td></td></tr><tr><td>state</td><td>char(2)</td><td>状态值</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-12 留言表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>msg_id</td><td>int(11)</td><td>主键</td><td>自动增长</td></tr><tr><td>title</td><td>varchar(20)</td><td>标题</td><td></td></tr><tr><td>content</td><td>varchar(500)</td><td>留言内容</td><td></td></tr><tr><td>sender_id</td><td>int(8)</td><td>发送者id</td><td></td></tr><tr><td>receiver_id</td><td>int(8)</td><td>接收者id</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>发表日期</td></tr></tbody></table><p>表3-13 留言回复表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>reId</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>content</td><td>varchar(500)</td><td>回复内容</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>回复时间</td><td></td></tr><tr><td>msg_id</td><td>int(11)</td><td>被回复的留言的id</td><td>外键</td></tr><tr><td>user_id</td><td>int</td><td>回复人id</td><td>外键</td></tr></tbody></table><p>表3-14 年级表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>grade_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>grade_value</td><td>char(4)</td><td>年份</td><td></td></tr><tr><td>class_num</td><td>int(4)</td><td>班级数</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>创建日期</td><td></td></tr><tr><td>state</td><td>char(2)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-15 组织信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>origin_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>origin_name</td><td>varchar(20)</td><td>组织编号</td><td></td></tr><tr><td>origin_no</td><td>varchar(20)</td><td>组织名</td><td></td></tr><tr><td>origin_type</td><td>varchar(20)</td><td>组织类型</td><td></td></tr><tr><td>origin_desc</td><td>varchar(500)</td><td>组织简介</td><td></td></tr><tr><td>origin_grade</td><td>varchar(4)</td><td>组织年级</td><td></td></tr><tr><td>members</td><td>int(4)</td><td>组织人员数量</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>组织成立的年份</td><td></td></tr><tr><td>mgr_id</td><td>int</td><td>组织的管理员id</td><td>外键</td></tr><tr><td>creator_id</td><td>int</td><td>组织创建人</td><td>外键</td></tr><tr><td>state</td><td>char(2)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-16 校友活动表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>act_id</td><td>int(8)</td><td>主键</td><td>自动增长</td></tr><tr><td>act_name</td><td>varchar(20)</td><td>活动名称</td></tr></tbody></table><p>续表3-16</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>start_time</td><td>datetime</td><td>活动开始时间</td><td></td></tr><tr><td>end_time</td><td>datetime</td><td>活动结束时间</td><td></td></tr><tr><td>act_place</td><td>varchar(50)</td><td>活动地点</td><td></td></tr><tr><td>act_desc</td><td>text</td><td>活动描述</td><td></td></tr><tr><td>act_num</td><td>int(4)</td><td>活动人数</td><td></td></tr><tr><td>sign_num</td><td>int(4)</td><td>活动已报名人数</td><td></td></tr><tr><td>interests</td><td>int(4)</td><td>感兴趣数</td><td></td></tr><tr><td>leader_name</td><td>varchar(10)</td><td>负责人姓名</td><td></td></tr><tr><td>leader_phone</td><td>varchar(30)</td><td>负责人联系方式</td><td></td></tr><tr><td>origin_id</td><td>int(8)</td><td>活动所属组织</td><td>外键</td></tr><tr><td>user_id</td><td>int(8)</td><td>活动发起人</td><td>外键</td></tr><tr><td>state</td><td>char(2)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-17 相册表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>album_id</td><td>int(8)</td><td>主键</td><td>自动增长</td></tr><tr><td>album_name</td><td>varchar(20)</td><td>相册名名</td><td></td></tr><tr><td>albm_desc</td><td>varchar(200)</td><td>相册描述</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>创建时间</td><td></td></tr><tr><td>interests</td><td>int(4)</td><td>感兴趣的人数</td><td></td></tr><tr><td>cover_image</td><td>int(11)</td><td>相册封面标识</td><td></td></tr><tr><td>origin_id</td><td>int</td><td>相册所属组织</td><td>外键</td></tr><tr><td>user_id</td><td>int</td><td>相册创建人</td><td>外键</td></tr><tr><td>state</td><td>char(2)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>创建时间</td></tr></tbody></table><p>表3-18 相册图片表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>album_id</td><td>int</td><td>相册id</td><td>外键</td></tr><tr><td>image_id</td><td>int</td><td>图片id</td><td>外键</td></tr><tr><td>create_time</td><td>datetime</td><td>创建时间</td></tr></tbody></table><p>表3-19 图片信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>image_id</td><td>int(11)</td><td>主键</td><td>自动增长</td></tr><tr><td>image_name</td><td>varchar(32)</td><td>图片名</td><td></td></tr><tr><td>is_remote</td><td>char(1)</td><td>远程文件</td><td></td></tr><tr><td>image_size</td><td>varchar(5)</td><td>图片大小</td><td></td></tr><tr><td>image_path</td><td>varchar(255)</td><td>图片路径</td><td></td></tr><tr><td>image_type</td><td>varchar(20)</td><td>图片类型</td><td></td></tr><tr><td>is_thumb</td><td>char(1)</td><td>缩略图标识</td><td></td></tr><tr><td>thumb_path</td><td>varchar(255)</td><td>缩略图路径</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>上传日期</td><td></td></tr><tr><td>state</td><td>char(2)</td><td>图片状态</td></tr></tbody></table><p>表3-20 信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>info_id</td><td>int(11)</td><td>主键</td><td>自动增长</td></tr><tr><td>info_title</td><td>varchar(50)</td><td>信息标题</td><td></td></tr><tr><td>content</td><td>text</td><td>内容</td><td></td></tr><tr><td>theme</td><td>varchar(2)</td><td>主题</td><td></td></tr><tr><td>thumb_image</td><td>varchar(255)</td><td>图文信息缩略图</td><td></td></tr><tr><td>views</td><td>int(4)</td><td>浏览量</td><td></td></tr><tr><td>comments</td><td>int(4)</td><td>评论数</td><td></td></tr><tr><td>shares</td><td>int(4)</td><td>分享次数</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>创建日期</td><td></td></tr><tr><td>is_top</td><td>char(1)</td><td>置顶标识</td><td></td></tr><tr><td>info_type</td><td>varchar(20)</td><td>信息类型</td><td></td></tr><tr><td>user_id</td><td>int(8)</td><td>用户id</td><td></td></tr><tr><td>origin_id</td><td>int(8)</td><td>信息所属组织id</td><td></td></tr><tr><td>state</td><td>char(2)</td><td>状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-21 评论表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>comment_id</td><td>int(11)</td><td>主键</td><td>自动增长</td></tr><tr><td>content</td><td>varchar(500)</td><td>评论内容</td></tr></tbody></table><p>续表3-21</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>create_time</td><td>datetime</td><td>评论日期</td><td></td></tr><tr><td>user_id</td><td>int</td><td>评论人</td><td>外键</td></tr><tr><td>info_id</td><td>int</td><td>评论的信息id</td><td>外键</td></tr></tbody></table><p>表3-22 信息转发表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>create_time</td><td>datetime</td><td>转发时间</td><td></td></tr><tr><td>info_id</td><td>int(11)</td><td>被转发的信息id</td><td>外键</td></tr><tr><td>user_id</td><td>int(8)</td><td>转发人id</td><td>外键</td></tr><tr><td>where</td><td>varchar(20)</td><td>转发方式</td></tr></tbody></table><p>表3-23 收藏表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>collect_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>create_time</td><td>datetime</td><td>收藏时间</td><td></td></tr><tr><td>info_id</td><td>int</td><td>收藏信息的id</td><td>外键</td></tr><tr><td>user_id</td><td>int</td><td>收藏人</td><td>外键</td></tr><tr><td>state</td><td>char(2)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-24 信息订阅表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>sub_id</td><td>int(11)</td><td>主键</td><td>自动增长</td></tr><tr><td>create_time</td><td>datetime</td><td>订阅时间</td><td></td></tr><tr><td>info_type</td><td>varchar(20)</td><td>订阅信息类型</td><td></td></tr><tr><td>is_email</td><td>char(1)</td><td>邮箱订阅标识</td><td></td></tr><tr><td>user_id</td><td>int(8)</td><td>用户id</td><td></td></tr><tr><td>state</td><td>char(2)</td><td>状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-25 招聘信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>recruitId</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>title</td><td>varchar(20)</td><td>招聘标题</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>创建时间</td></tr></tbody></table><p>续表3-25</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>end_time</td><td>datetime</td><td>招聘结束时间</td><td></td></tr><tr><td>members</td><td>int(4)</td><td>招聘人数</td><td></td></tr><tr><td>resumes</td><td>int(4)</td><td>简历投送数</td><td></td></tr><tr><td>leader_name</td><td>varchar(20)</td><td>联系人</td><td></td></tr><tr><td>leader_phone</td><td>varchar(30)</td><td>联系方式</td><td></td></tr><tr><td>is_top</td><td>char(1)</td><td>置顶标识</td><td></td></tr><tr><td>pos_name</td><td>varchar(20)</td><td>职位名称</td><td></td></tr><tr><td>pos_desc</td><td>varchar(500)</td><td>职位描述</td><td></td></tr><tr><td>benefit</td><td>varchar(50)</td><td>职位福利</td><td></td></tr><tr><td>work_place</td><td>varchar(50)</td><td>工作地点</td><td></td></tr><tr><td>unit_id</td><td>int(8)</td><td>招聘单位id</td><td></td></tr><tr><td>user_id</td><td>int</td><td>发布人id</td><td>外键</td></tr><tr><td>state</td><td>char(1)</td><td>状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-26 招聘单位信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>unit_id</td><td>int(8)</td><td>主键</td><td>自动增长</td></tr><tr><td>unit_name</td><td>varchar(30)</td><td>招聘单位名称</td><td></td></tr><tr><td>industry</td><td>varchar(30)</td><td>单位所属行业</td><td></td></tr><tr><td>property</td><td>varchar(20)</td><td>单位性质</td><td></td></tr><tr><td>scale</td><td>varchar(20)</td><td>单位规模</td><td></td></tr><tr><td>unit_desc</td><td>text</td><td>单位简介</td><td></td></tr><tr><td>unit_web</td><td>varchar(30)</td><td>单位网站</td><td></td></tr><tr><td>user_id</td><td>int(8)</td><td>发布者id</td><td>外键</td></tr><tr><td>state</td><td>char(1)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-27 附件表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>atta_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>atta_name</td><td>varchar(32)</td><td>附件文件名</td><td></td></tr><tr><td>atta_type</td><td>varchar(20)</td><td>附件类型</td></tr></tbody></table><p>续表3-27</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>is_romote</td><td>char(1)</td><td>远程文件标识</td><td></td></tr><tr><td>file_path</td><td>varchar(255)</td><td>文件路径</td><td></td></tr><tr><td>file_size</td><td>char(10)</td><td>文件大小</td><td></td></tr><tr><td>dowmloads</td><td>int(4)</td><td>文件下载次数</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>上传日期</td></tr></tbody></table><p>表3-28 信息附件表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>attachment_id</td><td>int</td><td>附件id</td><td>外键</td></tr><tr><td>info_id</td><td>int</td><td>信息id</td><td>外键</td></tr></tbody></table><p>表3-29 数据字典表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>dict_value</td><td>varchar(20)</td><td>字典值</td><td>主键</td></tr><tr><td>dict_name</td><td>varchar(50)</td><td>字典名</td><td></td></tr><tr><td>remark</td><td>varchar(200)</td><td>字典备注</td></tr></tbody></table><p>表3-30 数据字典数据表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int(8)</td><td>数据id</td><td>主键</td></tr><tr><td>dict_value</td><td>varchar(20)</td><td>数据字典</td><td>外键</td></tr><tr><td>dictdata_name</td><td>varchar(50)</td><td>数据名</td><td></td></tr><tr><td>dictdata_value</td><td>varchar(20)</td><td>数据值</td><td></td></tr><tr><td>is_fixed</td><td>char(1)</td><td>固定标识</td><td></td></tr><tr><td>is_cancel</td><td>char(1)</td><td>数据取消标识</td><td></td></tr><tr><td>parent_id</td><td>int(8)</td><td>父节点</td></tr></tbody></table><p>表3-31 日志表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>log_id</td><td>int(11)</td><td>日志id</td><td>主键</td></tr><tr><td>operator</td><td>varchar(100)</td><td>操作员</td><td></td></tr><tr><td>oper_name</td><td>varchar(100)</td><td>操作名称</td><td></td></tr><tr><td>oper_params</td><td>varchar(255)</td><td>操作参数</td><td></td></tr><tr><td>oper_result</td><td>varchar(100)</td><td>操作结果</td><td></td></tr><tr><td>oper_time</td><td>datetime</td><td>操作时间</td></tr></tbody></table><p>表3-32 用户组织表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>user_id</td><td>int</td><td>用户id</td><td>外键</td></tr><tr><td>origin_id</td><td>int</td><td>组织id</td><td>外键</td></tr><tr><td>create_time</td><td>datetime</td><td>加入时间</td><td></td></tr><tr><td>state</td><td>varchar(2)</td><td>状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态时间</td></tr></tbody></table><p>4 系统详细设计</p><p>4.1 班级录</p><p>（1） 功能实现</p><p>班级录主要实现给用户提供班级空间的功能，班级录总览界面按年级信息统计并展示院校当前班级的信息，按年级、校友姓名、班级专业条件查询班级并且能够在侧边栏按班级人数对班级进行热度排名，展示当前用户加入的班级，最近加入班级录的校友等信息。</p><p>（2） 实现方法</p><p>点击班级录标签页，请求class.action访问到Class控制器中的index()方法，index()调用ClassService业务逻辑类中的getAll()，查询年级信息，返回List<grade>类型的数据，添加到视图模型model中。Grade类对象中包含年级、班级个数等信息，index()方法跳转到class-index.jsp页面，展示年纪列表信息，并将年级列表加载到条件查询框中的下拉框中。页面加载时引入javascript，使用$.post()方法请求侧边栏数据。侧边栏数据包括班级录信息统计、班级排名、当前用户加入的班级、最近加入的校友等信息。在条件查询框中选择年级、填入校友姓名或专业关键字可以查询相关班级，提交查询时请求Class控制器中的queryClass()方法，传递grade、queryStr参数。queryClass()调用ClassService()业务逻辑类中的queryClasses()方法,queryClasses()方法的参数为Page&lt;&gt;类型的对象、grade、queryStr，queryClasses()执行查询,并返回 List<map<string,object>&gt;类型的数据。类型为Page&lt;&gt;的参数是分页对象，分页对象中包含分页的所有信息，包括页码pageIndex、pageSize、beanList等，新建分页对象时，如果没有设置参数，则pageIndex默认为1，pageSize默认为10。将page对象加入到视图模型model中，queryClass()返回class-query.jsp页面。jsp页面将班级信息列表展示出来，并追加页码执行翻页功能。</map<string,object></grade></p><p>（3） 界面设计</p><p>班级录总览界面如图4-1所示，总体分为导航栏、年级列表和侧边信息栏。班级查询界面如图4-2所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image002.jpg" alt="img"></p><p>图4-1 班级录总览界面</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image004.jpg" alt="img"></p><p>图4-2 班级查询界面</p><p>4.1.1 班级首页</p><p>（1）功能实现</p><p>班级主页主要对班级进行一些简介，并展示班级的一些近期信息，如班级简介、班级最新动态、班级最新照片、班级管理员信息、当前用户信息以及当前用户是否加入班级等。班级简介为班级实体中描述班级的字段，包括班级名称、班级人数、班级简介、班级所属年级。班级最新动态是班级动态按照日期降序排列后，选择最新的几条记录显示。班级最新照片是班级成员上传到班级相册照片，按照上传日期降序排列后选择最新的几张进行展示。班级管理员信息展示管理员的头像、姓名、简介等信息。当前用户信息展示当前用户的头像、姓名、简介、是否加入班级。</p><p>（2）实现方法</p><p>点击班级名称超链接，请求classroom.action，并传入班级id参数，Classroom控制器中index()方法接收参数,调用业务逻辑类ClassService中的classIndex()、classInfo()、classImage()、getAllMemberId()方法。clasIndex()方法查询班级的详细信息，返回Map<string, object>类型的数据，赋值给classroom，将返回数据classroom添加到视图模型model中。classInfo()查询班级的动态消息，动态消息按照日期降序排列，以List<map<string, object>&gt;类型返回日期最新的几条记录，赋值给infoList,将infoList添加到视图模型model中。classImage()方法查询班级成员上传的照片，照片按照上传日期降序排列，以List<map<string, object>&gt;类型返回上传日期最新的几条记录，赋值给imageList，将imageList添加到视图模型model中。getAllMemberId()查询所有班级成员的id，以List&lt; Integer&gt;类型返回，赋值给classIds，并将classIds添加到视图模型model中。Classroom控制器方法index()跳转到classroomdex.jsp页面，将classroom、infoList、imageList中的信息遍历展示在jsp页面中,将SESSION_USER环境变量中的当前用户信息展示为当前用户信息，并将SESSION_USER中的userId与classIds中的数据进行比较，如果userId存在与classIds中,则显示用户已经加入班级，否则显示加入班级按钮。Classroom-index.jsp加载的时候引入javascript，使用$.post()方法请求班级官员信息，并返回到jsp页面进行展示。</map<string,></map<string,></string,></p><p>（3）界面设计</p><p>班级主页界面设计如图4-3所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image006.jpg" alt="img"></p><p>图4-3 班级主页界面</p><p>4.1.2 班级动态</p><p>1.班级动态列表</p><p>（1） 功能实现</p><p>班级动态列表展示班级成员发布的动态信息，查询以当前班级id和信息类型作为条件查询信息，并进行分页处理，将查询到的信息分页展示。</p><p>（2） 实现方法</p><p>点击班级动态标签页，请求classroom/info.action，传递参数classId，Classroom控制器中的info()方法接收参数，info()调用ClassService业务逻辑类中的classIndex()、classInfo()方法。clasIndex()方法查询班级的详细信息，返回Map<string, object>类型的数据，赋值给classroom，将返回数据classroom添加到视图模型model中。classInfo()方法参数为Page&lt;&gt;类型数据、班级id和信息类型（数据字典中的信息类型数据），方法返回List<map<string, object>&gt;类型的数据。类型为Page&lt;&gt;的参数是分页对象，分页对象中包含分页的所有信息，包括页码pageIndex、pageSize、beanList等，新建分页对象时，如果没有设置参数，则pageIndex默认为1，pageSize默认为10。将page对象加入到视图模型model中，info()返回classroom-info.jsp页面。jsp页面将班级信息、班级动态信息列表展示出来，并追加页码执行翻页功能。</map<string,></string,></p><p>（3） 界面设计</p><p>班级动态列表界面如图4-4所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image008.jpg" alt="img"></p><p>图4-4 班级动态界面</p><p>2.班级动态详情</p><p>（1）功能实现</p><p>班级动态详情实现动态消息的详情展示，作者信息，消息评论区，以及班级相关动态和作者相关动态。班级动态消息详情包括图文信息、发布时间、浏览量、喜欢数、评论数，消息加载时动态消息的浏览量自增1。作者信息栏展示作者的头像、名字、简介等信息。评论区默认加载10条评论，点击加载更多评论按钮则再次加载10条评论，知道所有评论被加载完毕，用户可以在评论区发表评论。页面加载时，通过ajax方式将班级相关动态和作者相关动态加载到侧边栏。</p><p>（2）实现方法</p><p>点击消息详情按钮，请求classroom/infoDetail.action，传递班级id和消息id，Classroom控制器中的infoDetail()方法接收参数，调用ClassroomService业务类中的classInfoDetail()方法查询动态信息详情和作者信息，返回Map<string, object>类型的数据，赋值给info，将info添加到视图模型model中。infoDetail()返回classroom-info-detail.jsp页面，将info中的信息展示，并引入javascript使用ajax方式加载评论和侧边栏信息。</string,></p><p>（3）界面设计</p><p>班级动态信息详情界面和评论区界面如图4-5和图4-6所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image010.jpg" alt="img"></p><p>图4-5 班级动态详情界面</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image012.jpg" alt="img"></p><p>图4-6 班级动态消息评论区界面</p><p>4.1.3 班级通讯录</p><p>（1）功能实现</p><p>班级通讯录五章表关联查询班级成员的用户信息、所在地、电话、邮箱、QQ、微信等通讯信息，分页显示，并且支持下载班级通讯录信息，以Excel文件形式下载到本地。</p><p>（2）实现方法</p><p>点击通讯录标签页，请求classroom/directory.action，传递参数班级id，Classroom控制器中的directory()方法接收参数，并调用ClassrommService业务类中的classDirector()方法。classDirectory()关联user表、user_origin表、origin表、user_info表、image表，查询用户信息、用户通讯信息，以List<map<string, object>&gt;的形式返回通讯录列表，赋值给分页对象page中的beanList，并将page添加到视图模型model中。Directory()方法跳转classroom-directory.jsp页面，将beanList里的通讯录信息遍历出来。</map<string,></p><p>（3）界面设计</p><p>班级通讯录的界面设计如图4-7所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image014.jpg" alt="img"></p><p>图4-7 班级通讯录界面</p><p>4.1.4 班级相册</p><p>（1）功能实现</p><p>在班级相册中，班级成员可以查看相册、新建相册、上传图片、删除图片、设置相册封面、下载图片。上图图片支持批量上传，相册封面可以选择相册内的任意图片作为封面。</p><p>（2）实现方法</p><p>点击班级相册标签页，请求classroom/album.action，传递参数班级id，Classroom控制器中的album()方法接收参数，调用AlbumService业务类中的getAlbums()方法，以List<album>形式返回相册信息，赋值给分页对象page的beanList属性，返回classroom-album.jsp界面，将相册列表分页显示。</album></p><p>（3）界面设计</p><p>班级相册界面设计如图4-8所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image016.jpg" alt="img"></p><p>图4-8 班级相册界面</p><p>4.2 职业招聘</p><p>4.2.1 发布招聘</p><p>（1）功能实现</p><p>发布招聘时，系统判断当前用户是否已经登记公司信息，如果没有登记则跳转公司信息登记界面，否则跳转招聘登记界面。在招聘登记界面填写招聘信息后提交审核，后台管理员可以审核、置顶招聘。</p><p>（2）实现方法</p><p>点击发布招聘按钮，请求recruit/addRecruit.action，Recruit控制器中的addRecruit()方法接收请求，首先调用UnitService业务类中的getUnitsByUserId()方法查询当前用户的公司信息。如果公司信息，则返回redirect:/unit/addUnit.action，重定向到公司信息登记界面，否则addRecruit()将招聘常量positionSalary、positionBenefit、positionProf添加到视图模型model中，跳转至招聘信息登记界面。招聘信息表单填写完成后，提交至recruit/addRecruitSubmit.action，Recruit控制器调用RecruitService业务类中的createRecruit()方法，保存招聘信息，等待审核。</p><p>（3）界面设计</p><p>招聘单位信息登记界面设计如图4-9所示，招聘信息登记界面如图5-10所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image018.jpg" alt="img"></p><p>图4-9 招聘单位登记界面</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image020.jpg" alt="img"></p><p>图4-10 招聘信息登记界面</p><p>4.2.2 查询招聘</p><p>（1）功能实现</p><p>招聘查询可以招聘信息标题、招聘单位名称、职位信息、工作地点等查询招聘信息，并将查询到的记录分页显示。</p><p>（2）实现方法</p><p>点击职业招聘按钮，请求recruit.action，传递查询条件queryStr，Recruit控制器中的indexRecruit()方法，调用RecruitService业务类中的queryRecruit()方法执行查询，返回分页对象page，跳转到recruit-index.jsp页面，将招聘信息遍历出来并追加页码，执行翻页功能。</p><p>（3）界面设计</p><p>招聘查询界面如图4-11所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image022.jpg" alt="img"></p><p>图4-11 招聘查询界面</p><p>4.2.3 招聘详情</p><p>（1）功能实现</p><p>招聘详情展示招聘的详细信息，包括招聘单位信息、职位信息、联系人信息，并且能够加载此招聘信息的申请记录以及本招聘单位的相关招聘信息。</p><p>（2）实现方法</p><p>点击招聘信息标题超链接，请求recruit/detailRecruit.action，传递招聘信息id，Recruit控制器中的detailRecruit()方法接收参数，调用RecruitService业务类中的getDetailRecruit()、loadResumesToPost()、postResumeRecord()、loadOtherRecruits()等方法。getDetailRecruit()方法查询招聘的详细信息，返回Map<string,object>类型的数据，并添加到视图模型对象model中。postResumeRecord()方法关联recruit_post表、user表、image表查询出对此招聘信息投递简历的用户列表，返回List<map<string,object>&gt;类型的数据，并添加到视图模型对象中。LoadOtherRecruits()方法关联recruit_post表、recruit表，查询出此招聘单位的相关招聘信息，返回List<map<>&gt;类型的数据，并添加到数图模型对象model中。</map<></map<string,object></string,object></p><p>（3）界面设计</p><p>招聘查询界面如图4-12所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image024.jpg" alt="img"></p><p>图4-12 招聘查询界面</p><p>4.2.4 投递简历</p><p>（1）功能实现</p><p>在简历详情界面中，有简历投递选项，用户选择自己的简历投送至当前招聘信息。如果当前用户没有简历，则可以选择创建简历。</p><p>（2）实现方法</p><p>如果用户已经申请当前职位，则显示已申请职位，否则显示申请职位按钮。点击申请职位按钮，页面弹出简历投递模态框，通过c标签将用户简历列表加载到下拉框中，选择一个简历，点击确认申请按钮，请求my/resume/postResume.action，传递招聘信息id，用户简历id，用户信息控制器中的postResume()接收参数，并调用ResumeService服务类中的postResume()方法，保存简历投递信息。</p><p>（3）界面设计</p><p>简历投递界面如图4-13所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image026.jpg" alt="img"></p><p>图4-13 简历投递界面</p><p>4.3 校友论坛</p><p>4.3.1 论坛广场</p><p>（1）功能实现</p><p>论坛广场分页展示校友论坛的所有帖子，可以按照帖子标题、帖子主题和帖子作者进行模糊查询，并按照帖子的热度进行排名。</p><p>（2）实现方法</p><p>点击校友论坛，请求forum.action，Forum控制器中的index()方法接收请求，调用PostService中的queryPosts()方法，按日期降序排列并分页查询帖子，返回List<map<string,object>&gt;类型的数据，赋值给分页对象page，将page添加到视图模型对象model中。返回forum-index.jsp页面，将page中beanList的帖子信息分页显示。</map<string,object></p><p>（3）界面设计</p><p>论坛广场界面设计如图4-14所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image028.jpg" alt="img"></p><p>图4-14 校友论坛广场界面</p><p>4.3.2 发布新帖</p><p>（1）功能实现</p><p>用户可以在校友论坛广场发布新贴，帖子会被推送到广场并可以被搜索。</p><p>（2）实现方法</p><p>点击发布新贴按钮，请求post/add.action，Post控制器中的addPost()方法接收请求，将环境变量themeList添加到视图模型对象model中，加载帖子发布界面。在帖子发布界面填写post表单并提交，post信息存储至数据库，重新加载招聘广场即可看到新发布的帖子。</p><p>（3）界面设计</p><p>发布新贴界面如图4-15所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image030.jpg" alt="img"></p><p>图4-15 发布新贴界面</p><p>4.3.3 帖子详情</p><p>（1）功能实现</p><p>用户可以查看帖子详情，包括帖子内容、浏览量、评论量、喜欢数、作者信息，在帖子内容下方有评论区，加载评论内容或发表评论。在详情界面侧边栏显示相关主题的帖子和作者相关的帖子。</p><p>（2）实现方法</p><p>用户点击帖子标题超链接，请求post/detail.action，Post控制器中的detail()方法接收请求，调用PostService业务类中的postDetail()方法查询帖子详情，将返回的数据添加到视图模型对象model中，返回jsp页面显示帖子内容。页面加载完毕后，通过jquery的$.post()方法请求post/commentList.action和post/outLine.action加载评论区内容和侧边栏内容，Post控制器调用PostService业务类中的getOtherPost()f方法和CommentService业务类中的dynamicComment()方法查询信息，将返回的信息追加到页面，完成动态加载评论的功能。</p><p>（3）界面设计</p><p>帖子详情界面设计如图4-16所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image032.jpg" alt="img"></p><p>图4-16 帖子详情界面</p><p>结论</p><p>经过持久层、数据访问层、业务逻辑层、系统控制层、视图层的设计和实现，本系统基本实现了对班级管理，用户可以加入自己所在的班级；对班级留言的管理，用户可以在班级里查看、添加或修改留言；对班级通讯录的管理，用户可以查看班级成员的相关信息。系统已经能够实现留言、上传照片、评论等功能，同时具有方便的后台管理功能。同学录系统能够实现同学们生活中的交流，拥有自己的空间。校友论坛为广大校友提供了更加宽阔的平台，促进校友们之间的交流。与此同时，通过职业招聘模块、校园服务模块，校方管理员能够了解毕业生的就业情况，并为毕业生提供就业服务，包括向毕业生投送招聘信息，接收毕业生所在单位的招聘信息。因此，此系统能够在促进高校专业教学改革、募集高校筹资办学途径、促进校企合作、加强毕业生感情交流、提升大学生就业质量等方面带来巨大效益。</p><p>当然，本系统还不够完善，有一部分功能尚未实现。新闻中心应该具备热文推送和邮箱订阅功能，这样才能让校友更好的了解母校的动态消息。  网站内的消息应该支持富文本格式，这样可以使消息更具可读性和吸引力，同时富文本编辑器可以让用户更方便地编写内容。在消息发布和图片上传时，图片经过剪辑之后才可以更好地展示和存储。由于个人能力的限制，网站的邮箱订阅功能、富文本编辑存储功能和图片剪辑功能并没有实现。这些功能对本系统也显得尤为重要，因此以后必须实现。</p><p>经过对校友录系统的设计和实现，我对MVC模式有了更深层次的理解和应用。同时，我也学会许多新的框架和工具，包括SpringMVC、MyBatis、EhCache、Bootstrap、AmazeUI等框架，Maven、Git、IntelliJ IDEA等工具。因此，我相信在以后面临的工作和项目中本系统对我有很大帮助。</p><p>致谢</p><p>本论文的编写和修改是在胡局新老师悉心指导下完成的。胡老师有着严谨有致的教学态度，兢兢业业的工作作风，诲人不倦的高尚师德。在胡老师的每一堂课上，我都能感受到他的格物致知、敬业乐群，这也正是我在专业知识学习中保持热情的关键所在。在临近毕业的这段时间，胡老师也依然百忙之中为我讲解技术、指导论文，其崇高的责任心将是我受益一生的宝贵财富。在此，谨向我可敬可爱的胡老师致以诚挚的谢意。</p><p>不知不觉，四年的大学生活如白驹过隙般逝去，但这宝贵的四年无疑会在而后的回忆里细水长流。在徐州工程学院四年时间里我有过喜悦，有过沮丧，也学习了很多专业知识，参加了很多活动和比赛，获得了飞思卡尔智能汽车竞赛国赛奖项，电子设计大赛省级奖项。没有志同道合的校友，没有对我谆谆教诲的辅导员，没有对我坚定支持的母校，我不可能取得这些成就，也很难在低谷时战胜困难。因此，我想对帮助我的校友，关爱我的辅导员，坚定支持我的母校致以崇高的谢意。</p><p>同时，我也要感谢生我育我的父母。我的家庭生活并非想象中那么美好，父母的艰辛也许我无法体会，但是即使再困难，父母都会给予我精神、物质上的支持。父母不曾亏待我，我又能拿什么面对父母。唯有不懈的努力，让自己成功的速度快于他们老去的速度，我才能回报他们对我的爱。对于父母所给予我的这一切，我会用生命去珍惜，用感恩去呵护。</p><p>最后，我想再一次向精心教导我的胡老师，关爱我的辅导员，志同道合的校友，给予我支持的父母表达我的感恩之情，没有你们就没有如今的我，谢谢你们伴我走过青春的这段旅途，谢谢！</p><p>参考文献</p><p>[1] 盛仲飙 乔道迹.基于Java的通讯软件设计与实现[J].福建电脑,2015</p><p>[2] 陈衍席.基于Java网络聊天系统的设计及实现研究[J].通讯世界,2016</p><p>[3] 钱雪忠著,数据库原理与应用（第二版）[M].北京邮电大学出版社,2007</p><p>[4] 唐汉明 翟振兴 关宝军.深入浅出MySQL数据库开发优化与管理维护第2版[M].人民邮电出版社,2014</p><p>[5] 吴海星.Java程序员修炼之道[M].人民邮电出版社,2013</p><p>[6] 缪忠剑.基于Spring的集成化Web开发平台的研究与实现[M].北京机械工业出版社,2013</p><p>[7] 宋佳颖,基于Java的邮件接收系统分析[J].无线互联科技,2015</p><p>[8] 耿祥义,张跃平著.Java设计模式[M].清华大学出版社,2009</p><p>[9] 彭晓青,MVC模式的应用架构系统的研究与实现[J].电子工业出版社,2013</p><p>[10] 赵争东,基于Java的数据库应用框架的研究设计和探索[J].信息系统工程,2015</p><p>[11] 软件开发技术联盟著,Java Web开发实战[M].清华大学出版社,2013</p><p>[12] 贾蓓.镇明敏.杜磊著,Java Web整合开发实战[M].清华大学出版社,2013</p><p>[13] 李运莉著,web数据库应用系统性能优化[M].北京人民邮电出版社,2011</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;校友录网站。作为毕业设计，为母校设计校友交流平台。基于javaWeb，由Maven构建管理，采用Spring+SpringMVC+MyBatis框架，用EhCache做数据缓存。门户网站采用BootStrap设计界面，后台管理网站用AmazeUI设计界面。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="https://blackist.org/categories/JavaWeb/"/>
    
    
      <category term="开发" scheme="https://blackist.org/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="java" scheme="https://blackist.org/tags/java/"/>
    
      <category term="spring" scheme="https://blackist.org/tags/spring/"/>
    
      <category term="javaweb" scheme="https://blackist.org/tags/javaweb/"/>
    
      <category term="校友录" scheme="https://blackist.org/tags/%E6%A0%A1%E5%8F%8B%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>校友录设计</title>
    <link href="https://blackist.org/2019/06/23/spring-ar-introduce/"/>
    <id>https://blackist.org/2019/06/23/spring-ar-introduce/</id>
    <published>2019-06-23T09:11:19.000Z</published>
    <updated>2019-06-30T16:01:39.927Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>校友录网站。作为毕业设计，为母校设计校友交流平台。基于javaWeb，由Maven构建管理，采用Spring+SpringMVC+MyBatis框架，用EhCache做数据缓存。门户网站采用BootStrap设计界面，后台管理网站用AmazeUI设计界面。</p><a id="more"></a><p>项目地址：<a href="https://github.com/blackist/ar" target="_blank" rel="noopener">https://github.com/blackist/ar</a></p><p><strong>摘要</strong></p><p>校友作为高校的一种重要资源，在促进高校专业教学改革、募集高校筹资办学途径、促进校企合作、加强毕业生感情交流、提升大学生就业质量等方面发挥着重要作用。然而目前我校并没有一个系统可以追溯毕业生的情况。因此，校友们需要一个平台，来了解母校的新闻，校友们的近况，同时也能够让院校充分了解毕业生的就业状况。</p><p>为了给校友们的提供一个了解母校动态的平台，本设计首先确定以毕业生以及高校为主要用户对象，采用目前业内流行的SpringMVC+Spring+MyBatis轻量级JavaEE框架，用Maven构建和管理，开发基于B/S结构的校友录系统。其次，通过系统建模对系统的各项功能进行了分析，确定了校友录系统的功能模块，并阐述了数据库的设计过程。再次对系统的功能模块进行了详细的设计，并对系统功能模块的界面进行了展示。最后对论文所阐述的内容进行总结，并分析了校友录系统对毕业生和院校带来的便利。</p><p>校友录系统是在对师生、院校进行充分的调研分析之后设计的，校友更多关注的是院校新闻、班级动态、校友信息以及社团学生会等团体，院校更多关注的是毕业生的就业情况、对本校毕业生招聘信息的推送。为满足院校和毕业生的需求，校友录系统设计了新闻中心模块、班记录模块、校友组织模块、校友论坛模块、职业招聘模块、校园服务模块。</p><p>校友录系统不仅能够很好地满足校友了解母校、校友动态的需求，也提供职业招聘、校园服务功能，使院校能够更好地了解毕业生就业情况、为毕业生提供就业服务。</p><p><strong>关键词</strong> 毕业；校友录；就业；JavaEE</p><p><strong>Abstract</strong></p><p>Youth is the best time in life, and this period of youth spent in the university will undoubtedly become the most valuable memories of our lives.Although time goes by fast, university life, the impressive community, the memorable alumni, the unforgettable teaching building, will be a subsequent stream of water in the memories. After graduation, we left school, along with the alumni miss and the alma mater’s attention. Thus, alumni desire for a platform to follow the news of alma mater, the status of alumni, and the dynamics of the group that they have joined.</p><p>​    In order to provide a sustenance for alumni’s emotions, this design, taking graduates and colleges as the main user object, using the current industry-popular SpringMVC + Spring + MyBatis lightweight JavaEE framework, develops the computer-based web pages Version of the simple and elegant Alumni Record System ( AR), built and managed by Maven.</p><p>​    AR is designed after a full investigation and analysis is conducted in the teachers, students and institutions. Alumni pay more attention to the school news, class dynamics, alumni information, community students and other groups. Institutions concern more about the graduates’ employment situation, new enrollment situation and delivery of recruit information about school graduates. AR designs the news center module, class record module, alumni organization module and alumni forum module. And album function is added into the class record and alumni organization, which aims to meet the needs of alumni better. At the same time, AR includes professional recruitment module, campus service module, so that institutions can understand the employment situation of graduates and help graduates better.</p><p>AR system not only can meet alumni to understand the alma mater, alumni dynamic needs, but also provide professional recruitment, campus service function, so that institutions can better understand the employment situation of graduates, to provide employment services for graduates.</p><p><strong>Keywords</strong>  graduation  alumni-record  employment  javaee</p><p><strong>目</strong>       <strong>录</strong></p><p><a href="#_Toc482890209">摘要… I</a></p><p><a href="#_Toc482890210">Abstract II</a></p><p><a href="#_Toc482890211">1 绪论… 1</a></p><p><a href="#_Toc482890212">1.1 课题背景… 1</a></p><p><a href="#_Toc482890213">1.2 课题意义… 1</a></p><p><a href="#_Toc482890214">1.3 课题内容… 1</a></p><p><a href="#_Toc482890215">1.4 论文的组织结构… 1</a></p><p><a href="#_Toc482890216">2 系统需求分析… 3</a></p><p><a href="#_Toc482890217">2.1 需求分析… 3</a></p><p><a href="#_Toc482890218">2.2 功能分析… 4</a></p><p><a href="#_Toc482890219">2.2.1 院校新闻发布功能… 4</a></p><p><a href="#_Toc482890220">2.2.2 班级管理功能… 5</a></p><p><a href="#_Toc482890221">3.2.3 院校组织管理功能… 6</a></p><p><a href="#_Toc482890222">3.2.4 校友论坛功能… 6</a></p><p><a href="#_Toc482890223">3.2.5 院校职业招聘功能… 7</a></p><p><a href="#_Toc482890224">3.2.6 校园服务功能… 7</a></p><p><a href="#_Toc482890225">3.2.7 用户个人中心功能… 8</a></p><p><a href="#_Toc482890226">2.4 技术路线… 9</a></p><p><a href="#_Toc482890227">3 系统总体设计… 11</a></p><p><a href="#_Toc482890228">3.1 系统总体设计… 11</a></p><p><a href="#_Toc482890229">3.1.1 系统登录… 11</a></p><p><a href="#_Toc482890230">3.1.2 新闻中心… 11</a></p><p><a href="#_Toc482890231">3.1.3 班级录… 11</a></p><p><a href="#_Toc482890232">3.1.4 校友组织… 11</a></p><p><a href="#_Toc482890233">3.1.5 校友论坛… 11</a></p><p><a href="#_Toc482890234">3.1.6 职位招聘… 12</a></p><p><a href="#_Toc482890235">3.1.7 校园服务… 12</a></p><p><a href="#_Toc482890236">3.1.8 个人中心… 12</a></p><p><a href="#_Toc482890237">3.2 系统功能设计… 12</a></p><p><a href="#_Toc482890238">3.2.1 新闻中心… 12</a></p><p><a href="#_Toc482890239">3.2.2 班记录… 13</a></p><p><a href="#_Toc482890240">3.2.3 校友组织… 14</a></p><p><a href="#_Toc482890241">3.2.4 校友论坛… 14</a></p><p><a href="#_Toc482890242">3.2.5 职业招聘… 15</a></p><p><a href="#_Toc482890243">3.2.6 校园服务… 16</a></p><p><a href="#_Toc482890244">3.2.8 个人中心… 16</a></p><p><a href="#_Toc482890245">3.3 数据库设计… 17</a></p><p><a href="#_Toc482890246">3.3.1 概念模型设计… 17</a></p><p><a href="#_Toc482890247">3.3.2 逻辑结构设计… 25</a></p><p><a href="#_Toc482890248">4 系统详细设计… 37</a></p><p><a href="#_Toc482890249">4.1 班级录… 37</a></p><p><a href="#_Toc482890250">4.1.1 班级首页… 38</a></p><p><a href="#_Toc482890251">4.1.2 班级动态… 40</a></p><p><a href="#_Toc482890252">4.1.3 班级通讯录… 42</a></p><p><a href="#_Toc482890253">4.1.4 班级相册… 43</a></p><p><a href="#_Toc482890254">4.2 职业招聘… 44</a></p><p><a href="#_Toc482890255">4.2.1 发布招聘… 44</a></p><p><a href="#_Toc482890256">4.2.2 查询招聘… 45</a></p><p><a href="#_Toc482890257">4.2.3 招聘详情… 46</a></p><p><a href="#_Toc482890258">4.2.4 投递简历… 47</a></p><p><a href="#_Toc482890259">4.3 校友论坛… 48</a></p><p><a href="#_Toc482890260">4.3.1 论坛广场… 48</a></p><p><a href="#_Toc482890261">4.3.2 发布新帖… 49</a></p><p><a href="#_Toc482890262">4.3.3 帖子详情… 49</a></p><p><a href="#_Toc482890263">结论… 51</a></p><p><a href="#_Toc482890264">致谢… 52</a></p><p><a href="#_Toc482890265">参考文献… 53</a></p><p>1 绪论</p><p>1.1 课题背景</p><p>青春是人生最美好的时光，而在大学度过的这一段青春岁月无疑将成为我们人生中最为宝贵的回忆。大学生活如白驹过隙匆匆流逝，却又将在而后的回忆里细水长流，忘不掉的社团，忘不掉的校友， 忘不掉的教学楼。毕业后，我们离开学校，一同带走的还有对校友的思念和对母校的关注。因此，校友们需要一个平台，来了解母校的新闻，校友们的近况，自己曾加入的团体的动态等等。</p><p>同时，院校对毕业生的培养与关怀也不会停止，院校希望了解毕业生的就业情况，并为毕业生提供就业服务，包括向毕业生投送招聘信息，接收毕业生所在单位的招聘信息。并且，校友作为高校的一种重要资源，在促进高校专业教学改革、募集高校筹资办学途径、促进校企合作、加强毕业生感情交流、提升大学生就业质量等方面发挥着重要作用。这也有助于改善教学方案，从而使本校毕业生更好地适应社会需求。</p><p>1.2 课题意义</p><p>中国同学录网的调查显示，用户最关心的是班级信息、班级留言、同学联系方式和同学照片等。不同用户对系统的需求不同，但是基本功能需求是一致的，包括：对班级管理，用户可以创建自己所在的班级；对班级留言的管理，用户可以在班级里查看、添加或修改留言；对班级通讯录的管理，用户可以查看班级成员的相关信息。</p><p>此系统还可以让校友了解母校的新闻，校友们的近况，自己曾加入的团体的动态，也提供了职业招聘功能，此功能是院校和毕业生交互的重要平台。院校可在职业招聘模块发布招聘信息，毕业生可以浏览招聘信息、投递简历、在线制作简历，毕业生可以发布自己所在单位的招聘信息，经管理员审核后发布到招聘广场，为其他毕业校友提供有力的就业帮助。校友的信息反馈在促进高校专业教学改革、募集高校筹资办学途径、促进校企合作、加强毕业生感情交流、提升大学生就业质量等方面发挥着重要作用。</p><p>1.3 课题内容</p><p>此系统是在对师生、院校进行充分的调研分析之后设计的，校友更多关注的是院校新闻、班级动态、校友信息以及社团学生会等团体，院校更多关注的是毕业生的就业情况、新生的招生情况以及对本校毕业生招聘信息的投送。此系统设计了新闻中心模块、班记录模块、校友组织模块、校友论坛模块，并在班记录和校友组织中加入相册功能，更好地满足校友的需求。同时，此系统包含职业招聘模块、校园服务模块，使院校更好地了解毕业生就业情况、为毕业生提供帮助。</p><p>1.4 论文的组织结构</p><p>论文主要内容包括五大部分，主要包括：</p><p>第一章 绪论。本章介绍了课题背景、课题意义以及本课题研究的主要内容。</p><p>第二章 系统需求分析。本章介绍了本系统的业务需求分析、系统功能分析以及相关业务的流程，开发过程中具体的开发环境、开发工具、相关技术。</p><p>第三章 系统总体设计。本章介绍了本系统的总体设计、系统各项功能的设计以及数据库的设计。</p><p>第四章 系统详细设计。本章介绍了系统的详细设计，包括各项系统功能的界面设计、代码逻辑设计以及实现。 </p><p>2 系统需求分析</p><p>2.1 需求分析</p><p>中国同学录网的调查显示，用户最关心的是班级信息、班级留言、同学联系方式和同学照片等。不同用户对系统的需求不同，但是基本功能需求是一致的，包括：对班级管理，用户可以查询并加入自己所在的班级；对班级留言的管理，用户可以在班级里查看、添加或修改留言；对班级通讯录的管理，用户可以查看班级成员的相关信息。考虑到网络的现况和同学们以及毕业生跟踪调查的各种需求，系统应该具有各方面的交流能力和实时的用户反馈信息，能够实现留言、上传照片、评论等功能，同时具有方便的后台管理功能。同学录系统能够实现同学们生活中的交流，拥有自己的空间，与此同时，校方管理员能够了解毕业生的就业情况，并为毕业生提供就业服务，包括向毕业生投送招聘信息，接收毕业生所在单位的招聘信息。这也有助于改善教学方案，从而更好地让本校毕业生适应社会需求。系统主要功能有：</p><p>（1）系统用户的登录、注册。注册，由管理员将历届学生的学号、姓名导入数据库，学号作为用户的用户名；登录，输入用户输入用户名（学号）和密码登录系统；</p><p>（2）校园新闻发布中心功能：新闻发布，后台管理发布图文信息到门户网站，可置顶、编辑、删除新闻信息；新闻评论，用户可以对新闻信息发表评论，回复评论，动态加载地评论；新闻热度，用户喜欢可以新闻信息，系统根据信息的喜欢量、浏览流量推送新闻信息；</p><p>（3）同学交流的班级录功能。班级检索，按入学年份查询，按照班级名称、校友姓名查询，综合检索班级；班级排名，根据班级人数、活跃时间对班级进行热度排名；班级主页，每个班级有自己的空间，包括班级主页、班级动态、班级留言、班级成员、班级通讯录、班级相册、班级事务管理等；班级管理，班级的新增、管理员的设置由后台管理员完成；</p><p>（4） 校友互动的团体组织功能。校友总会，院校总会；院系分会，各学院的校友组织；社团分会，院校内的各种社团、协会的组织；学生协会，院校内的各学生协会组织；组织主页，个组织有自己的空间，包括组织主页、动态消息、留言、成员列表、通讯录、相册、活动、组织事务管理；</p><p>（5）校友话题参与的论坛功能。帖子浏览，按作者、主题检索帖子，查看详情，对帖子发表评论，回复评论、删除用户自己的评论，ajax动态加载评论；热帖推送，用户可以喜欢帖子，系统根据帖子的喜欢数量和浏览量进行推送；发布新帖，用户登录后可以发布帖子；贴子管理，管理员可审核、置顶、删除帖子；</p><p>（6） 职位招聘信息推送功能。招聘广场，浏览招聘信息，根据公司名称、职位名称、工作地点检索并查看招聘信息；简历投送，用户可以向喜欢的招聘信息投送个人简历；简历管理，用户可以新增简历、编辑简历、删除简历；单位管理，用户可以登记、编辑自己所在单位的信息；发布招聘，用户登记单位信息后可以发布招聘信息，由管理员审核后推送到招聘广场； </p><p>（7）招生就业的校园服务。校内服务，包括走进校园、校园行指南、学报编辑部、图书馆、档案馆、信息公开网等信息；招生就业服务，包括本科招生、成教招生、就业网、人才招聘、本站招聘等信息；</p><p>（8）用户个人管理中心。个人资料，基本资料、 详细资料、 工作信息、 头像设置；账户设置，密码修改、邮箱绑定；我的班级，用户加入的班级相关信息；我的论坛，用户早论坛的相关信息；我的招聘，用户发布的招聘信息，用户投递的简历信息，用户个人简历管理。</p><p>2.2 功能分析</p><p>基于对校友录系统的需求分析，校友录系统有新闻中心功能，管理员发布管理图文信息，用户可以浏览、评论新闻信息。校友录系统设置班记录功能，给班级同学提供班级空间，班级空间内有交流平台、班级相册，这是同学比较关心的功能。同时，校友录系统具有校友组织功能，校友可以加入校内的组织和团体，组织有自己的空间给组织成员提供交流平台。为给广大校友提供更大的交流平台，校友录系统提供校友论坛功能，校友可以浏览话题并参与讨论。为满足院校对招聘信息推送的需求，校友录系统应加入职业招聘模块，院校管理员发布招聘信息，用户浏览并投递简历，用户也可以发布自己所在单位的招聘信息，经管理员审核后发不到招聘广场。为更好地微笑有提供入学、就业服务，校友录系统设有校园服务，为校友提供校园指南和就业服务。最后，校友录系统为用户提供个人中心功能，对个人信息以及在站内的应用进行管理。</p><h3 id="2-2-1-院校新闻发布功能"><a href="#2-2-1-院校新闻发布功能" class="headerlink" title="2.2.1 院校新闻发布功能"></a>2.2.1 院校新闻发布功能</h3><p>1.新闻中心用例分析</p><p>新闻中心包括新闻发布，后台管理发布图文信息到门户网站，可置顶、编辑、删除新闻信息。新闻评论，用户可以对新闻信息发表评论，回复评论，动态加载评论。新闻热度，用户喜欢可以新闻信息，系统根据信息的喜欢量、浏览流量推送新闻信息。新闻中心用例如图2-1所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image002.jpg" alt="img"></p><p>图2-1 新闻中心用例图</p><h3 id="2-2-2-班级管理功能"><a href="#2-2-2-班级管理功能" class="headerlink" title="2.2.2 班级管理功能"></a>2.2.2 班级管理功能</h3><p>1、班记录用例分析</p><p>班记录包括班级检索，按入学年份查询，按照班级名称、校友姓名查询，综合检索班级；班级排名，根据班级人数、活跃时间对班级进行热度排名；班级主页，每个班级有自己的空间，包括班级主页、班级动态、班级留言、班级成员、班级通讯录、班级相册、班级事务管理等；班级管理，班级的新增、管理员的设置由后台管理员完成。班记录用例如图2-2所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image004.jpg" alt="img"></p><p>图2-2 班记录用例图</p><h3 id="2-2-3-院校组织管理功能"><a href="#2-2-3-院校组织管理功能" class="headerlink" title="2.2.3 院校组织管理功能"></a>2.2.3 院校组织管理功能</h3><p>1.校友组织用例分析</p><p>校友组织包括：校友总会，院校总会；院系分会，各学院的校友组织；社团分会，院校内的各种社团、协会的组织；学生协会，院校内的各学生协会组织；组织主页，个组织有自己的空间，包括组织主页、动态消息、留言、成员列表、通讯录、相册、活动、组织事务管理；校友组织用例如图2-3所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image006.jpg" alt="img"></p><p>图2-3 校友组织用例</p><h3 id="2-2-4-校友论坛功能"><a href="#2-2-4-校友论坛功能" class="headerlink" title="2.2.4 校友论坛功能"></a>2.2.4 校友论坛功能</h3><p>1.校友论坛用例分析</p><p>校友论坛包括：帖子浏览，按作者、主题检索帖子，查看详情，对帖子发表评论，回复评论、删除用户自己的评论，ajax动态加载评论；热帖推送，用户可以喜欢帖子，系统根据帖子的喜欢数量和浏览量进行推送；发布新帖，用户登录后可以发布帖子；贴子管理，管理员可审核、置顶、删除帖子；校友论坛用例如图2-4所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image008.jpg" alt="img"></p><p>图2-4 校友论坛用例图</p><h3 id="2-2-5-院校职业招聘功能"><a href="#2-2-5-院校职业招聘功能" class="headerlink" title="2.2.5 院校职业招聘功能"></a>2.2.5 院校职业招聘功能</h3><p>1.业招聘用例分析</p><p>职位招聘包括：招聘广场。浏览招聘信息，根据公司名称、职位名称、工作地点检索并查看招聘信息；简历投送，用户可以向喜欢的招聘信息投送个人简历；简历管理，用户可以新增简历、编辑简历、删除简历；单位管理，用户可以登记、编辑自己所在单位的信息；发布招聘，用户登记单位信息后可以发布招聘信息，由管理员审核后推送到招聘广场。职业招聘用例如图2-5所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image010.jpg" alt="img"></p><p>图2-5 职业招聘用例图</p><h3 id="2-2-6-校园服务功能"><a href="#2-2-6-校园服务功能" class="headerlink" title="2.2.6 校园服务功能"></a>2.2.6 校园服务功能</h3><p>1.校园服务用例分析</p><p>校园服务：校内服务，包括走进校园、校园行指南、学报编辑部、图书馆、档案馆、信息公开网等信息；招生就业服务，包括本科招生、成教招生、就业网、人才招聘、本站招聘等信息。校园服务用例如图2-6所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image012.jpg" alt="img"></p><p>图2-6 职业招聘用例图</p><h3 id="2-2-7-用户个人中心功能"><a href="#2-2-7-用户个人中心功能" class="headerlink" title="2.2.7 用户个人中心功能"></a>2.2.7 用户个人中心功能</h3><p>1.个人中心用例分析</p><p>个人中心：个人资料，基本资料、 详细资料、 工作信息、 头像设置；账户设置，密码修改、邮箱绑定；我的班级，用户加入的班级相关信息；我的论坛，用户早论坛的相关信息；我的招聘，用户发布的招聘信息，用户投递的简历信息，用户个人简历管理。个人中心用例如图2-7所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image014.jpg" alt="img"></p><p>图2-7 个人中心用例图</p><p>2.4 技术路线</p><p>本系统采用业内流行的SpringMVC+Spring+MyBatis框架（简称SSM），由项目构建工具Maven构建，并使用Git版本控制系统辅助项目开发。</p><p>Git是一个便捷的分布式版本控制工具，本项目用Git进行管理，可以轻松地备份项目，控制项目的版本，并且能够更安全地开发、调试。</p><p>Maven可以通过项目对象模型配置文件（pom.xml）轻松地构建项目，不用将jar包添加到项目，缩小了项目的体积。本系统使用Maven构建父模块ar-parent，并聚合了三个子模块ar-common、ar-manage、ar-portal。ar-common是项目的公共基础模块，java应用类的模型，包含实体类、工具类、数据访问对象等，依赖Spring、MyBatis等。ar-manage是本系统的后台管理模块，web应用类的模型，依赖ar-common、Spring、SpringMVC等。Ar-poratl是本系统的门户网站模块，依赖ar-common、ar-manage、Spring、SpringMVC等。Maven可以将web应用类项目打包成war并发布到tomcat服务器运行测试。</p><p>本系统充分利用Spring的IoC（控制反转）和AOP（面向切面）特性，将创建用户的SpringMVC控制器Controller、业务逻辑类Service、数据访问类Mapper交由Spring Container管理，生成对应的bean（也称组件）, 并把实现类的类名作为bean的id。当控制器、业务逻辑类、数据访问类需要Spring Container中bean对应的实现类时，Spring Container通过依赖注入机制为其注入对应的bean。通过这种配置，系统实现了控制器和业务逻辑类分离，业务逻辑类和数据访问类分离。SpringMVC中的DispatcherServlet接收请求，并交由控制器Controller处理，Controller接收参数、调用业务逻辑类中的方法，通过ModelAndView视图模型返回jsp页面、json数据。</p><p>本系统的视图层采用jsp、HTML，通过事件触发机制向服务器端发送请求，并采用Bootstrap、AmazeUI、HTML5、CSS3等前台样式，通过c标签、javascript、jquery处理前台数据。</p><p>技术路线如图2-8所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image016.jpg" alt="img"></p><p>图2-8 技术路线图</p><p>3 系统总体设计</p><p>3.1 系统总体设计</p><p>根据系统功能分析，本系统应该具备的功能包括：登录注册、新闻中心、班级录、校友组织、校友论坛、职位招聘、校园服务、个人中心等功能。</p><h3 id="3-1-1-系统登录"><a href="#3-1-1-系统登录" class="headerlink" title="3.1.1 系统登录"></a>3.1.1 系统登录</h3><p>（1）注册：由管理员将历届学生的学号、姓名导入数据库，学号作为用户的用户名；</p><p>（2）登录：输入用户输入用户名（学号）和密码登录系统。</p><h3 id="3-1-2-新闻中心"><a href="#3-1-2-新闻中心" class="headerlink" title="3.1.2 新闻中心"></a>3.1.2 新闻中心</h3><p>（1）新闻发布：后台管理发布图文信息到门户网站，可置顶、编辑、删除新闻信息；</p><p>（2）新闻评论：用户可以对新闻信息发表评论，回复评论，动态加载评论；</p><p>（3）新闻热度：用户喜欢可以新闻信息，系统根据信息的喜欢量、浏览流量推送新闻信息。</p><h3 id="3-1-3-班级录"><a href="#3-1-3-班级录" class="headerlink" title="3.1.3 班级录"></a>3.1.3 班级录</h3><p>（1）班级检索：按入学年份查询，按照班级名称、校友姓名查询，综合检索班级；</p><p>（2）班级排名：根据班级人数、活跃时间对班级进行热度排名；</p><p>（3）班级主页：每个班级有自己的空间，包括班级主页、班级动态、班级留言、班级成员、班级通讯录、班级相册、班级事务管理等；</p><p>（4）班级管理：班级的新增、管理员的设置由后台管理员完成。</p><h3 id="3-1-4-校友组织"><a href="#3-1-4-校友组织" class="headerlink" title="3.1.4 校友组织"></a>3.1.4 校友组织</h3><p>（1）校友总会：院校总会；</p><p>（2）院系分会：各学院的校友组织；</p><p>（3）社团分会：院校内的各种社团、协会的组织；</p><p>（4）学生协会：院校内的各学生协会组织；</p><p>（5）组织主页：个组织有自己的空间，包括组织主页、动态消息、留言、成员列表、通讯录、相册、活动、组织事务管理。</p><h3 id="3-1-5-校友论坛"><a href="#3-1-5-校友论坛" class="headerlink" title="3.1.5 校友论坛"></a>3.1.5 校友论坛</h3><p>（1）帖子浏览：按作者、主题检索帖子，查看详情；</p><p>（2）评论帖子：对帖子发表评论，回复评论、删除用户自己的评论，ajax动态加载评论；</p><p>（3）热帖推送：用户可以喜欢帖子，系统根据帖子的喜欢数量和浏览量进行推送；</p><p>（4）发布新帖：用户登录后可以发布帖子； </p><p>（5）贴子管理：管理员可审核、置顶、删除帖子。</p><h3 id="3-1-6-职位招聘"><a href="#3-1-6-职位招聘" class="headerlink" title="3.1.6 职位招聘"></a>3.1.6 职位招聘</h3><p>（1）招聘广场：浏览招聘信息，根据公司名称、职位名称、工作地点检索并查看招聘信息；</p><p>（2）简历投送：用户可以向喜欢的招聘信息投送个人简历；</p><p>（3）简历管理：用户可以新增简历、编辑简历、删除简历；</p><p>（4）单位管理：用户可以登记、编辑自己所在单位的信息；</p><p>（5）发布招聘：用户登记单位信息后可以发布招聘信息，由管理员审核后推送到招聘广场。</p><h3 id="3-1-7-校园服务"><a href="#3-1-7-校园服务" class="headerlink" title="3.1.7 校园服务"></a>3.1.7 校园服务</h3><p>（1）校内服务：包括走进校园、校园行指南、学报编辑部、图书馆、档案馆、信息公开网等信息；</p><p>（2）招生就业服务：包括本科招生、成教招生、就业网、人才招聘、本站招聘等信息。</p><h3 id="3-1-8-个人中心"><a href="#3-1-8-个人中心" class="headerlink" title="3.1.8 个人中心"></a>3.1.8 个人中心</h3><p>（1）个人资料：基本资料、 详细资料、 工作信息、 头像设置；</p><p>（2）账户设置：密码修改、邮箱绑定； </p><p>（3）我的班级：用户加入的班级相关信息；</p><p>（4）我的论坛：用户早论坛的相关信息；</p><p>（5）我的招聘：用户发布的招聘信息，用户投递的简历信息，用户个人简历管理。</p><p>3.2 系统功能设计</p><p>3.2.1 新闻中心</p><p>新闻发布，后台管理发布图文信息到门户网站，可置顶、编辑、删除新闻信息；新闻评论，用户可以对新闻信息发表评论，回复评论，动态加载评论；新闻热度，用户喜欢可以新闻信息，系统根据信息的喜欢量、浏览流量推送新闻信息。新闻中心功能如图3-1所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image018.jpg" alt="img"></p><p>图3-1 新闻中心功能图</p><p>3.2.2 班记录</p><p>班级录功能包括:班级检索，按入学年份查询，按照班级名称、校友姓名查询，综合检索班级；班级排名，根据班级人数、活跃时间对班级进行热度排名；班级主页，每个班级有自己的空间，包括班级主页、班级动态、班级留言、班级成员、班级通讯录、班级相册、班级事务管理等；班级管理，班级的新增、管理员的设置由后台管理员完成。班级录功能如图3-2所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image020.jpg" alt="img"></p><p>图3-2 班记录功能图</p><h3 id="3-2-3-校友组织"><a href="#3-2-3-校友组织" class="headerlink" title="3.2.3 校友组织"></a>3.2.3 校友组织</h3><p>校友组织包括：校友总会，院校总会；院系分会，各学院的校友组织；社团分会，院校内的各种社团、协会的组织；学生协会，院校内的各学生协会组织；组织主页，个组织有自己的空间，包括组织主页、动态消息、留言、成员列表、通讯录、相册、活动、组织事务管理。校友组织功能如图3-3所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image021.png" alt="img"></p><p>图3-3 校友组织功能功能图</p><p>3.2.4 校友论坛</p><p>校友论坛：帖子浏览，按作者、主题检索帖子，查看详情，对帖子发表评论，回复评论、删除用户自己的评论，ajax动态加载评论；热帖推送，用户可以喜欢帖子，系统根据帖子的喜欢数量和浏览量进行推送；发布新帖，用户登录后可以发布帖子；贴子管理，管理员可审核、置顶、删除帖子。校友论坛功能如图3-4所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image023.jpg" alt="img"></p><p>图3-4 校友论坛功能图</p><h3 id="3-2-5-职业招聘"><a href="#3-2-5-职业招聘" class="headerlink" title="3.2.5 职业招聘"></a>3.2.5 职业招聘</h3><p>职位招聘：招聘广场。浏览招聘信息，根据公司名称、职位名称、工作地点检索并查看招聘信息；简历投送，用户可以向喜欢的招聘信息投送个人简历；简历管理，用户可以新增简历、编辑简历、删除简历；单位管理，用户可以登记、编辑自己所在单位的信息；发布招聘，用户登记单位信息后可以发布招聘信息，由管理员审核后推送到招聘广场。职业招聘功能如图3-5所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image025.jpg" alt="img"></p><p>图3-5 职业招聘功能图</p><h3 id="3-2-6-校园服务"><a href="#3-2-6-校园服务" class="headerlink" title="3.2.6 校园服务"></a>3.2.6 校园服务</h3><p>校园服务包括：校内服务，包括走进校园、校园行指南、学报编辑部、图书馆、档案馆、信息公开网等信息；招生就业服务，包括本科招生、成教招生、就业网、人才招聘、本站招聘等信息。校园服务功能如图3-6所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image027.jpg" alt="img"></p><p>图3-6 校园服务功能图</p><h3 id="3-2-7-个人中心"><a href="#3-2-7-个人中心" class="headerlink" title="3.2.7 个人中心"></a>3.2.7 个人中心</h3><p>个人中心：个人资料，基本资料、 详细资料、 工作信息、 头像设置；账户设置，密码修改、邮箱绑定；我的班级，用户加入的班级相关信息；我的论坛，用户在论坛的相关信息；我的招聘，用户发布的招聘信息，用户投递的简历信息，用户个人简历管理。个人中心功能如图3-7所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image029.jpg" alt="img"></p><p>图3-7 个人中心功能图</p><p>3.3 数据库设计</p><p>3.3.1 概念模型设计</p><p>根据系统总体设计和功能设计，设计出系统涉及到的实体信息，包括用户实体，个人信息实体，职业信息实体，简历实体，地址实体，留言实体，评论回复实体，年级实体，组织实体，活动实体，相册实体，图片实体，信息实体，评论实体，分享实体，收藏实体，订阅实体，招聘信息实体，招聘单位实体，附件实体，角色实体，权限实体，字典实体，字典数据实体，各实体信息的概念模型如下所示。</p><p>（1）用户实体模型如图3-8所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image031.jpg" alt="img"></p><p>图3-8 用户实体模型</p><p>（2）职业信息实体模型如图3-9所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image033.jpg" alt="img"></p><p>图3-9 职业信息实体模型</p><p>（3）简历实体模型如图3-10所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image035.jpg" alt="img"></p><p>图3-10 简历实体模型</p><p>（4）地址实体模型如图3-11所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image037.jpg" alt="img"></p><p>图3-11 地址实体模型</p><p>（5）留言实体模型如图3-12所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image039.jpg" alt="img"></p><p>图3-12  留言实体模型</p><p>（6）评论回复实体模型如图3-13所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image041.jpg" alt="img"></p><p>图3-13  回复实体模型</p><p>（7）年级实体模型如图3-14所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image043.jpg" alt="img"></p><p>图3-14 年级实体</p><p>（8）组织实体模型如图3-15所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image045.jpg" alt="img"></p><p>图3-15  组织实体模型</p><p>（9）相册实体模型如图3-16所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image047.jpg" alt="img"></p><p>图3-16 相册实体模型</p><p>（10）活动实体模型如图3-17所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image049.jpg" alt="img"></p><p>图3-17 活动实体模型</p><p>（11）字典数据实体模型如图3-18所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image051.jpg" alt="img"></p><p>图3-18 字典数据实体模型</p><p>（12）图片实体模型如图3-19所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image053.jpg" alt="img"></p><p>图3-19 图片实体模型</p><p>（13）信息实体模型如图3-20所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image055.jpg" alt="img"></p><p>图3-20 信息实体模型</p><p>（14）评论实体模型如图3-21所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image057.jpg" alt="img"></p><p>图3-21 评论实体模型</p><p>（15）分享实体模型如图3-22所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image059.jpg" alt="img"></p><p>图3-22 分享实体模型</p><p>（16）收藏实体模型如图3-23所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image061.jpg" alt="img"></p><p>图3-23 收藏实体模型</p><p>（17）订阅实体模型如图3-24所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image063.jpg" alt="img"></p><p>图3-24 订阅实体模型</p><p>（18）招聘信息实体模型如图3-25所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image065.jpg" alt="img"></p><p>图3-25 招聘实体模型</p><p>（19）招聘单位实体模型如图3-26所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image067.jpg" alt="img"></p><p>图3-26 招聘单位实体模型</p><p>（20）附件实体模型如图3-27所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image069.jpg" alt="img"></p><p>图3-27 附件实体模型</p><p>（21）角色实体模型如图3-28所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image071.jpg" alt="img"></p><p>图3-28  角色实体模型</p><p>（22）权限实体模型如图3-29所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image073.jpg" alt="img"></p><p>图3-29  权限实体模型</p><p>（23）字典实体模型如图3-30所示</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image075.jpg" alt="img"></p><p>图3-30 字典表模型</p><p>（24）简历投递实体模型如图3-31所示</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image077.jpg" alt="img"></p><p>图3-31 简历投递模型</p><p>3.3.2 逻辑结构设计</p><p>根据系统的概念模型设计，设计出适应大多数数据库的数据表逻辑结构，共设计31张表，如表3-1所示。</p><p>表3-1 数据表汇总</p><table><thead><tr><th>序号</th><th>名称</th><th>用途与约束</th></tr></thead><tbody><tr><td>1</td><td>user</td><td>用户表</td></tr><tr><td>2</td><td>user_info</td><td>用户个人信息表</td></tr><tr><td>3</td><td>user_job</td><td>用户工作信息表</td></tr><tr><td>4</td><td>user_resume</td><td>用户个人简历</td></tr><tr><td>5</td><td>resume_post</td><td>简历投递信息</td></tr><tr><td>6</td><td>user_origin</td><td>用户加入组织信息表</td></tr><tr><td>7</td><td>user_role</td><td>用户角色设定表</td></tr><tr><td>8</td><td>role</td><td>角色表</td></tr></tbody></table><p>续表3-1</p><table><thead><tr><th>序号</th><th>名称</th><th>用途与约束</th></tr></thead><tbody><tr><td>9</td><td>role_right</td><td>角色权限分配表</td></tr><tr><td>10</td><td>right</td><td>权限表</td></tr><tr><td>11</td><td>Address</td><td>地址信息表</td></tr><tr><td>12</td><td>message</td><td>消息表</td></tr><tr><td>13</td><td>reply</td><td>回复表</td></tr><tr><td>14</td><td>grade</td><td>年级表</td></tr><tr><td>15</td><td>origin</td><td>组织表</td></tr><tr><td>16</td><td>activity</td><td>活动表</td></tr><tr><td>17</td><td>album</td><td>相册信息表</td></tr><tr><td>18</td><td>album_image</td><td>相册图片信息表</td></tr><tr><td>19</td><td>image</td><td>图片信息表</td></tr><tr><td>20</td><td>information</td><td>信息表</td></tr><tr><td>21</td><td>comment</td><td>评论表</td></tr><tr><td>22</td><td>share</td><td>信息分享表</td></tr><tr><td>23</td><td>collect</td><td>信息收藏表</td></tr><tr><td>24</td><td>subscription</td><td>信息订阅表</td></tr><tr><td>25</td><td>recruit</td><td>招聘信息表</td></tr><tr><td>26</td><td>recruit_unit</td><td>招聘单位信息表</td></tr><tr><td>27</td><td>attachment</td><td>附件信息表</td></tr><tr><td>28</td><td>attachment_info</td><td>信息附件关系表</td></tr><tr><td>29</td><td>dictionary</td><td>数据字典表</td></tr><tr><td>30</td><td>dictionary_data</td><td>数据字典数据表</td></tr><tr><td>31</td><td>log</td><td>日志表</td></tr></tbody></table><p>表3-2 用户表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>account</td><td>char(20)</td><td>用户名</td><td></td></tr><tr><td>is_admin</td><td>char(1)</td><td>管理员标识</td><td></td></tr><tr><td>email</td><td>varchar(20)</td><td>用户邮箱</td><td></td></tr><tr><td>password</td><td>char(32)</td><td>用户密码</td><td></td></tr><tr><td>head_image_id</td><td>int(8)</td><td>头像图片标识</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>用户注册时间</td></tr></tbody></table><p>续表3-2</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>state</td><td>char(5)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-3 用户个人信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>user_info_id</td><td>int(8)</td><td>主键</td><td>自动增长</td></tr><tr><td>ture_name</td><td>Nvarchar(20)</td><td>用户名</td><td></td></tr><tr><td>age</td><td>char(5)</td><td>年龄</td><td></td></tr><tr><td>sex</td><td>char(5)</td><td>性别</td><td></td></tr><tr><td>birthday</td><td>datetime</td><td>生日</td><td></td></tr><tr><td>introduce</td><td>varchar(200)</td><td>个人简介</td><td></td></tr><tr><td>phone</td><td>varchar(20)</td><td>联系电话</td><td></td></tr><tr><td>email</td><td>varchar(50)</td><td>邮箱</td><td></td></tr><tr><td>qq</td><td>varchar(20)</td><td>QQ</td><td></td></tr><tr><td>microblog</td><td>varchar(50)</td><td>微博</td><td></td></tr><tr><td>wechat</td><td>varchar(20)</td><td>微信</td><td></td></tr><tr><td>address</td><td>Nvarchar(50)</td><td>住址</td><td></td></tr><tr><td>user_id</td><td>int</td><td>用户id</td><td>外键</td></tr><tr><td>state</td><td>char(2)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态时间</td></tr></tbody></table><p>表3-4 职业信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>job_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>job_name</td><td>Varchar(20)</td><td>职业名称</td><td></td></tr><tr><td>job_unit</td><td>Varchar(20)</td><td>就业单位</td><td></td></tr><tr><td>date_start</td><td>date</td><td>就职时间</td><td></td></tr><tr><td>date_end</td><td>date</td><td>离职时间</td><td></td></tr><tr><td>job_desc</td><td>varhar(200)</td><td>职业简述</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>工作登记时间</td><td></td></tr><tr><td>user_id</td><td>int</td><td>就业者</td><td>外键</td></tr><tr><td>state</td><td>char(1)</td><td>此条记录的状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>记录状态</td></tr></tbody></table><p>表3-5 个人简历表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>resume_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>resume_title</td><td>varchar(20)</td><td>简历标题</td><td></td></tr><tr><td>prof_type</td><td>vatchar(20)</td><td>职业类别</td><td></td></tr><tr><td>exp_salary</td><td>varchar(10)</td><td>期望薪资</td><td></td></tr><tr><td>name</td><td>varchar(10)</td><td>姓名</td><td></td></tr><tr><td>sex</td><td>char(1)</td><td>性别</td><td></td></tr><tr><td>domicile</td><td>varchar(20)</td><td>现在居住地</td><td></td></tr><tr><td>contact</td><td>varchar(30)</td><td>联系方式</td><td></td></tr><tr><td>introduce</td><td>varchar(200)</td><td>个人简介</td><td></td></tr><tr><td>userId</td><td>int</td><td>用户id</td><td>外键</td></tr><tr><td>statusValue</td><td>char(5)</td><td>状态值</td><td>a     x       t</td></tr></tbody></table><p>表3-6 简历投递表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>recruit_id</td><td>int</td><td>招聘信息id</td><td>外键</td></tr><tr><td>resume_id</td><td>int</td><td>简历id</td><td>外键</td></tr><tr><td>create_time</td><td>datetime</td><td>投递日期</td><td></td></tr><tr><td>state</td><td>char(2)</td><td>投递状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-7 角色权限配置表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>user_id</td><td>int</td><td>用户id</td><td>外键</td></tr><tr><td>role_id</td><td>int</td><td>角色id</td><td>外键</td></tr></tbody></table><p>表3-8 权限信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>role_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>role_name</td><td>varchar(20)</td><td>角色名称</td><td></td></tr><tr><td>role_value</td><td>varchar(20)</td><td>角色类型</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>创建时间</td><td></td></tr><tr><td>state</td><td>char(2)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-9 角色权限表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>role_id</td><td>int</td><td>角色id</td><td>自动增长</td></tr><tr><td>right_id</td><td>int</td><td>权限id</td></tr></tbody></table><p>表3-10 权限信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>right_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>right_name</td><td>varchar(20)</td><td>权限名称</td><td></td></tr><tr><td>right_pos</td><td>int</td><td>权限位</td><td></td></tr><tr><td>right_code</td><td>bigint</td><td>权限码</td><td></td></tr><tr><td>right_URL</td><td>varchar(50)</td><td>权限路径</td><td></td></tr><tr><td>is_public</td><td>char</td><td>是否是公共资源</td><td></td></tr><tr><td>state</td><td>char(2)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-11 地址表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>addr_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>province</td><td>varchar(10)</td><td>省份</td><td></td></tr><tr><td>city</td><td>varchar(10)</td><td>市</td><td></td></tr><tr><td>district</td><td>varchar(10)</td><td>区</td><td></td></tr><tr><td>detail</td><td>varchar(50)</td><td>详细地址</td><td></td></tr><tr><td>zip_code</td><td>char(6)</td><td>邮编</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>创建日期</td><td></td></tr><tr><td>state</td><td>char(2)</td><td>状态值</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-12 留言表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>msg_id</td><td>int(11)</td><td>主键</td><td>自动增长</td></tr><tr><td>title</td><td>varchar(20)</td><td>标题</td><td></td></tr><tr><td>content</td><td>varchar(500)</td><td>留言内容</td><td></td></tr><tr><td>sender_id</td><td>int(8)</td><td>发送者id</td><td></td></tr><tr><td>receiver_id</td><td>int(8)</td><td>接收者id</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>发表日期</td></tr></tbody></table><p>表3-13 留言回复表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>reId</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>content</td><td>varchar(500)</td><td>回复内容</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>回复时间</td><td></td></tr><tr><td>msg_id</td><td>int(11)</td><td>被回复的留言的id</td><td>外键</td></tr><tr><td>user_id</td><td>int</td><td>回复人id</td><td>外键</td></tr></tbody></table><p>表3-14 年级表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>grade_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>grade_value</td><td>char(4)</td><td>年份</td><td></td></tr><tr><td>class_num</td><td>int(4)</td><td>班级数</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>创建日期</td><td></td></tr><tr><td>state</td><td>char(2)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-15 组织信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>origin_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>origin_name</td><td>varchar(20)</td><td>组织编号</td><td></td></tr><tr><td>origin_no</td><td>varchar(20)</td><td>组织名</td><td></td></tr><tr><td>origin_type</td><td>varchar(20)</td><td>组织类型</td><td></td></tr><tr><td>origin_desc</td><td>varchar(500)</td><td>组织简介</td><td></td></tr><tr><td>origin_grade</td><td>varchar(4)</td><td>组织年级</td><td></td></tr><tr><td>members</td><td>int(4)</td><td>组织人员数量</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>组织成立的年份</td><td></td></tr><tr><td>mgr_id</td><td>int</td><td>组织的管理员id</td><td>外键</td></tr><tr><td>creator_id</td><td>int</td><td>组织创建人</td><td>外键</td></tr><tr><td>state</td><td>char(2)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-16 校友活动表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>act_id</td><td>int(8)</td><td>主键</td><td>自动增长</td></tr><tr><td>act_name</td><td>varchar(20)</td><td>活动名称</td></tr></tbody></table><p>续表3-16</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>start_time</td><td>datetime</td><td>活动开始时间</td><td></td></tr><tr><td>end_time</td><td>datetime</td><td>活动结束时间</td><td></td></tr><tr><td>act_place</td><td>varchar(50)</td><td>活动地点</td><td></td></tr><tr><td>act_desc</td><td>text</td><td>活动描述</td><td></td></tr><tr><td>act_num</td><td>int(4)</td><td>活动人数</td><td></td></tr><tr><td>sign_num</td><td>int(4)</td><td>活动已报名人数</td><td></td></tr><tr><td>interests</td><td>int(4)</td><td>感兴趣数</td><td></td></tr><tr><td>leader_name</td><td>varchar(10)</td><td>负责人姓名</td><td></td></tr><tr><td>leader_phone</td><td>varchar(30)</td><td>负责人联系方式</td><td></td></tr><tr><td>origin_id</td><td>int(8)</td><td>活动所属组织</td><td>外键</td></tr><tr><td>user_id</td><td>int(8)</td><td>活动发起人</td><td>外键</td></tr><tr><td>state</td><td>char(2)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-17 相册表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>album_id</td><td>int(8)</td><td>主键</td><td>自动增长</td></tr><tr><td>album_name</td><td>varchar(20)</td><td>相册名名</td><td></td></tr><tr><td>albm_desc</td><td>varchar(200)</td><td>相册描述</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>创建时间</td><td></td></tr><tr><td>interests</td><td>int(4)</td><td>感兴趣的人数</td><td></td></tr><tr><td>cover_image</td><td>int(11)</td><td>相册封面标识</td><td></td></tr><tr><td>origin_id</td><td>int</td><td>相册所属组织</td><td>外键</td></tr><tr><td>user_id</td><td>int</td><td>相册创建人</td><td>外键</td></tr><tr><td>state</td><td>char(2)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>创建时间</td></tr></tbody></table><p>表3-18 相册图片表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>album_id</td><td>int</td><td>相册id</td><td>外键</td></tr><tr><td>image_id</td><td>int</td><td>图片id</td><td>外键</td></tr><tr><td>create_time</td><td>datetime</td><td>创建时间</td></tr></tbody></table><p>表3-19 图片信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>image_id</td><td>int(11)</td><td>主键</td><td>自动增长</td></tr><tr><td>image_name</td><td>varchar(32)</td><td>图片名</td><td></td></tr><tr><td>is_remote</td><td>char(1)</td><td>远程文件</td><td></td></tr><tr><td>image_size</td><td>varchar(5)</td><td>图片大小</td><td></td></tr><tr><td>image_path</td><td>varchar(255)</td><td>图片路径</td><td></td></tr><tr><td>image_type</td><td>varchar(20)</td><td>图片类型</td><td></td></tr><tr><td>is_thumb</td><td>char(1)</td><td>缩略图标识</td><td></td></tr><tr><td>thumb_path</td><td>varchar(255)</td><td>缩略图路径</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>上传日期</td><td></td></tr><tr><td>state</td><td>char(2)</td><td>图片状态</td></tr></tbody></table><p>表3-20 信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>info_id</td><td>int(11)</td><td>主键</td><td>自动增长</td></tr><tr><td>info_title</td><td>varchar(50)</td><td>信息标题</td><td></td></tr><tr><td>content</td><td>text</td><td>内容</td><td></td></tr><tr><td>theme</td><td>varchar(2)</td><td>主题</td><td></td></tr><tr><td>thumb_image</td><td>varchar(255)</td><td>图文信息缩略图</td><td></td></tr><tr><td>views</td><td>int(4)</td><td>浏览量</td><td></td></tr><tr><td>comments</td><td>int(4)</td><td>评论数</td><td></td></tr><tr><td>shares</td><td>int(4)</td><td>分享次数</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>创建日期</td><td></td></tr><tr><td>is_top</td><td>char(1)</td><td>置顶标识</td><td></td></tr><tr><td>info_type</td><td>varchar(20)</td><td>信息类型</td><td></td></tr><tr><td>user_id</td><td>int(8)</td><td>用户id</td><td></td></tr><tr><td>origin_id</td><td>int(8)</td><td>信息所属组织id</td><td></td></tr><tr><td>state</td><td>char(2)</td><td>状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-21 评论表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>comment_id</td><td>int(11)</td><td>主键</td><td>自动增长</td></tr><tr><td>content</td><td>varchar(500)</td><td>评论内容</td></tr></tbody></table><p>续表3-21</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>create_time</td><td>datetime</td><td>评论日期</td><td></td></tr><tr><td>user_id</td><td>int</td><td>评论人</td><td>外键</td></tr><tr><td>info_id</td><td>int</td><td>评论的信息id</td><td>外键</td></tr></tbody></table><p>表3-22 信息转发表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>create_time</td><td>datetime</td><td>转发时间</td><td></td></tr><tr><td>info_id</td><td>int(11)</td><td>被转发的信息id</td><td>外键</td></tr><tr><td>user_id</td><td>int(8)</td><td>转发人id</td><td>外键</td></tr><tr><td>where</td><td>varchar(20)</td><td>转发方式</td></tr></tbody></table><p>表3-23 收藏表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>collect_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>create_time</td><td>datetime</td><td>收藏时间</td><td></td></tr><tr><td>info_id</td><td>int</td><td>收藏信息的id</td><td>外键</td></tr><tr><td>user_id</td><td>int</td><td>收藏人</td><td>外键</td></tr><tr><td>state</td><td>char(2)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-24 信息订阅表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>sub_id</td><td>int(11)</td><td>主键</td><td>自动增长</td></tr><tr><td>create_time</td><td>datetime</td><td>订阅时间</td><td></td></tr><tr><td>info_type</td><td>varchar(20)</td><td>订阅信息类型</td><td></td></tr><tr><td>is_email</td><td>char(1)</td><td>邮箱订阅标识</td><td></td></tr><tr><td>user_id</td><td>int(8)</td><td>用户id</td><td></td></tr><tr><td>state</td><td>char(2)</td><td>状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-25 招聘信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>recruitId</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>title</td><td>varchar(20)</td><td>招聘标题</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>创建时间</td></tr></tbody></table><p>续表3-25</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>end_time</td><td>datetime</td><td>招聘结束时间</td><td></td></tr><tr><td>members</td><td>int(4)</td><td>招聘人数</td><td></td></tr><tr><td>resumes</td><td>int(4)</td><td>简历投送数</td><td></td></tr><tr><td>leader_name</td><td>varchar(20)</td><td>联系人</td><td></td></tr><tr><td>leader_phone</td><td>varchar(30)</td><td>联系方式</td><td></td></tr><tr><td>is_top</td><td>char(1)</td><td>置顶标识</td><td></td></tr><tr><td>pos_name</td><td>varchar(20)</td><td>职位名称</td><td></td></tr><tr><td>pos_desc</td><td>varchar(500)</td><td>职位描述</td><td></td></tr><tr><td>benefit</td><td>varchar(50)</td><td>职位福利</td><td></td></tr><tr><td>work_place</td><td>varchar(50)</td><td>工作地点</td><td></td></tr><tr><td>unit_id</td><td>int(8)</td><td>招聘单位id</td><td></td></tr><tr><td>user_id</td><td>int</td><td>发布人id</td><td>外键</td></tr><tr><td>state</td><td>char(1)</td><td>状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-26 招聘单位信息表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>unit_id</td><td>int(8)</td><td>主键</td><td>自动增长</td></tr><tr><td>unit_name</td><td>varchar(30)</td><td>招聘单位名称</td><td></td></tr><tr><td>industry</td><td>varchar(30)</td><td>单位所属行业</td><td></td></tr><tr><td>property</td><td>varchar(20)</td><td>单位性质</td><td></td></tr><tr><td>scale</td><td>varchar(20)</td><td>单位规模</td><td></td></tr><tr><td>unit_desc</td><td>text</td><td>单位简介</td><td></td></tr><tr><td>unit_web</td><td>varchar(30)</td><td>单位网站</td><td></td></tr><tr><td>user_id</td><td>int(8)</td><td>发布者id</td><td>外键</td></tr><tr><td>state</td><td>char(1)</td><td>此条记录状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态日期</td></tr></tbody></table><p>表3-27 附件表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>atta_id</td><td>int</td><td>主键</td><td>自动增长</td></tr><tr><td>atta_name</td><td>varchar(32)</td><td>附件文件名</td><td></td></tr><tr><td>atta_type</td><td>varchar(20)</td><td>附件类型</td></tr></tbody></table><p>续表3-27</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>is_romote</td><td>char(1)</td><td>远程文件标识</td><td></td></tr><tr><td>file_path</td><td>varchar(255)</td><td>文件路径</td><td></td></tr><tr><td>file_size</td><td>char(10)</td><td>文件大小</td><td></td></tr><tr><td>dowmloads</td><td>int(4)</td><td>文件下载次数</td><td></td></tr><tr><td>create_time</td><td>datetime</td><td>上传日期</td></tr></tbody></table><p>表3-28 信息附件表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>attachment_id</td><td>int</td><td>附件id</td><td>外键</td></tr><tr><td>info_id</td><td>int</td><td>信息id</td><td>外键</td></tr></tbody></table><p>表3-29 数据字典表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>dict_value</td><td>varchar(20)</td><td>字典值</td><td>主键</td></tr><tr><td>dict_name</td><td>varchar(50)</td><td>字典名</td><td></td></tr><tr><td>remark</td><td>varchar(200)</td><td>字典备注</td></tr></tbody></table><p>表3-30 数据字典数据表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int(8)</td><td>数据id</td><td>主键</td></tr><tr><td>dict_value</td><td>varchar(20)</td><td>数据字典</td><td>外键</td></tr><tr><td>dictdata_name</td><td>varchar(50)</td><td>数据名</td><td></td></tr><tr><td>dictdata_value</td><td>varchar(20)</td><td>数据值</td><td></td></tr><tr><td>is_fixed</td><td>char(1)</td><td>固定标识</td><td></td></tr><tr><td>is_cancel</td><td>char(1)</td><td>数据取消标识</td><td></td></tr><tr><td>parent_id</td><td>int(8)</td><td>父节点</td></tr></tbody></table><p>表3-31 日志表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>log_id</td><td>int(11)</td><td>日志id</td><td>主键</td></tr><tr><td>operator</td><td>varchar(100)</td><td>操作员</td><td></td></tr><tr><td>oper_name</td><td>varchar(100)</td><td>操作名称</td><td></td></tr><tr><td>oper_params</td><td>varchar(255)</td><td>操作参数</td><td></td></tr><tr><td>oper_result</td><td>varchar(100)</td><td>操作结果</td><td></td></tr><tr><td>oper_time</td><td>datetime</td><td>操作时间</td></tr></tbody></table><p>表3-32 用户组织表</p><table><thead><tr><th>字段名称</th><th>字段类型（长度）</th><th>字段含义</th><th>备注</th></tr></thead><tbody><tr><td>user_id</td><td>int</td><td>用户id</td><td>外键</td></tr><tr><td>origin_id</td><td>int</td><td>组织id</td><td>外键</td></tr><tr><td>create_time</td><td>datetime</td><td>加入时间</td><td></td></tr><tr><td>state</td><td>varchar(2)</td><td>状态</td><td></td></tr><tr><td>state_time</td><td>datetime</td><td>状态时间</td></tr></tbody></table><p>4 系统详细设计</p><p>4.1 班级录</p><p>（1） 功能实现</p><p>班级录主要实现给用户提供班级空间的功能，班级录总览界面按年级信息统计并展示院校当前班级的信息，按年级、校友姓名、班级专业条件查询班级并且能够在侧边栏按班级人数对班级进行热度排名，展示当前用户加入的班级，最近加入班级录的校友等信息。</p><p>（2） 实现方法</p><p>点击班级录标签页，请求class.action访问到Class控制器中的index()方法，index()调用ClassService业务逻辑类中的getAll()，查询年级信息，返回List<grade>类型的数据，添加到视图模型model中。Grade类对象中包含年级、班级个数等信息，index()方法跳转到class-index.jsp页面，展示年纪列表信息，并将年级列表加载到条件查询框中的下拉框中。页面加载时引入javascript，使用$.post()方法请求侧边栏数据。侧边栏数据包括班级录信息统计、班级排名、当前用户加入的班级、最近加入的校友等信息。在条件查询框中选择年级、填入校友姓名或专业关键字可以查询相关班级，提交查询时请求Class控制器中的queryClass()方法，传递grade、queryStr参数。queryClass()调用ClassService()业务逻辑类中的queryClasses()方法,queryClasses()方法的参数为Page&lt;&gt;类型的对象、grade、queryStr，queryClasses()执行查询,并返回 List<map<string,object>&gt;类型的数据。类型为Page&lt;&gt;的参数是分页对象，分页对象中包含分页的所有信息，包括页码pageIndex、pageSize、beanList等，新建分页对象时，如果没有设置参数，则pageIndex默认为1，pageSize默认为10。将page对象加入到视图模型model中，queryClass()返回class-query.jsp页面。jsp页面将班级信息列表展示出来，并追加页码执行翻页功能。</map<string,object></grade></p><p>（3） 界面设计</p><p>班级录总览界面如图4-1所示，总体分为导航栏、年级列表和侧边信息栏。班级查询界面如图4-2所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image002.jpg" alt="img"></p><p>图4-1 班级录总览界面</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image004.jpg" alt="img"></p><p>图4-2 班级查询界面</p><p>4.1.1 班级首页</p><p>（1）功能实现</p><p>班级主页主要对班级进行一些简介，并展示班级的一些近期信息，如班级简介、班级最新动态、班级最新照片、班级管理员信息、当前用户信息以及当前用户是否加入班级等。班级简介为班级实体中描述班级的字段，包括班级名称、班级人数、班级简介、班级所属年级。班级最新动态是班级动态按照日期降序排列后，选择最新的几条记录显示。班级最新照片是班级成员上传到班级相册照片，按照上传日期降序排列后选择最新的几张进行展示。班级管理员信息展示管理员的头像、姓名、简介等信息。当前用户信息展示当前用户的头像、姓名、简介、是否加入班级。</p><p>（2）实现方法</p><p>点击班级名称超链接，请求classroom.action，并传入班级id参数，Classroom控制器中index()方法接收参数,调用业务逻辑类ClassService中的classIndex()、classInfo()、classImage()、getAllMemberId()方法。clasIndex()方法查询班级的详细信息，返回Map<string, object>类型的数据，赋值给classroom，将返回数据classroom添加到视图模型model中。classInfo()查询班级的动态消息，动态消息按照日期降序排列，以List<map<string, object>&gt;类型返回日期最新的几条记录，赋值给infoList,将infoList添加到视图模型model中。classImage()方法查询班级成员上传的照片，照片按照上传日期降序排列，以List<map<string, object>&gt;类型返回上传日期最新的几条记录，赋值给imageList，将imageList添加到视图模型model中。getAllMemberId()查询所有班级成员的id，以List&lt; Integer&gt;类型返回，赋值给classIds，并将classIds添加到视图模型model中。Classroom控制器方法index()跳转到classroomdex.jsp页面，将classroom、infoList、imageList中的信息遍历展示在jsp页面中,将SESSION_USER环境变量中的当前用户信息展示为当前用户信息，并将SESSION_USER中的userId与classIds中的数据进行比较，如果userId存在与classIds中,则显示用户已经加入班级，否则显示加入班级按钮。Classroom-index.jsp加载的时候引入javascript，使用$.post()方法请求班级官员信息，并返回到jsp页面进行展示。</map<string,></map<string,></string,></p><p>（3）界面设计</p><p>班级主页界面设计如图4-3所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image006.jpg" alt="img"></p><p>图4-3 班级主页界面</p><p>4.1.2 班级动态</p><p>1.班级动态列表</p><p>（1） 功能实现</p><p>班级动态列表展示班级成员发布的动态信息，查询以当前班级id和信息类型作为条件查询信息，并进行分页处理，将查询到的信息分页展示。</p><p>（2） 实现方法</p><p>点击班级动态标签页，请求classroom/info.action，传递参数classId，Classroom控制器中的info()方法接收参数，info()调用ClassService业务逻辑类中的classIndex()、classInfo()方法。clasIndex()方法查询班级的详细信息，返回Map<string, object>类型的数据，赋值给classroom，将返回数据classroom添加到视图模型model中。classInfo()方法参数为Page&lt;&gt;类型数据、班级id和信息类型（数据字典中的信息类型数据），方法返回List<map<string, object>&gt;类型的数据。类型为Page&lt;&gt;的参数是分页对象，分页对象中包含分页的所有信息，包括页码pageIndex、pageSize、beanList等，新建分页对象时，如果没有设置参数，则pageIndex默认为1，pageSize默认为10。将page对象加入到视图模型model中，info()返回classroom-info.jsp页面。jsp页面将班级信息、班级动态信息列表展示出来，并追加页码执行翻页功能。</map<string,></string,></p><p>（3） 界面设计</p><p>班级动态列表界面如图4-4所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image008.jpg" alt="img"></p><p>图4-4 班级动态界面</p><p>2.班级动态详情</p><p>（1）功能实现</p><p>班级动态详情实现动态消息的详情展示，作者信息，消息评论区，以及班级相关动态和作者相关动态。班级动态消息详情包括图文信息、发布时间、浏览量、喜欢数、评论数，消息加载时动态消息的浏览量自增1。作者信息栏展示作者的头像、名字、简介等信息。评论区默认加载10条评论，点击加载更多评论按钮则再次加载10条评论，知道所有评论被加载完毕，用户可以在评论区发表评论。页面加载时，通过ajax方式将班级相关动态和作者相关动态加载到侧边栏。</p><p>（2）实现方法</p><p>点击消息详情按钮，请求classroom/infoDetail.action，传递班级id和消息id，Classroom控制器中的infoDetail()方法接收参数，调用ClassroomService业务类中的classInfoDetail()方法查询动态信息详情和作者信息，返回Map<string, object>类型的数据，赋值给info，将info添加到视图模型model中。infoDetail()返回classroom-info-detail.jsp页面，将info中的信息展示，并引入javascript使用ajax方式加载评论和侧边栏信息。</string,></p><p>（3）界面设计</p><p>班级动态信息详情界面和评论区界面如图4-5和图4-6所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image010.jpg" alt="img"></p><p>图4-5 班级动态详情界面</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image012.jpg" alt="img"></p><p>图4-6 班级动态消息评论区界面</p><p>4.1.3 班级通讯录</p><p>（1）功能实现</p><p>班级通讯录五章表关联查询班级成员的用户信息、所在地、电话、邮箱、QQ、微信等通讯信息，分页显示，并且支持下载班级通讯录信息，以Excel文件形式下载到本地。</p><p>（2）实现方法</p><p>点击通讯录标签页，请求classroom/directory.action，传递参数班级id，Classroom控制器中的directory()方法接收参数，并调用ClassrommService业务类中的classDirector()方法。classDirectory()关联user表、user_origin表、origin表、user_info表、image表，查询用户信息、用户通讯信息，以List<map<string, object>&gt;的形式返回通讯录列表，赋值给分页对象page中的beanList，并将page添加到视图模型model中。Directory()方法跳转classroom-directory.jsp页面，将beanList里的通讯录信息遍历出来。</map<string,></p><p>（3）界面设计</p><p>班级通讯录的界面设计如图4-7所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image014.jpg" alt="img"></p><p>图4-7 班级通讯录界面</p><p>4.1.4 班级相册</p><p>（1）功能实现</p><p>在班级相册中，班级成员可以查看相册、新建相册、上传图片、删除图片、设置相册封面、下载图片。上图图片支持批量上传，相册封面可以选择相册内的任意图片作为封面。</p><p>（2）实现方法</p><p>点击班级相册标签页，请求classroom/album.action，传递参数班级id，Classroom控制器中的album()方法接收参数，调用AlbumService业务类中的getAlbums()方法，以List<album>形式返回相册信息，赋值给分页对象page的beanList属性，返回classroom-album.jsp界面，将相册列表分页显示。</album></p><p>（3）界面设计</p><p>班级相册界面设计如图4-8所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image016.jpg" alt="img"></p><p>图4-8 班级相册界面</p><p>4.2 职业招聘</p><p>4.2.1 发布招聘</p><p>（1）功能实现</p><p>发布招聘时，系统判断当前用户是否已经登记公司信息，如果没有登记则跳转公司信息登记界面，否则跳转招聘登记界面。在招聘登记界面填写招聘信息后提交审核，后台管理员可以审核、置顶招聘。</p><p>（2）实现方法</p><p>点击发布招聘按钮，请求recruit/addRecruit.action，Recruit控制器中的addRecruit()方法接收请求，首先调用UnitService业务类中的getUnitsByUserId()方法查询当前用户的公司信息。如果公司信息，则返回redirect:/unit/addUnit.action，重定向到公司信息登记界面，否则addRecruit()将招聘常量positionSalary、positionBenefit、positionProf添加到视图模型model中，跳转至招聘信息登记界面。招聘信息表单填写完成后，提交至recruit/addRecruitSubmit.action，Recruit控制器调用RecruitService业务类中的createRecruit()方法，保存招聘信息，等待审核。</p><p>（3）界面设计</p><p>招聘单位信息登记界面设计如图4-9所示，招聘信息登记界面如图5-10所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image018.jpg" alt="img"></p><p>图4-9 招聘单位登记界面</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image020.jpg" alt="img"></p><p>图4-10 招聘信息登记界面</p><p>4.2.2 查询招聘</p><p>（1）功能实现</p><p>招聘查询可以招聘信息标题、招聘单位名称、职位信息、工作地点等查询招聘信息，并将查询到的记录分页显示。</p><p>（2）实现方法</p><p>点击职业招聘按钮，请求recruit.action，传递查询条件queryStr，Recruit控制器中的indexRecruit()方法，调用RecruitService业务类中的queryRecruit()方法执行查询，返回分页对象page，跳转到recruit-index.jsp页面，将招聘信息遍历出来并追加页码，执行翻页功能。</p><p>（3）界面设计</p><p>招聘查询界面如图4-11所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image022.jpg" alt="img"></p><p>图4-11 招聘查询界面</p><p>4.2.3 招聘详情</p><p>（1）功能实现</p><p>招聘详情展示招聘的详细信息，包括招聘单位信息、职位信息、联系人信息，并且能够加载此招聘信息的申请记录以及本招聘单位的相关招聘信息。</p><p>（2）实现方法</p><p>点击招聘信息标题超链接，请求recruit/detailRecruit.action，传递招聘信息id，Recruit控制器中的detailRecruit()方法接收参数，调用RecruitService业务类中的getDetailRecruit()、loadResumesToPost()、postResumeRecord()、loadOtherRecruits()等方法。getDetailRecruit()方法查询招聘的详细信息，返回Map<string,object>类型的数据，并添加到视图模型对象model中。postResumeRecord()方法关联recruit_post表、user表、image表查询出对此招聘信息投递简历的用户列表，返回List<map<string,object>&gt;类型的数据，并添加到视图模型对象中。LoadOtherRecruits()方法关联recruit_post表、recruit表，查询出此招聘单位的相关招聘信息，返回List<map<>&gt;类型的数据，并添加到数图模型对象model中。</map<></map<string,object></string,object></p><p>（3）界面设计</p><p>招聘查询界面如图4-12所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image024.jpg" alt="img"></p><p>图4-12 招聘查询界面</p><p>4.2.4 投递简历</p><p>（1）功能实现</p><p>在简历详情界面中，有简历投递选项，用户选择自己的简历投送至当前招聘信息。如果当前用户没有简历，则可以选择创建简历。</p><p>（2）实现方法</p><p>如果用户已经申请当前职位，则显示已申请职位，否则显示申请职位按钮。点击申请职位按钮，页面弹出简历投递模态框，通过c标签将用户简历列表加载到下拉框中，选择一个简历，点击确认申请按钮，请求my/resume/postResume.action，传递招聘信息id，用户简历id，用户信息控制器中的postResume()接收参数，并调用ResumeService服务类中的postResume()方法，保存简历投递信息。</p><p>（3）界面设计</p><p>简历投递界面如图4-13所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image026.jpg" alt="img"></p><p>图4-13 简历投递界面</p><p>4.3 校友论坛</p><p>4.3.1 论坛广场</p><p>（1）功能实现</p><p>论坛广场分页展示校友论坛的所有帖子，可以按照帖子标题、帖子主题和帖子作者进行模糊查询，并按照帖子的热度进行排名。</p><p>（2）实现方法</p><p>点击校友论坛，请求forum.action，Forum控制器中的index()方法接收请求，调用PostService中的queryPosts()方法，按日期降序排列并分页查询帖子，返回List<map<string,object>&gt;类型的数据，赋值给分页对象page，将page添加到视图模型对象model中。返回forum-index.jsp页面，将page中beanList的帖子信息分页显示。</map<string,object></p><p>（3）界面设计</p><p>论坛广场界面设计如图4-14所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image028.jpg" alt="img"></p><p>图4-14 校友论坛广场界面</p><p>4.3.2 发布新帖</p><p>（1）功能实现</p><p>用户可以在校友论坛广场发布新贴，帖子会被推送到广场并可以被搜索。</p><p>（2）实现方法</p><p>点击发布新贴按钮，请求post/add.action，Post控制器中的addPost()方法接收请求，将环境变量themeList添加到视图模型对象model中，加载帖子发布界面。在帖子发布界面填写post表单并提交，post信息存储至数据库，重新加载招聘广场即可看到新发布的帖子。</p><p>（3）界面设计</p><p>发布新贴界面如图4-15所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image030.jpg" alt="img"></p><p>图4-15 发布新贴界面</p><p>4.3.3 帖子详情</p><p>（1）功能实现</p><p>用户可以查看帖子详情，包括帖子内容、浏览量、评论量、喜欢数、作者信息，在帖子内容下方有评论区，加载评论内容或发表评论。在详情界面侧边栏显示相关主题的帖子和作者相关的帖子。</p><p>（2）实现方法</p><p>用户点击帖子标题超链接，请求post/detail.action，Post控制器中的detail()方法接收请求，调用PostService业务类中的postDetail()方法查询帖子详情，将返回的数据添加到视图模型对象model中，返回jsp页面显示帖子内容。页面加载完毕后，通过jquery的$.post()方法请求post/commentList.action和post/outLine.action加载评论区内容和侧边栏内容，Post控制器调用PostService业务类中的getOtherPost()f方法和CommentService业务类中的dynamicComment()方法查询信息，将返回的信息追加到页面，完成动态加载评论的功能。</p><p>（3）界面设计</p><p>帖子详情界面设计如图4-16所示。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\msohtmlclip1\01\clip_image032.jpg" alt="img"></p><p>图4-16 帖子详情界面</p><p>结论</p><p>经过持久层、数据访问层、业务逻辑层、系统控制层、视图层的设计和实现，本系统基本实现了对班级管理，用户可以加入自己所在的班级；对班级留言的管理，用户可以在班级里查看、添加或修改留言；对班级通讯录的管理，用户可以查看班级成员的相关信息。系统已经能够实现留言、上传照片、评论等功能，同时具有方便的后台管理功能。同学录系统能够实现同学们生活中的交流，拥有自己的空间。校友论坛为广大校友提供了更加宽阔的平台，促进校友们之间的交流。与此同时，通过职业招聘模块、校园服务模块，校方管理员能够了解毕业生的就业情况，并为毕业生提供就业服务，包括向毕业生投送招聘信息，接收毕业生所在单位的招聘信息。因此，此系统能够在促进高校专业教学改革、募集高校筹资办学途径、促进校企合作、加强毕业生感情交流、提升大学生就业质量等方面带来巨大效益。</p><p>当然，本系统还不够完善，有一部分功能尚未实现。新闻中心应该具备热文推送和邮箱订阅功能，这样才能让校友更好的了解母校的动态消息。  网站内的消息应该支持富文本格式，这样可以使消息更具可读性和吸引力，同时富文本编辑器可以让用户更方便地编写内容。在消息发布和图片上传时，图片经过剪辑之后才可以更好地展示和存储。由于个人能力的限制，网站的邮箱订阅功能、富文本编辑存储功能和图片剪辑功能并没有实现。这些功能对本系统也显得尤为重要，因此以后必须实现。</p><p>经过对校友录系统的设计和实现，我对MVC模式有了更深层次的理解和应用。同时，我也学会许多新的框架和工具，包括SpringMVC、MyBatis、EhCache、Bootstrap、AmazeUI等框架，Maven、Git、IntelliJ IDEA等工具。因此，我相信在以后面临的工作和项目中本系统对我有很大帮助。</p><p>致谢</p><p>本论文的编写和修改是在胡局新老师悉心指导下完成的。胡老师有着严谨有致的教学态度，兢兢业业的工作作风，诲人不倦的高尚师德。在胡老师的每一堂课上，我都能感受到他的格物致知、敬业乐群，这也正是我在专业知识学习中保持热情的关键所在。在临近毕业的这段时间，胡老师也依然百忙之中为我讲解技术、指导论文，其崇高的责任心将是我受益一生的宝贵财富。在此，谨向我可敬可爱的胡老师致以诚挚的谢意。</p><p>不知不觉，四年的大学生活如白驹过隙般逝去，但这宝贵的四年无疑会在而后的回忆里细水长流。在徐州工程学院四年时间里我有过喜悦，有过沮丧，也学习了很多专业知识，参加了很多活动和比赛，获得了飞思卡尔智能汽车竞赛国赛奖项，电子设计大赛省级奖项。没有志同道合的校友，没有对我谆谆教诲的辅导员，没有对我坚定支持的母校，我不可能取得这些成就，也很难在低谷时战胜困难。因此，我想对帮助我的校友，关爱我的辅导员，坚定支持我的母校致以崇高的谢意。</p><p>同时，我也要感谢生我育我的父母。我的家庭生活并非想象中那么美好，父母的艰辛也许我无法体会，但是即使再困难，父母都会给予我精神、物质上的支持。父母不曾亏待我，我又能拿什么面对父母。唯有不懈的努力，让自己成功的速度快于他们老去的速度，我才能回报他们对我的爱。对于父母所给予我的这一切，我会用生命去珍惜，用感恩去呵护。</p><p>最后，我想再一次向精心教导我的胡老师，关爱我的辅导员，志同道合的校友，给予我支持的父母表达我的感恩之情，没有你们就没有如今的我，谢谢你们伴我走过青春的这段旅途，谢谢！</p><p>参考文献</p><p>[1] 盛仲飙 乔道迹.基于Java的通讯软件设计与实现[J].福建电脑,2015</p><p>[2] 陈衍席.基于Java网络聊天系统的设计及实现研究[J].通讯世界,2016</p><p>[3] 钱雪忠著,数据库原理与应用（第二版）[M].北京邮电大学出版社,2007</p><p>[4] 唐汉明 翟振兴 关宝军.深入浅出MySQL数据库开发优化与管理维护第2版[M].人民邮电出版社,2014</p><p>[5] 吴海星.Java程序员修炼之道[M].人民邮电出版社,2013</p><p>[6] 缪忠剑.基于Spring的集成化Web开发平台的研究与实现[M].北京机械工业出版社,2013</p><p>[7] 宋佳颖,基于Java的邮件接收系统分析[J].无线互联科技,2015</p><p>[8] 耿祥义,张跃平著.Java设计模式[M].清华大学出版社,2009</p><p>[9] 彭晓青,MVC模式的应用架构系统的研究与实现[J].电子工业出版社,2013</p><p>[10] 赵争东,基于Java的数据库应用框架的研究设计和探索[J].信息系统工程,2015</p><p>[11] 软件开发技术联盟著,Java Web开发实战[M].清华大学出版社,2013</p><p>[12] 贾蓓.镇明敏.杜磊著,Java Web整合开发实战[M].清华大学出版社,2013</p><p>[13] 李运莉著,web数据库应用系统性能优化[M].北京人民邮电出版社,2011</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;校友录网站。作为毕业设计，为母校设计校友交流平台。基于javaWeb，由Maven构建管理，采用Spring+SpringMVC+MyBatis框架，用EhCache做数据缓存。门户网站采用BootStrap设计界面，后台管理网站用AmazeUI设计界面。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://blackist.org/categories/Spring/"/>
    
    
      <category term="开发" scheme="https://blackist.org/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="java" scheme="https://blackist.org/tags/java/"/>
    
      <category term="spring" scheme="https://blackist.org/tags/spring/"/>
    
      <category term="javaweb" scheme="https://blackist.org/tags/javaweb/"/>
    
      <category term="校友录" scheme="https://blackist.org/tags/%E6%A0%A1%E5%8F%8B%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>依赖注入</title>
    <link href="https://blackist.org/2019/06/13/java-java7-ioc/"/>
    <id>https://blackist.org/2019/06/13/java-java7-ioc/</id>
    <published>2019-06-13T12:07:19.000Z</published>
    <updated>2019-06-16T09:47:35.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>讲真的，今年就业形势相当不好，对IT从业者的专业能力要求将变得更高。近来一边忙学业，一边学习Java基础和框架源码，为不久之后的招聘做准备。</p><p>打算从Java7、Java8d的版本新特性着手，再深入JVM、并发编程等。Java7中发布了JSR-330标准的DI特性。IoC是控制反转，DI是依赖注入。依赖注入（控制反转的一种形式）是Java开发主流中一个重要的范式。</p><a id="more"></a><h2 id="一、理解IoC和DI"><a href="#一、理解IoC和DI" class="headerlink" title="一、理解IoC和DI"></a>一、理解IoC和DI</h2><p><a name="iGpK3"></a></p><h3 id="IoC-控制反转"><a href="#IoC-控制反转" class="headerlink" title="IoC(控制反转)"></a>IoC(控制反转)</h3><p>非IoC范式编程，“功能中心”控制程序逻辑的流程，调用各个可重用对象中的方法执行特定的功能。<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/204153/1560386178634-f13db507-ef0b-4eb5-be76-f61291a3e741.jpeg#align=left&amp;display=inline&amp;height=254&amp;originHeight=254&amp;originWidth=353&amp;size=0&amp;status=done&amp;width=353" alt><br>IoC程式编程，调用者的代码来处理程序的执行顺序，而程序逻辑则被封装在接受调用的子流程中。<br><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/204153/1560386191880-91750474-e215-4608-bf06-53e820c2a180.jpeg#align=left&amp;display=inline&amp;height=421&amp;originHeight=421&amp;originWidth=336&amp;size=0&amp;status=done&amp;width=336" alt></p><p>IoC也被称为<strong>好莱坞原则</strong>，其思想可以归结为会有另一端代码拥有最初的控制线程（容器/工厂），并且有它来调用你的代码（注入/实例化对象），而不是由你的代码调用它。</p><blockquote><p>好莱坞原则 – “不要给我们打电话，我们会打给你”<br>好莱坞经纪人总是给人打电话，而不是让别人打给他们！</p></blockquote><p>IoC—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：<br> <br>●<strong>谁控制谁，控制什么：</strong>传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。<br><br><br>●<strong>为何是反转，哪些方面反转了：</strong>有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？<strong>依赖对象的获取</strong>被反转了。</p><p><a name="FxilH"></a></p><h3 id="IoC应用"><a href="#IoC应用" class="headerlink" title="IoC应用"></a>IoC应用</h3><p><strong>降低代码间的耦合度</strong>，让代码<strong>更易于测试、更易读、内聚性更强</strong>。</p><p>IoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。<br>其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。<br>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。<br></p><p><a name="kSWEA"></a></p><h3 id="IoC实现方式"><a href="#IoC实现方式" class="headerlink" title="IoC实现方式"></a>IoC实现方式</h3><p>包括工厂模式，服务器定位模式，依赖注入(DI)。</p><p><a name="LQjDC"></a></p><h3 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI(依赖注入)"></a>DI(依赖注入)</h3><p>DI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。<br><br><br>DI是IoC的一种特定形态，是指<strong>寻找依赖项的过程（实例化）不在当前执行代码的直接控制之下</strong>。通常使用自带IoC容器的DI框架来实现依赖注入机制，如Guice，Spring。IoC可以看作运行时环境。<br><br><br>依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。<br> <br>理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：<br> <br>●<strong>谁依赖于谁：</strong>当然是应用程序依赖于IoC容器；<br>●<strong>为什么需要依赖：</strong>应用程序需要IoC容器来提供对象需要的外部资源；<br>●<strong>谁注入谁：</strong>很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；<br><br><br><strong>●注入了什么：</strong>就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。<br> <br>IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，<strong>“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</strong></p><p><a name="IB7px"></a></p><h2 id="二、DI实现实例"><a href="#二、DI实现实例" class="headerlink" title="二、DI实现实例"></a>二、DI实现实例</h2><blockquote><p>找出所有对Java开发人员比较友善的好莱坞经纪人</p></blockquote><p>有个AgentFinder接口，及其两个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentFinder</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;String&gt; <span class="title">getAllAgents</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevAgentFinder</span> <span class="keyword">extends</span> <span class="title">AgentFinder</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getAllAgents</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankAgentFinder</span> <span class="keyword">extends</span> <span class="title">AgentFinder</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getAllAgents</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在AgentFinderService中使用AgentFinder查找对Java开发人员友好的经纪人，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentFinderService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getGoodAgents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AgentFinder finder = <span class="keyword">new</span> DevAgentFinder();</span><br><span class="line">List&lt;String&gt; allAgents = finder.getAllAgents();</span><br><span class="line"><span class="keyword">return</span> filterAgents(allAgents);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">filterAgents</span><span class="params">(List&lt;String&gt; agents)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; fitAgents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String agent : agents) &#123;</span><br><span class="line"><span class="keyword">if</span> (agent.contains(<span class="string">"Java"</span>)) &#123;</span><br><span class="line">fitAgents.add(agent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fitAgents;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，AgentFinderService和DevAgentFinder紧密黏合，使用工厂模式和服务器定位模式可降低耦合，它们都是IoC的一种。</p><p><a name="LtAfb"></a></p><h3 id="使用工厂-服务器定位模式"><a href="#使用工厂-服务器定位模式" class="headerlink" title="使用工厂/服务器定位模式"></a>使用工厂/服务器定位模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentFinderService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getGoodAgents</span><span class="params">(String agentFinderType)</span> </span>&#123;</span><br><span class="line">        AgentFinderFactory factory = AgentFinderFactory.getInstance();</span><br><span class="line">        AgentFinder finder = factory.getAgentFinder(agentFinderType);</span><br><span class="line">List&lt;String&gt; allAgents = finder.getAllAgents();</span><br><span class="line"><span class="keyword">return</span> filterAgents(allAgents);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">filterAgents</span><span class="params">(List&lt;String&gt; agents)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AgentFinderFactory根据注入的agentFinderType实例化令人满意的AgentFinder。仍存在问题：</p><ul><li>代码注入agentFinderType作为引用凭据，而没有注入真正的对象。</li><li>getGoodAgents仍存在其他依赖项，达不到只关注自身职能的状态。</li></ul><p><a name="DXp6k"></a></p><h3 id="使用DI"><a href="#使用DI" class="headerlink" title="使用DI"></a>使用DI</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentFinderService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getGoodAgents</span><span class="params">(AgentFinder finder)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; allAgents = finder.getAllAgents();</span><br><span class="line"><span class="keyword">return</span> filterAgents(allAgents);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">filterAgents</span><span class="params">(List&lt;String&gt; agents)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上AgentFinder被直接注入到getGoodAgents方法中，只专注于纯业务逻辑。存在问题，如何配置AgentFinder具体实现？原本AgentFinderFactory要做的事情只是<strong>换个地方</strong>完成。</p><p><a name="LhmHR"></a></p><h3 id="使用JSR-330-DI"><a href="#使用JSR-330-DI" class="headerlink" title="使用JSR-330 DI"></a>使用JSR-330 DI</h3><p>使用框架执行DI操作，DI框架用标准的JSR-330<a href="#">@Inject</a>注解将依赖项注入到getGoodAgents方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentFinderService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Inject</span> <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getGoodAgents</span><span class="params">(AgentFinder finder)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; allAgents = finder.getAllAgents();</span><br><span class="line"><span class="keyword">return</span> filterAgents(allAgents);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">filterAgents</span><span class="params">(List&lt;String&gt; agents)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，AgentFinder的某个具体实现类的实例由支持JSR-330@inject注解的DI框架在运行时注入。</p><blockquote><p>JSR 企业应用标准：<br>JSR-330: Dependency Injection for Java 1.0<br>JSR-330统一DI体系，对大多数Java DI框架的核心功能做了很好的汇总</p></blockquote><p>从以上改造来温故依赖注入对我们的帮助：</p><ul><li>松耦合</li><li>可测性</li><li>更强的内聚性</li><li>可重用组件</li><li>更轻盈的代码</li></ul><p><a name="FAjHO"></a></p><h2 id="三、Java中标准化DI"><a href="#三、Java中标准化DI" class="headerlink" title="三、Java中标准化DI"></a>三、Java中标准化DI</h2><p>DI新标准中，javax.inject包只是提供一个接口和几个注解类型，这些都会被遵循JSR-330标准的各种DI框架实现。</p><p><a name="eSefj"></a></p><h3 id="理解DI工作原来"><a href="#理解DI工作原来" class="headerlink" title="理解DI工作原来"></a>理解DI工作原来</h3><p>优秀的Java开发人员不能只满足于使用类库和框架，要明白内部基本工作原理。在DI领域，会面临各种问题，如依赖项配置错误、依赖项诡异地超出作用域、依赖项在不该共享时被共享、分布调试离奇宕机等。</p><p>理解javax.inject包：</p><blockquote><p>javax.inject包<br>这个包指明了获取对象的一种方式，与传统的构造方法、工厂模式、服务器定位模式（如JNDI）等相比，这种方式的可重用性、可测试性、可维护性都有极大提升。这种方式成为依赖注入。</p></blockquote><p>javax.inject包中包括一个Provider<t>接口和5个注解类型（@inject、@Qualifier、@Named、@Scope、@Singleton）。</t></p><p><a name="M5vYz"></a></p><h3 id="Inject-注解"><a href="#Inject-注解" class="headerlink" title="@Inject 注解"></a>@Inject 注解</h3><p>@Inject注解可以出现在三种类成员之前，表示该成员需要依赖注入。按运行时处理顺序：</p><ol><li>构造器</li><li>方法</li><li>属性</li></ol><p><a name="kECuT"></a></p><h4 id="构造器上使用-Inject"><a href="#构造器上使用-Inject" class="headerlink" title="构造器上使用@Inject"></a>构造器上使用@Inject</h4><p>在构造器上使用@Inject时，其参数在运行时由配置好的IoC容器提供。比如在下面的代码中，运行时调用AgentFinderService的构造器时，IoC容器会注入其参数AgentFinder。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentFinderService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AgentFinder finder;</span><br><span class="line"><span class="meta">@Inject</span> <span class="function"><span class="keyword">public</span> <span class="title">AgentFinderService</span><span class="params">(AgentFinder finder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.finder = finder;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><p>因为JRE无法决定构造器注入的优先级，所以规范中规定类中<strong>只能有一个构造器带@Inject注解</strong></p><p><a name="zlKd3"></a></p><h4 id="方法上使用-Inject"><a href="#方法上使用-Inject" class="headerlink" title="方法上使用@Inject"></a>方法上使用@Inject</h4><p>运行时可注入的参数可以是多个也可以是0个，使用参数注入的方法不能声明为抽象方法，也不能声明其自身的类型参数。下面这段代码在set方法前使用@Inject，这是注入可选属性的常用技术。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(Content contnet)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.content = content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向方法中注入参数技术对于服务类方法来说非常有用，其所需的资源可以作为参数注入，比如向查询数据库的服务方法中注入数据访问对象（DAO）。</p><blockquote><p>向构造器注入的通常是类中必需的依赖项，而对于非必需的依赖项，通常是在set方法上注入。比如已经给出了默认的属性就是非必需的依赖项。</p></blockquote><p><a name="nxUoc"></a></p><h4 id="属性上使用-Inject"><a href="#属性上使用-Inject" class="headerlink" title="属性上使用@Inject"></a>属性上使用@Inject</h4><p>简单直接，但最好不要用。因为这样可能会使单元测试更加困难。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentFinderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span> <span class="keyword">private</span> <span class="keyword">final</span> AgentFinder finder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="QyP4w"></a></p><h3 id="Qualifier-注解"><a href="#Qualifier-注解" class="headerlink" title="@Qualifier 注解"></a>@Qualifier 注解</h3><p>JSR-330规范使用@Qualifier限定（标识）要注入的对象，比如IoC容器有两个类型相同的对象，当把他们注入到你的代码中时，要把他们区分开来。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/204153/1560392266590-a5a9c420-3145-49f5-a196-b1d91d6ff87a.png#align=left&amp;display=inline&amp;height=399&amp;name=image.png&amp;originHeight=399&amp;originWidth=689&amp;size=18655&amp;status=done&amp;width=689" alt="image.png"><br>创建一个@Qualifier实现必须遵循如下规则：</p><ul><li>必须标记为@Qualifier和@Retention（RUNTIME），以确保该限定注解在运行时一直有效。</li><li>通常还要加上@Documented注解，这样该实现就能加到API的公共JavaDoc中了。</li><li>可以有属性。</li><li>@Target注解可以限定其使用范围。</li></ul><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MusicGenre &#123;</span><br><span class="line">    <span class="function">Genre <span class="title">genre</span><span class="params">()</span> <span class="keyword">default</span> Genre.TRANCE</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> GENRE &#123; CLASSICAL, METAL, ROCK, TRANCE &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Evb8J"></a></p><h3 id="Named-注解"><a href="#Named-注解" class="headerlink" title="@Named 注解"></a>@Named 注解</h3><p><a href="#">@amed</a>@Named是一个特别的@Qualifier注解，借助@Named可以用名字注明要注入的对象。将@Named和@Inject一起使用，符合指定名称并且类型正确的对象会被注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentFinderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span> <span class="meta">@Named</span>(<span class="string">"devFinder"</span>) <span class="keyword">private</span> <span class="keyword">final</span> AgentFinder devFinder;</span><br><span class="line">    <span class="meta">@Inject</span> <span class="meta">@Named</span>(<span class="string">"bankFinder"</span>) <span class="keyword">private</span> <span class="keyword">final</span> AgentFinder bankFinder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="J6Xx8"></a></p><h3 id="Scoped-注解"><a href="#Scoped-注解" class="headerlink" title="@Scoped 注解"></a>@Scoped 注解</h3><p>@Scoped注解用于自定义注解器（IoC容器）对注入对象的重用方式。JSR-330默认了如下几种默认行为：</p><ul><li>如果未声明任何@Scope注解接口的实现，注入器应创建注入对象并且仅使用该对象一次。</li><li>如果声明了@Scoped注解接口，注入对象的声明周期由所声明的@Scoped注解实现决定。</li><li>如果注入对象在@Scoped实现中要由多个线程使用，则需保证注入对象的线程安全性。</li><li>如果某个类上声明了多个@Scoped注解，或声明了不受支持的@Scoped注解，IoC容器应该抛出异常。</li></ul><p>公认的通用@Scoped实现只有@Singleton一个，JSR-330只确定了这么一个标准的生命周期注解。</p><p><a name="NWSe0"></a></p><h3 id="Singleton-注解"><a href="#Singleton-注解" class="headerlink" title="@Singleton 注解"></a>@Singleton 注解</h3><p>@Singleton注解接口在DI框架中应用广泛，需要注入一个不会改变的对象时，就要用@Singleton。大多数DI框架都将@Singleton作为注入对象的默认声明周期，无需显式发明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentFinderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span> <span class="meta">@Singleton</span> <span class="keyword">private</span> AgentFinder devFinder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="y22MA"></a></p><h3 id="接口Provider"><a href="#接口Provider" class="headerlink" title="接口Provider"></a>接口Provider<t></t></h3><p>当DI框架的标准注解不能满足你的需求，你想对DI框架注入代码中的对象拥有更多的控制权，可以要求DI框架将Provider<t>接口实现注入对象。</t></p><ul><li>可以获取该对象的多个实例。</li><li>可以延迟加载对象。</li><li>可以打破循环依赖。</li><li>可以定义作用域，能在比整个被加载的应用小的作用域中查找对象。</li></ul><p>该接口仅有一个T get()方法，这个方法会返回一个构造好的注入对象（T）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentFinderService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Inject</span> <span class="function"><span class="keyword">public</span> <span class="title">AgentFinderService</span><span class="params">(AgentFinderProvider provider)</span> </span>&#123;</span><br><span class="line">AgentFinder finder = provider.get();</span><br><span class="line">        <span class="keyword">if</span> (condition) &#123; <span class="comment">// 延迟加载</span></span><br><span class="line">            AgentFinder finder2 = provider.get(); <span class="comment">// 多个实例对象</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="sa2Mm"></a></p><h2 id="四、DI参考实现：Guice3"><a href="#四、DI参考实现：Guice3" class="headerlink" title="四、DI参考实现：Guice3"></a>四、DI参考实现：Guice3</h2><p>Guice3是JSR-330规范的完整参考实现，可以配置、绑定、注入依赖项。</p><p><a name="aA1Cw"></a></p><h3 id="实现DI"><a href="#实现DI" class="headerlink" title="实现DI"></a>实现DI</h3><p><a name="Ra3KF"></a></p><h4 id="创建绑定关系"><a href="#创建绑定关系" class="headerlink" title="创建绑定关系"></a>创建绑定关系</h4><p>先创建绑定关系AgentFinderModule，重写configure()声明绑定关系，当AgentFinderService要求@Inject一个AgentFinder时，就会绑定DevAgentFinder作为注入对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentFinderModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">bind(AgentFinder.class).to(DevAgentFinder.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentFinderService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AgentFinder finder;</span><br><span class="line"><span class="meta">@Inject</span> <span class="function"><span class="keyword">public</span> <span class="title">AgentFinderService</span><span class="params">(AgentFinder finder)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.finder = finder;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getGoodAgents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; allAgents = finder.getAllAgents();</span><br><span class="line"><span class="keyword">return</span> filterAgents(allAgents);</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码4-1</p><p><a name="WQnho"></a></p><h4 id="构建Guice对象关系图"><a href="#构建Guice对象关系图" class="headerlink" title="构建Guice对象关系图"></a>构建Guice对象关系图</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Injector injector = Guice.createInjector(<span class="keyword">new</span> AgentFinderModule());</span><br><span class="line">AgentFinderService hollywoodService = injector.getInstance(AgentFinderService.class);</span><br><span class="line">List&lt;String&gt; agents = hollywoodService.getGoodAgents();</span><br><span class="line">System.out.println(agents);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码4-2<br><a name="m1R8M"></a></p><h3 id="Guice的各种绑定"><a href="#Guice的各种绑定" class="headerlink" title="Guice的各种绑定"></a>Guice的各种绑定</h3><p>Guice提供多种绑定方式：</p><ul><li>链接绑定</li><li>绑定注解</li><li>实例绑定</li><li>@Provides方法</li><li>Provider绑定</li><li>无目标绑定</li><li>内置绑定</li><li>及时绑定</li></ul><p>最常用的包括链接绑定、绑定注解、@Provides方法、Provider<t>绑定。<br><a name="DPOM8"></a></t></p><h4 id="链接绑定"><a href="#链接绑定" class="headerlink" title="链接绑定"></a>链接绑定</h4><p>代码4-1中AgentFinderModule即为链接绑定，是最简单的绑定方式，只是告诉注入器运行时应该注入实现类或扩展类（可以直接注入子类）。</p><p><a name="4nYv7"></a></p><h4 id="绑定注解"><a href="#绑定注解" class="headerlink" title="绑定注解"></a>绑定注解</h4><p>将注入类的类型和额外的标识符组合起来，以标识恰当的注入对象。使用JSR-330标准注解@Named，注入特定名称的AgentFinder，在AgentFinderModule中配置@Named绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentFinderModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">bind(AgentFinder.class)</span><br><span class="line">            .annotatedWith(Names.named(<span class="string">"primary"</span>))</span><br><span class="line">            .to(DevAgentFinder.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentFinderService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AgentFinder finder;</span><br><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AgentFinderService</span><span class="params">(@Named(<span class="string">"primary"</span>)</span> AgentFinder finder) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.finder = finder;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="cMKDQ"></a></p><h4 id="Provides和Provider：提供完全定制的对象"><a href="#Provides和Provider：提供完全定制的对象" class="headerlink" title="@Provides和Provider：提供完全定制的对象"></a>@Provides和Provider：提供完全定制的对象</h4><p>需要注入特别的AgentFinder，使用@Provides注解或在configure()方法中绑定，注入器会查看左右标记了@Provides注解方法的返回类型，决定 注入哪个对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentFinderModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="function">AgentFinder <span class="title">provideAgentFinder</span><span class="params">()</span> </span>&#123; <span class="comment">// 返回注入器需要的类型</span></span><br><span class="line">DevAgentFinder finder = <span class="keyword">new</span> DevAgentFinder(); <span class="comment">// 创建实例并定制</span></span><br><span class="line">finder.setName(<span class="string">"JavaFind"</span>);</span><br><span class="line"><span class="keyword">return</span> finder;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@Provides方法会变得越来越大，为简化Module，需要把定制化代码拆分出去。使用toProvider方法绑定到Provider类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentFinderProvider</span> <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">AgentFinder</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AgentFinder <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DevAgentFinder finder = <span class="keyword">new</span> DevAgentFinder(); <span class="comment">// 创建实例并定制</span></span><br><span class="line">finder.setName(<span class="string">"JavaFind"</span>);</span><br><span class="line"><span class="keyword">return</span> finder;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentFinderModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">bind(AgentFinder.class)</span><br><span class="line">            .toProvider(AgentFinderProvider.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="MLwOI"></a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://jinnianshilongnian.iteye.com/blog/1413846" target="_blank" rel="noopener">https://jinnianshilongnian.iteye.com/blog/1413846</a><br>《Java程序员修炼之道 Benjamin J.Evans》第3章</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲真的，今年就业形势相当不好，对IT从业者的专业能力要求将变得更高。近来一边忙学业，一边学习Java基础和框架源码，为不久之后的招聘做准备。&lt;/p&gt;
&lt;p&gt;打算从Java7、Java8d的版本新特性着手，再深入JVM、并发编程等。Java7中发布了JSR-330标准的DI特性。IoC是控制反转，DI是依赖注入。依赖注入（控制反转的一种形式）是Java开发主流中一个重要的范式。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://blackist.org/categories/Java/"/>
    
    
      <category term="开发" scheme="https://blackist.org/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="java" scheme="https://blackist.org/tags/java/"/>
    
      <category term="java7" scheme="https://blackist.org/tags/java7/"/>
    
      <category term="IoC" scheme="https://blackist.org/tags/IoC/"/>
    
  </entry>
  
  <entry>
    <title>分布式-开启SpringBoot微服务之旅</title>
    <link href="https://blackist.org/2019/05/22/distributed-outline/"/>
    <id>https://blackist.org/2019/05/22/distributed-outline/</id>
    <published>2019-05-22T06:58:05.000Z</published>
    <updated>2019-07-02T15:49:40.014Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>分布式架构可以降低程序错误给整体系统带来的风险，也可以通过不断扩张主机的数量以实现横向水平的性能扩展，因此我们需要分布式架构。</p><a id="more"></a><h2 id="微服务架构及容器技术"><a href="#微服务架构及容器技术" class="headerlink" title="微服务架构及容器技术"></a>微服务架构及容器技术</h2><p>微服务这个词近几年很火，微服务架构（Microservices Architecture，MSA）是分布式架构的一种，它的产生主要依赖以下方面的内容：</p><ul><li>领域驱动设计：分析并模型化复杂业务。</li><li>敏捷方法论：快速发布，形成有效反馈。</li><li>持续交付：更快、可靠、频繁地部署和交付。</li><li>虚拟化和基础设施自动化：Docker等容器技术简化安装部署环境。</li><li>DevOps：开发、测试、运维整合。</li></ul><p>MSA把小的服务开发成单一应用的形式，每个服务运行在单独的进程中并采用轻量级的机制通信（HTTP等）。这些服务围绕业务构建，自动化部署，可以使用不同的编程语言和存储技术，并保持最小化集中管理。</p><h3 id="如何构建微服务"><a href="#如何构建微服务" class="headerlink" title="如何构建微服务"></a>如何构建微服务</h3><p>ZooKeeper、Dubbo、Jersey、SpringBoot、SpringColud等都可以实现微服务。我决定围绕SpringBoot、SpringCloud展开微服务架构学习。</p><h2 id="SpringBoot微服务架构基础"><a href="#SpringBoot微服务架构基础" class="headerlink" title="SpringBoot微服务架构基础"></a>SpringBoot微服务架构基础</h2><p>SpringBoot简化企业级应用开发地复杂性，提供很多开箱即用的Starter，通过少量代码创建一个独立的、产品级Spring应用。</p><p>我学习的步骤如下：</p><ul><li>SpringBoot引入Web创建RESTful API和单元测试</li><li>使用Swagger2构建API文档</li><li>统一处理异常</li><li>SpringData JPA</li><li>SpringSecurity和JWT</li><li>事务管理</li><li>集中式缓存Redis</li><li>日志系统 本地日志和MongoDB</li><li>消息服务RabbitMQ</li><li>邮件系统</li></ul><h2 id="微服务架构设计原则"><a href="#微服务架构设计原则" class="headerlink" title="微服务架构设计原则"></a>微服务架构设计原则</h2><ul><li>拆分足够微：足够小即可，不要过小。小团队两周内开发完且能够维护。</li><li>轻量级通信：服务跨进程或跨主机，服务间通信采用采用轻量级通信协议，同步的REST（HTTP:XML/JSON），异步的AMQP、MQTT、STOMP。</li><li>领域驱动原则：基于领域驱动设计（Domain-Driven Design，DDD）开发一个微服务，一个服务反应某个业务的领域模型，理清领域边界逻辑和上下文边界。</li><li>单一职责原则：高内聚，低耦合。密切相关的多个功能应尽量包含在同一个服务中以降低服务间的干扰；通过接口（API、事件）进行通信以降低对其它服务的依赖。</li><li>DevOps及两个披萨：开发人员具备用户界面、业务逻辑、持久化存储、独立运维的全栈能力，降低沟通成本，防止项目陷入停顿。人数不多过两个披萨不够吃。</li><li>不限于技术栈：根据场景（计算密集型[CPU/内存]、非结构化存储[NoSQL]）进行技术选型，但不滥用技术，以安全稳定的Java等为主。</li><li>可独立部署：微服务独立部署使得开发者不再需要协调其它服务部署对本服务的影响；Docker容器技术使得服务能够在构建镜像中所期望的环境中运行。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.didispace.com/spring-boot-learning-1x/" target="_blank" rel="noopener">http://blog.didispace.com/spring-boot-learning-1x/</a></p><p>《SpringCloud微服务架构 杨伟卫著》第1章 微服务概述</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式架构可以降低程序错误给整体系统带来的风险，也可以通过不断扩张主机的数量以实现横向水平的性能扩展，因此我们需要分布式架构。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://blackist.org/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="springboot" scheme="https://blackist.org/tags/springboot/"/>
    
      <category term="分布式" scheme="https://blackist.org/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门</title>
    <link href="https://blackist.org/2019/05/03/ops-docker-basic/"/>
    <id>https://blackist.org/2019/05/03/ops-docker-basic/</id>
    <published>2019-05-03T12:51:42.000Z</published>
    <updated>2019-06-16T09:47:35.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux Containers Linux容器 缩写LXC，其对进程进行隔离，而非一个完整的操作系统。Docker属于LXC的一种封装，提供简单易用的容器使用接口。Docker主要用于提供一次性环境、提供 弹性的云服务、组件微服务架构。</p><a id="more"></a><h2 id="一、基本操作"><a href="#一、基本操作" class="headerlink" title="一、基本操作"></a>一、基本操作</h2><h3 id="1-1-Docker安装"><a href="#1-1-Docker安装" class="headerlink" title="1.1 Docker安装"></a>1.1 Docker安装</h3><p>Docker是一个开源的开品，有两个版本：CE（Community Edition）和EE（Enterprise Edition）。企业版包含一些收费服务，社区版适合个人开发者。</p><ul><li><a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Ubuntu</a></li><li><a href="https://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/" target="_blank" rel="noopener">CentOS</a></li><li><a href="https://docs.docker-cn.com/docker-for-mac/install/" target="_blank" rel="noopener">Mac</a></li></ul><p>安装完成后，使用如下命令验证是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -version</span><br></pre></td></tr></table></figure><p>Docker需要用户具有sudo权限，为了避免每次输入sudo以及用户不具有sudo权限，请先使用管理员用户将特定的用户添加到Docker用户组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G docker $USER</span><br></pre></td></tr></table></figure></p><p>Docker 是服务器—-客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 启动Docker服务</span><br><span class="line">sudo service docker start</span><br><span class="line"># 设置开启自己懂</span><br><span class="line">systemctl enable docker.service</span><br><span class="line"># 检查开机自启动设置成功没</span><br><span class="line">systemctl list-unit-files |grep docker</span><br><span class="line"></span><br><span class="line">docker.service                             enabled </span><br><span class="line">docker.socket                              enabled</span><br></pre></td></tr></table></figure><h3 id="1-2-Docker镜像文件image"><a href="#1-2-Docker镜像文件image" class="headerlink" title="1.2 Docker镜像文件image"></a>1.2 Docker镜像文件image</h3><p>Docker将应用程序及其依赖打包在镜像（image）文件里，通常一个image会继承自另一个image，开发者在其中加入个性化的配置，从而形成定制化的镜像文件。</p><p>Docker通过image来生成并运行虚拟容器。比如说我们的网站程序打包成image文件并拷贝在一个服务器上，通过docker根据此image文件在服务器上生成并运行多个相同的网站程序。</p><p>通过Docker管理image文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 列出本机的image文件</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"># 删除本机image文件</span><br><span class="line">docker image rm $image_name</span><br></pre></td></tr></table></figure><p>image具备复用性，通常我们可以使用别人制作好的Image文件，这些共享镜像通常来自于<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>。</p><h3 id="1-3-Docker镜像实例"><a href="#1-3-Docker镜像实例" class="headerlink" title="1.3 Docker镜像实例"></a>1.3 Docker镜像实例</h3><p>我们可以从Docker官方镜像仓库/第三方仓库拉取image文件并运行。</p><h4 id="hello-world"><a href="#hello-world" class="headerlink" title="hello-world"></a>hello-world</h4><p>从官方拉取hello-world镜像来感受下Docker：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull library/hello-world</span><br></pre></td></tr></table></figure></p><ul><li>docker image pull：拉取镜像的命令</li><li>library：镜像文件所在组</li><li>hello-world：镜像文件的名字</li></ul><p>Docker官方提供的镜像文件都在library下，因此library是默认镜像组，可省略不写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull hello-world</span><br></pre></td></tr></table></figure><h3 id="1-4-Docker运行容器实例"><a href="#1-4-Docker运行容器实例" class="headerlink" title="1.4 Docker运行容器实例"></a>1.4 Docker运行容器实例</h3><p>基于image文件生成并运行容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container run hello-world</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>输出一段话后，hello-world容器自动终止。</p><p>有些容器不会自动终止，因为它们提供的是服务例如网站容器和虚拟操作系统容器，运行ubuntu的容器，docker会从镜像仓库下载ubuntu的镜像，下载完成后直接从ubuntu镜像运行容器实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker container run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Unable to find image &apos;ubuntu:latest&apos; locally</span><br><span class="line">latest: Pulling from library/ubuntu</span><br><span class="line">f476d66f5408: Pull complete</span><br><span class="line">...</span><br><span class="line">Status: Downloaded newer image for ubuntu:latest</span><br><span class="line">root@341a7595b69e:</span><br></pre></td></tr></table></figure><ul><li>-t: flag assigns a pseudo-tty or terminal inside the new container.</li><li>-i: flag allows you to make an interactive connection by grabbing the standard in (STDIN) of the container.</li><li>-it：Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器</li><li>bash: launches a Bash shell inside our container.</li></ul><p>输入exit或按Ctrl+D可退出此ubuntu容器实例进程，此种方式依赖命令行运行，命令行退出则容器进程终止（使用Ctrl+P+Q也可退出容器且不关闭容器）。使用ps命令查看docker进程，可见ubuntu的进程已退出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED       STATUS    </span><br><span class="line">341a7595b69e        ubuntu              &quot;bash&quot;              2 minutes ago       Exited </span><br><span class="line"></span><br><span class="line">44a7468dabfd        hello-world         &quot;/hello&quot;            23 minutes ago      Exited</span><br></pre></td></tr></table></figure><p>也可以将将容器作为后台进程运行，再使用attach命令进入在后台运行的容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker container run -itd ubuntu</span><br><span class="line">1f7b446e9a8f6a9e9ec8066526f055222c9cfb6bf75f5389a8a9163428d53272</span><br><span class="line"></span><br><span class="line">docker ps -a </span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED       STATUS</span><br><span class="line">1f7b446e9a8f        ubuntu              &quot;bash&quot;              13 seconds ago      Up 11 seconds</span><br><span class="line"></span><br><span class="line">341a7595b69e        ubuntu              &quot;bash&quot;              2 minutes ago       Exited </span><br><span class="line"></span><br><span class="line">44a7468dabfd        hello-world         &quot;/hello&quot;            23 minutes ago      Exited</span><br></pre></td></tr></table></figure><p>容器在后台运行成功，使用attach/exec命令进入后台进程的ubuntu容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># docker attach [OPTIONS] CONTAINER</span><br><span class="line">docker attach 1f7b446e9a8f</span><br><span class="line"></span><br><span class="line"># docker exec [OPTIONS] CONTAINER COMMAND [PARAMS]</span><br><span class="line">docker exec 1f7b446e9a8f bash</span><br><span class="line"></span><br><span class="line">root@1f7b446e9a8f:/#</span><br></pre></td></tr></table></figure><p>容器进程退出，但容器文件依然存在，因此关闭容器不会删除容器文件。一些container常用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 启动容器</span><br><span class="line">docker start CONTAINER</span><br><span class="line"># 50s内停止容器，否则强制停止</span><br><span class="line">docker stop -t 50 CONTAINER</span><br><span class="line"># 强制停止容器</span><br><span class="line">docker kill CONTAINER</span><br><span class="line"># 重启容器</span><br><span class="line">docker restart CONTAINER</span><br><span class="line"># 删除容器文件</span><br><span class="line">docker rm CONTAINER</span><br></pre></td></tr></table></figure><h2 id="二、自定义容器"><a href="#二、自定义容器" class="headerlink" title="二、自定义容器"></a>二、自定义容器</h2><p>使用Dockerfile来定制image，适应我们自己的需要。Dockerfile是一个文本配置文件，docker将根据它生成我们需要的image。</p><h3 id="2-1-准备镜像所需的工程代码或文件"><a href="#2-1-准备镜像所需的工程代码或文件" class="headerlink" title="2.1 准备镜像所需的工程代码或文件"></a>2.1 准备镜像所需的工程代码或文件</h3><p>拉取测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/blackist/maven-quiz.git</span><br></pre></td></tr></table></figure></p><p>在本地编译maven项目，mvn clean package编译出需要的war包。</p><blockquote><p>也可基于maven镜像，在容器内构建maven项目，但需要令行配置</p></blockquote><h3 id="2-2-编写Docker配置文件"><a href="#2-2-编写Docker配置文件" class="headerlink" title="2.2 编写Docker配置文件"></a>2.2 编写Docker配置文件</h3><p>在此项目基础上构建Dockerfile项目，新建Dockerfile配置文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ADD ./target/maven-quiz.jar /app.jar</span><br><span class="line">EXPOSE 8000</span><br><span class="line">ENTRYPOINT [&quot;nohup&quot;, &quot;java&quot;, &quot;-Dserver.port=8000&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;, &quot;&amp;&quot;]</span><br></pre></td></tr></table></figure><h4 id="FROM-openjdk-8"><a href="#FROM-openjdk-8" class="headerlink" title="FROM openjdk:8"></a>FROM openjdk:8</h4><p>基于openjdk8镜像编译自定义镜像</p><h4 id="VOLUME-tmp"><a href="#VOLUME-tmp" class="headerlink" title="VOLUME /tmp"></a>VOLUME /tmp</h4><p>将本地文件夹挂载到当前容器</p><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p> ADD ./target/maven-quiz.jar /app.jar 是拷贝war文件到容器</p><h4 id="EXPOSE-8000"><a href="#EXPOSE-8000" class="headerlink" title="EXPOSE 8000"></a>EXPOSE 8000</h4><p>开放8000端口</p><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>ENTRYPOINT [“nohup”, “java”, “-Dserver.port=8000”, “-jar”, “/app.jar”, “&amp;”]<br>配置容器启动后执行的命令，使用nohup使得java程序运行于后台，不至于命令行退出java程序终止。</p><ul><li>ENTRYPOINT，表示镜像在初始化时需要执行的命令，不可被重写覆盖，需谨记</li><li>CMD，表示镜像运行默认参数，可被重写覆盖</li><li>ENTRYPOINT/CMD都只能在文件中存在一次，并且最后一个生效 多个存在，只有最后一个生效，其它无效！</li><li>需要初始化运行多个命令，彼此之间可以使用 &amp;&amp; 隔开，但最后一个须要为无限运行的命令，需切记！</li></ul><p>ENTRYPOINT/CMD，一般两者可以配合使用，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;/usr/sbin/sshd&quot;] </span><br><span class="line">CMD [&quot;-D&quot;]</span><br></pre></td></tr></table></figure><h2 id="2-3-编译Docker镜像"><a href="#2-3-编译Docker镜像" class="headerlink" title="2.3 编译Docker镜像"></a>2.3 编译Docker镜像</h2><p>编译命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t maven-quiz .</span><br></pre></td></tr></table></figure><ul><li>docker build 或 docker image build：编译命令</li><li>-t：指定镜像的name，maven-quiz为镜像名，其后可加:来指定标签，默认为lastest</li><li>.：指定Dockerfile配置文件所在路径，.即是当前路径</li></ul><p>编译过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon  16.87MB</span><br><span class="line">Step 1/5 : FROM openjdk:8</span><br><span class="line"> ---&gt; b8d3f94869bb</span><br><span class="line">Step 2/5 : VOLUME /tmp</span><br><span class="line"> ---&gt; Running in dd6790b892cc</span><br><span class="line">Removing intermediate container dd6790b892cc</span><br><span class="line"> ---&gt; c22a0db1f2e0</span><br><span class="line">Step 3/5 : ADD ./target/maven-quiz.jar /app.jar</span><br><span class="line"> ---&gt; 3a7eb1b80968</span><br><span class="line">Step 4/5 : EXPOSE 8000</span><br><span class="line"> ---&gt; Running in 95ea426741b7</span><br><span class="line">Removing intermediate container 95ea426741b7</span><br><span class="line"> ---&gt; b472a3d4e0d5</span><br><span class="line">Step 5/5 : ENTRYPOINT [&quot;nohup&quot;, &quot;java&quot;, &quot;-Dserver.port=8000&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;, &quot;&amp;&quot;]</span><br><span class="line"> ---&gt; Running in c95c9393b88f</span><br><span class="line">Removing intermediate container c95c9393b88f</span><br><span class="line"> ---&gt; 48aa6f27aecf</span><br><span class="line">Successfully built 48aa6f27aecf</span><br><span class="line">Successfully tagged maven-quiz:latest</span><br></pre></td></tr></table></figure><h3 id="2-4-运行容器"><a href="#2-4-运行容器" class="headerlink" title="2.4 运行容器"></a>2.4 运行容器</h3><p>运行命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8000:8000 -itd maven-quiz</span><br></pre></td></tr></table></figure><p>-docker run：运行容器</p><ul><li>-p：指定本地：容器端口映射</li><li>-itd：容器在后台运行</li><li>maven-quiz：指定镜像，:后加标签，默认为lastest</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></p><p><a href="https://blog.csdn.net/zhezhebie/article/details/75501149" target="_blank" rel="noopener">https://blog.csdn.net/zhezhebie/article/details/75501149</a></p><p><a href="http://book.itmuch.com/3%20%E4%BD%BF%E7%94%A8Docker%E6%9E%84%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1/3.6%20%E4%BD%BF%E7%94%A8Dockerfile%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F.html" target="_blank" rel="noopener">http://book.itmuch.com/3%20%E4%BD%BF%E7%94%A8Docker%E6%9E%84%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1/3.6%20%E4%BD%BF%E7%94%A8Dockerfile%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F.html</a></p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux Containers Linux容器 缩写LXC，其对进程进行隔离，而非一个完整的操作系统。Docker属于LXC的一种封装，提供简单易用的容器使用接口。Docker主要用于提供一次性环境、提供 弹性的云服务、组件微服务架构。&lt;/p&gt;
    
    </summary>
    
      <category term="OPS" scheme="https://blackist.org/categories/OPS/"/>
    
    
      <category term="Linux" scheme="https://blackist.org/tags/Linux/"/>
    
      <category term="OPS" scheme="https://blackist.org/tags/OPS/"/>
    
      <category term="Docker" scheme="https://blackist.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Android组件化-MVP设计模式</title>
    <link href="https://blackist.org/2019/03/31/android-modulize-mvp/"/>
    <id>https://blackist.org/2019/03/31/android-modulize-mvp/</id>
    <published>2019-03-31T08:12:27.000Z</published>
    <updated>2019-06-16T09:47:35.122Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Anroid MVP是安卓开发中一个经典的话题，当项目较大、参与的开发人员较多，MVP的优势就体现出来了。</p><a id="more"></a><blockquote><p><strong>系列文章</strong></p><p><a href="/2018/10/18/android-modulize-common/">Android组件化-基础框架搭建</a></p><p><a href="/2018/10/23/android-modulize-router/">Android组件化-组件间通信BRouter</a></p><p><a href="/2019/03/21/android-modulize-ui-theme/">Android组件化-风格统一&amp;主题变色</a></p><p><a href="/2019/03/31/android-modulize-mvp/">Android组件化-MVP设计模式</a></p></blockquote><h2 id="一、经典的MVP"><a href="#一、经典的MVP" class="headerlink" title="一、经典的MVP"></a>一、经典的MVP</h2><blockquote><p>经典的意思，就是又老又香 ^-^</p></blockquote><h3 id="1-1-一句话MVP"><a href="#1-1-一句话MVP" class="headerlink" title="1.1 一句话MVP"></a>1.1 一句话MVP</h3><p>提到Android MVP（Model-View-Presenter）就会想到MVC（Model-View-Controller），C就是Web开发中经常提到的Controller，P则是Android中用来分离Activity逻辑与界面的Presenter。</p><p>MVP核心思想：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MVP把Activity中的UI逻辑抽象成View接口，把业务逻辑抽象成Presenter接口，Model类还是原来的Model。</span><br></pre></td></tr></table></figure><h3 id="1-2-MVP图解"><a href="#1-2-MVP图解" class="headerlink" title="1.2 MVP图解"></a>1.2 MVP图解</h3><p>一图胜千言：</p><p><img src="http://pic.blackist.top/android-modulize-mvp-struc.png" alt="MVP模型图"></p><ul><li>视图View：Activity和Fragment</li><li>逻辑Presenter：业务逻辑和业务管理类等</li><li>模型Model：SharedPreferences、数据库访问（Dao）和网络交互（Api）</li></ul><h2 id="二、Modulize使用MVP"><a href="#二、Modulize使用MVP" class="headerlink" title="二、Modulize使用MVP"></a>二、Modulize使用MVP</h2><p><a href="https://github.com/blackist/modulize" target="_blank" rel="noopener">Modulize项目</a>使用MVP作为基本的开发框架（以登录为例）。</p><h3 id="2-1-Model层的设计"><a href="#2-1-Model层的设计" class="headerlink" title="2.1 Model层的设计"></a>2.1 Model层的设计</h3><p>Model层负责数据交互，包括网络交互、本地数据库交互以及SharedPreferences数据存取。在lib-common中添加抽象类BaseModel，LoginModel等业务模块继承自BaseModel。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="网络交互-okHttp-Retrofit-Rxjava"><a href="#网络交互-okHttp-Retrofit-Rxjava" class="headerlink" title="网络交互 - okHttp+Retrofit+Rxjava"></a>网络交互 - okHttp+Retrofit+Rxjava</h4><p>网络访问使用无话可说的okHttp，结合优雅的Retrofit，加以RxJava，真香！</p><p>使用okHttpClient实例管理全局http访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class OkHttp3Util &#123;</span><br><span class="line"></span><br><span class="line">    private static OkHttpClient mOkHttpClient;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取OkHttpClient对象实例</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static OkHttpClient getOkHttpClient() &#123;</span><br><span class="line"></span><br><span class="line">        if (null == mOkHttpClient) &#123;</span><br><span class="line"></span><br><span class="line">            // build design mode</span><br><span class="line">            mOkHttpClient = new OkHttpClient.Builder()</span><br><span class="line">                    // cookie manager</span><br><span class="line">                    .cookieJar(new CookiesManager())</span><br><span class="line">                    // 网络请求日志</span><br><span class="line">                    .addInterceptor(loggingInterceptor)</span><br><span class="line">                    // 自定义拦截器</span><br><span class="line">                    .addInterceptor(new CommonIntercepter())</span><br><span class="line">                    // set timeout of connection, reading and writing</span><br><span class="line">                    .connectTimeout(10, TimeUnit.SECONDS)</span><br><span class="line">                    .writeTimeout(30, TimeUnit.SECONDS)</span><br><span class="line">                    .readTimeout(20, TimeUnit.SECONDS)</span><br><span class="line">                    .cache(cache)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return mOkHttpClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在lib-common中新建ServiceGenerate类管理、创建Retrofit接口访问实例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_SERVICE = <span class="string">"http://xxxx:8080/api/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在gson中加入时间格式化，DateDeserializer\DateSerializer为自定义转换类.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Gson gson = <span class="keyword">new</span> GsonBuilder()</span><br><span class="line">            .registerTypeAdapter(java.util.Date.class, <span class="keyword">new</span> DateDeserializer()).setDateFormat(DateFormat.LONG)</span><br><span class="line">            .registerTypeAdapter(java.util.Date.class, <span class="keyword">new</span> DateSerializer()).setDateFormat(DateFormat.LONG)</span><br><span class="line">            .create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * API Retrofit.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Retrofit apiGenerator = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">            .baseUrl(API_SERVICE)</span><br><span class="line">            <span class="comment">// 自定义转换器一定要在gsonConverter前面,否则gson会拦截所有的解析方式</span></span><br><span class="line">            .addConverterFactory(CustomConverterFactory.create())</span><br><span class="line">            <span class="comment">// Gson Converter</span></span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create(gson))</span><br><span class="line">            <span class="comment">// Callback Handler RxJava</span></span><br><span class="line">            .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">            .client(OkHttp3Util.getOkHttpClient())</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了统一处理Http接口返回，创建Response响应类，应当和后台接口保持一致的gson格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于Retrofit的登录Api如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface LoginApi &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * user login</span><br><span class="line">     *</span><br><span class="line">     * @param username username</span><br><span class="line">     * @param password password</span><br><span class="line">     * @return user info</span><br><span class="line">     */</span><br><span class="line">    @FormUrlEncoded</span><br><span class="line">    @POST(&quot;login&quot;)</span><br><span class="line">    Observable&lt;Response&lt;User&gt;&gt; loginStu(@Field(&quot;username&quot;) String username, @Field(&quot;password&quot;) String password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据库交互-GreenDao"><a href="#数据库交互-GreenDao" class="headerlink" title="数据库交互 - GreenDao"></a>数据库交互 - GreenDao</h4><p>使用J神家的的GreenDao，这个移动端ORM框架还是需要好好学习下的，本文仅介绍GrrenDao在MVP中的使用。在lib-db中创建DBHelper用于管理数据库连接和数据访问对象（Dao）实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DBHelper &#123;</span><br><span class="line"></span><br><span class="line">    ... instance init</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; AbstractDao getDao(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        return session.getDao(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h4><p>使用SP存储用户偏好设置或登录认证数据等碎片数据。</p><h4 id="LoginModel"><a href="#LoginModel" class="headerlink" title="LoginModel"></a>LoginModel</h4><p>Model中持有Retrofit实例（api）、数据库访问对象（Dao）以及SP等本地存储对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class LoginModel extends BaseModel &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG = &quot;LoginModel&quot;;</span><br><span class="line"></span><br><span class="line">    private LoginApi api;</span><br><span class="line">    private UserDao userDao;</span><br><span class="line">    private SharedPreferences userPreference;</span><br><span class="line"></span><br><span class="line">    public LoginModel() &#123;</span><br><span class="line">        // 使用ServiceGenerator生成api访问类</span><br><span class="line">        api = ServiceGenerator.createAPIService(LoginApi.class);</span><br><span class="line">        // 获取数据库访问对象</span><br><span class="line">        userDao = (UserDao) DBHelper.getInstance().getDao(User.class);</span><br><span class="line">        userPreference = context.getSharedPreferences(&quot;user&quot;, Context.MODE_PRIVATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUser(User user) &#123;</span><br><span class="line">        userPreference.put(&quot;user&quot;, user.getName());</span><br><span class="line">        userDao.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void login(String username, String password, Observer&lt;Response&lt;User&gt;&gt; observer) &#123;</span><br><span class="line">        rxSubscribe(api.login(username, password), observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Presenter调用LoginModel方法时传递接口参数和Observer，LoginModel接口请求响应后回调Observer，rxSubscribe()定义在BaseModel中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">rxSubscribe</span><span class="params">(Observable&lt;T&gt; observable, Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class="line">        observable.subscribeOn(Schedulers.io())</span><br><span class="line">                .subscribeOn(Schedulers.newThread())<span class="comment">//子线程访问网络</span></span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())<span class="comment">//回调到主线程</span></span><br><span class="line">                .subscribe(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Presenter层的设计"><a href="#2-2-Presenter层的设计" class="headerlink" title="2.2 Presenter层的设计"></a>2.2 Presenter层的设计</h3><p>Presenter持有Model实例，Presenter初始化时实例化Model，在lib-common中加入BasePresenter：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class BasePresenter&lt;TView extends BaseView, TModel extends BaseModel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    protected TView mView;</span><br><span class="line">    protected TModel mModel;</span><br><span class="line"></span><br><span class="line">    public BasePresenter(TView view) &#123;</span><br><span class="line">        this.mView = view;</span><br><span class="line">        this.mModel = this.getModel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract TModel getModel();</span><br><span class="line"></span><br><span class="line">    public void detach() &#123;</span><br><span class="line">        this.mView = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LoginPresenter集成BasePresenter，实例化LoginModel：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class LoginPresenter extends BasePresenter&lt;BaseActivity, LoginModel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public LoginPresenter(BaseActivity activity) &#123;</span><br><span class="line">        super(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected LoginModel getModel() &#123;</span><br><span class="line">        return new LoginModel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void login(String username, String password) &#123;</span><br><span class="line">        // 请求前 加载等待框</span><br><span class="line">        mView.loadHud();</span><br><span class="line">        mModel.loginStudent(username, password, new Observer&lt;Response&lt;User&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onCompleted() &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Response&lt;User&gt; response) &#123;</span><br><span class="line">                // 加载完成  取消等待框</span><br><span class="line">                mView.cancelHud();</span><br><span class="line"></span><br><span class="line">                if (response.OK()) &#123;</span><br><span class="line">                    // 请求成功 回调VIew层进行页面刷新</span><br><span class="line">            mView.onViewEvent(BaseView.VIEW_LOADED, response.getData());</span><br><span class="line">                    // 把用户信息保存在本地</span><br><span class="line">                    mModel.setUser(user);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">                    // 请求失败 回调View层报错</span><br><span class="line">            mView.onViewEvent(LoginActivity.ERROR, null);</span><br><span class="line">        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本项目在MVP中未使用接口的方式，在View中实现接口，在Presenter中持有实例并进行接口调用，因为使用接口则每个页面都需要新建一个接口类，较为繁琐。</p><p>本项目MVP使用BaseView中的抽象方法onViewEvent()，每个View继承BaseView后实现onViewEvent(int code, Object param)，Presenter层Attach BaseView后通过mView.onViewEvent()对View进行界面回调处理，View中根据事件code和参数param进行视图处理。</p><blockquote><p>一个Presenter可持有多个Model，定义多个Model对象并在Presenter构造函数中初始化。</p></blockquote><h3 id="2-3-View层的设计"><a href="#2-3-View层的设计" class="headerlink" title="2.3 View层的设计"></a>2.3 View层的设计</h3><p>在lib-common中定义BaseView，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toast</span><span class="params">(@StringRes <span class="keyword">int</span> resId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于Presenter中吐司提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">toast</span><span class="params">(String res)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T extends View&gt; <span class="function">T <span class="title">findViewById</span><span class="params">(@IdRes <span class="keyword">int</span> resId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于Presenter回调界面操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onViewEvent</span><span class="params">(<span class="keyword">int</span> code, Object param)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在界面中统一处理数据、网络异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onViewState</span><span class="params">(<span class="keyword">int</span> state)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onViewState</span><span class="params">(Response response)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载、取消Dialog</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadHud</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancelHud</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>toast（）：Toast封装，用于在Activity、Fragment或Presenter中弹出用户提示</li><li>findViewById()：主要用于fragment中获取元素使用（组件化开发使用ButterKnife较为繁琐，不建议使用）</li><li>onViewEvent()：View层的回调，用于Presenter网络请求响应后通知View层</li><li>onViewState()：View层的回调。当Presenter层发生错误时统一处理View（网络异常、Http请求错误等）</li><li>loadHud()/cancelHud()：加载ProgressDialog，Presenter发请网络请求时、请求结束后，在Presenter层弹出ProgressDialog</li></ul><h4 id="BaseActivity"><a href="#BaseActivity" class="headerlink" title="BaseActivity"></a>BaseActivity</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">public abstract class BaseActivity&lt;TPresenter extends BasePresenter&gt; extends AppCompatActivity implements BaseView &#123;</span><br><span class="line"></span><br><span class="line">    protected Handler mUIHandler;</span><br><span class="line"></span><br><span class="line">    protected TPresenter mPresenter;</span><br><span class="line"></span><br><span class="line">    protected KProgressHUD mHud;</span><br><span class="line">    </span><br><span class="line">    // 获取界面layout资源文件</span><br><span class="line">    @LayoutRes</span><br><span class="line">    protected abstract int getLayoutResId();</span><br><span class="line"></span><br><span class="line">    protected abstract void initViewAndData(@Nullable Bundle savedInstanceState);</span><br><span class="line"></span><br><span class="line">    protected abstract TPresenter getPresenter();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        beforeCreate();</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        beforeSetContentView();</span><br><span class="line">        setContentView(this.getLayoutResId());</span><br><span class="line">        // init</span><br><span class="line">        this.init();</span><br><span class="line">        this.initViewAndData(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        // EventBus</span><br><span class="line">        EventBus.getDefault().register(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * before set contentView</span><br><span class="line">     */</span><br><span class="line">    private void beforeSetContentView() &#123;</span><br><span class="line">        // NoTitle</span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        // ScreenPortrait</span><br><span class="line">        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * before create</span><br><span class="line">     */</span><br><span class="line">    private void beforeCreate() &#123;</span><br><span class="line">        // 统一设置主题</span><br><span class="line">        setTheme(UIConfig.getInstance(getApplicationContext()).getThemeId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Subscribe(threadMode = ThreadMode.MAIN)</span><br><span class="line">    public void onEventMainThread(CommonEvent event) &#123;</span><br><span class="line">        // EventBus统一处理全局异常</span><br><span class="line">        BLog.e(&quot;[Event]: &quot; + event.code);</span><br><span class="line">        if (event.code == CommonEvent.Type.NETWORK_ERROR) &#123;</span><br><span class="line">            onViewState(UIConstants.ViewState.NETWORK_DISCONNECTED);</span><br><span class="line">            if (this.mCommonEvent != null) &#123;</span><br><span class="line">                this.mCommonEvent.onCommonEvent(event.code, event.param);</span><br><span class="line">            &#125;</span><br><span class="line">            // cancel loading hud</span><br><span class="line">            cancelHud();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * init view, e.g commonTitleBar.</span><br><span class="line">     */</span><br><span class="line">    private void init() &#123;</span><br><span class="line">        // view init</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        // 从子类拿到Presenter实例</span><br><span class="line">        this.mPresenter = this.getPresenter();</span><br><span class="line">        // 使用第三方库作为Loading Dialog</span><br><span class="line">        this.mHud = KProgressHUD.create(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onViewState(int state) &#123;</span><br><span class="line">        // 全局异常处理</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onViewState(Response response) &#123;</span><br><span class="line">        // 根据Response处理服务器http响应</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line"></span><br><span class="line">        this.mUIHandler = null;</span><br><span class="line">        // Unregister EventBus</span><br><span class="line">        EventBus.getDefault().unregister(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T extends View&gt; T findViewById(int resId) &#123;</span><br><span class="line">        return super.findViewById(resId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void toast(@StringRes final int resId) &#123;</span><br><span class="line">        if (mUIHandler == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mUIHandler.post(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Toast.makeText(</span><br><span class="line">                        getApplicationContext(),</span><br><span class="line">                        resId,</span><br><span class="line">                        Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void toast(final String res) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void loadHud(int resId) &#123;</span><br><span class="line">        // 加载等待Dialog</span><br><span class="line">        if (mHud == null) &#123;</span><br><span class="line">            mHud = KProgressHUD.create(this);</span><br><span class="line">        &#125;</span><br><span class="line">        mHud.setStyle(KProgressHUD.Style.SPIN_INDETERMINATE)</span><br><span class="line">                .setCancellable(true)</span><br><span class="line">                .setLabel(resId == 0 ? getString(R.string.opt_loading) : getString(resId))</span><br><span class="line">                .setAnimationSpeed(1)</span><br><span class="line">                .setDimAmount(0.5f)</span><br><span class="line">                .show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void cancelHud() &#123;</span><br><span class="line">        if (mHud != null) &#123;</span><br><span class="line">            mHud.dismiss();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>loadHud()：参考第三方库<a href="https://github.com/Kaopiz/KProgressHUD" target="_blank" rel="noopener">https://github.com/Kaopiz/KProgressHUD</a></li></ul><h4 id="BaseFragment"><a href="#BaseFragment" class="headerlink" title="BaseFragment"></a>BaseFragment</h4><p>类似BaseActivity，加入一些对宿主Activity的回调。</p><p>参考<a href="https://github.com/blackist/modulize/blob/8478eb2a4bdaf7b9f9e2022be0e9462ea82b3eeb/lib-common/src/main/java/org/blackist/common/base/BaseFragment.java" target="_blank" rel="noopener">https://github.com/blackist/modulize/blob/8478eb2a4bdaf7b9f9e2022be0e9462ea82b3eeb/lib-common/src/main/java/org/blackist/common/base/BaseFragment.java</a></p><h4 id="LoginActivity"><a href="#LoginActivity" class="headerlink" title="LoginActivity"></a>LoginActivity</h4><p>LoginActivity继承自BaseActivity，实例化LoginPresenter，实现onViewEvent()回调函数：</p><pre><code>public class LoginActivity extends BaseActivity&lt;LoginPresenter&gt; implements View.OnClickListener {    private static final String TAG = &quot;LoginActivity&quot;;    public static final int ERROR = 1000;    @Override    protected int getLayoutResId() {        return R.layout.main_login_activity;    }    @Override    protected void initViewAndData(@Nullable Bundle savedInstanceState) {        initView();        ...    }    @Override    protected LoginPresenter getPresenter() {        return new LoginPresenter(this);    }    @Override    public void onClick(View v) {        ...    }    @Override    public void onViewEvent(int code, Object param) {        switch (code) {            case VIEW_LOADED: {                // 登录成功处理                ...                startActivity(new Intent(this, MainActivity.class));                finish();            }            break;            case ERROR: {                toast(R.string.main_login_error);            }            break;            default:        }    }}</code></pre><blockquote><p>通常情况下一个View对应一个Presenter，也可在View中定义多个Presenter对象并在initViewAndData()中初始化</p></blockquote><p>至此，实现了精简版的Android MVP，本人用在项目开发中问题不大。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000003927200" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003927200</a></p><p><a href="https://juejin.im/post/5a61559051882573351a5fb6" target="_blank" rel="noopener">https://juejin.im/post/5a61559051882573351a5fb6</a></p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Anroid MVP是安卓开发中一个经典的话题，当项目较大、参与的开发人员较多，MVP的优势就体现出来了。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://blackist.org/categories/Android/"/>
    
    
      <category term="开发" scheme="https://blackist.org/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="android" scheme="https://blackist.org/tags/android/"/>
    
      <category term="组件化" scheme="https://blackist.org/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="MVP" scheme="https://blackist.org/tags/MVP/"/>
    
  </entry>
  
  <entry>
    <title>Android组件化-UI统一&amp;主题变色</title>
    <link href="https://blackist.org/2019/03/21/android-modulize-ui-theme/"/>
    <id>https://blackist.org/2019/03/21/android-modulize-ui-theme/</id>
    <published>2019-03-21T13:56:19.000Z</published>
    <updated>2019-06-16T09:47:35.122Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>客户端开发中UI设计极其重要，直接影响用户体验和App的品质；其次UI设计应做到样式、排版统一，简化布局文件，方便全局修改和维护。</p><a id="more"></a><blockquote><p><strong>系列文章</strong></p><p><a href="/2018/10/18/android-modulize-common/">Android组件化-基础框架搭建</a></p><p><a href="/2018/10/23/android-modulize-router/">Android组件化-组件间通信BRouter</a></p><p><a href="/2019/03/21/android-modulize-ui-theme/">Android组件化-风格统一&amp;主题变色</a></p><p><a href="/2019/03/31/android-modulize-mvp/">Android组件化-MVP设计模式</a></p></blockquote><h2 id="一、样式排版统一"><a href="#一、样式排版统一" class="headerlink" title="一、样式排版统一"></a>一、样式排版统一</h2><h3 id="1-1-共用style"><a href="#1-1-共用style" class="headerlink" title="1.1 共用style"></a>1.1 共用style</h3><h4 id="基础颜色表"><a href="#基础颜色表" class="headerlink" title="基础颜色表"></a>基础颜色表</h4><p>在values资源文件夹下添加文件colors.xml，加入常用的基础颜色值，使全局组件色调保持一致：</p><p><img src="http://pic.blackist.top/android-modulize-ui-common-style-color.png" alt="颜色表参考 https://stackoverflow.com/a/7323234/8945448"></p><p>除基础颜色，还可添加App主题色调，使得ActionBar、Tab等组件颜色和主题色保持一致：</p><p><img src="http://pic.blackist.top/android-modulize-ui-color-theme.png" alt="ActionBar TabBar等组件颜色"></p><p><img src="http://pic.blackist.top/android-modulize-ui-style-action-bar.png" alt="ActionBar TabBar"></p><h4 id="统一布局尺寸和文字大小"><a href="#统一布局尺寸和文字大小" class="headerlink" title="统一布局尺寸和文字大小"></a>统一布局尺寸和文字大小</h4><p>Android界面设计需要统一排版，如图标边距、文字大小、ListItem间隔等，在values资源文件夹下添加文件dimen.xml，添加统一的布局距离和文字大小：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"font_larger"</span>&gt;</span>22sp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"font_large"</span>&gt;</span>18sp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"font_normal"</span>&gt;</span>16sp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"font_small"</span>&gt;</span>14sp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"font_smaller"</span>&gt;</span>12sp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"font_smallest"</span>&gt;</span>10sp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"spacing_huge"</span>&gt;</span>40dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"spacing_larger"</span>&gt;</span>34dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"spacing_large"</span>&gt;</span>24dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"spacing_biger"</span>&gt;</span>20dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"spacing_big"</span>&gt;</span>18dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"spacing_normal"</span>&gt;</span>14dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"spacing_small"</span>&gt;</span>12dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"spacing_smaller"</span>&gt;</span>10dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"spacing_smallest"</span>&gt;</span>8dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"spacing_tiny"</span>&gt;</span>6dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"spacing_tinyer"</span>&gt;</span>4dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"spacing_tinyest"</span>&gt;</span>2dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"spacing_border"</span>&gt;</span>12dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>界面排版等的尺寸可以参考如下布局，</p><ul><li>菜单选项内边距、字体颜色、选中颜色、背景色、上线分割线</li><li>ListView中Item的外边距、图标尺寸、图标和内容的间距、内容区标题和内容的文字尺寸颜色、Item分割线</li><li>Tab菜单选项图标尺寸、文字尺寸、Item间隔、Item选中样式</li></ul><p><img src="http://pic.blackist.top/android-modulize-ui-layout-size.png" alt="布局尺寸"></p><h4 id="统一样式"><a href="#统一样式" class="headerlink" title="统一样式"></a>统一样式</h4><p>应用内组件的样式应保持统一，比如按钮、弹窗、菜单列表等，在values资源文件夹下定义styles.xml（或新建文件把样式分离出来，如style-btn.xml），方便全局修改。</p><p>如下在布局文件中添加几个按钮，无任何样式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/main_module_mine"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Mine"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/main_module_message"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Message"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/main_module_theme"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"@style/ButtonTheme"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Theme"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://pic.blackist.top/android-modulize-ui-common-style-button-normal.png" alt></p><p>现加入按钮字体、内边距、背景等样式，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/main_module_mine"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@drawable/theme_button_selector"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingBottom</span>=<span class="string">"@dimen/spacing_smallest"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingTop</span>=<span class="string">"@dimen/spacing_smallest"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Mine"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">"@color/white"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">"@dimen/font_normal"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>theme-button-selector.xml如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shape</span> <span class="attr">android:shape</span>=<span class="string">"rectangle"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"3dip"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">stroke</span> <span class="attr">android:width</span>=<span class="string">"1dip"</span> <span class="attr">android:color</span>=<span class="string">"@color/colorPrimary"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">gradient</span> <span class="attr">android:angle</span>=<span class="string">"-90"</span> <span class="attr">android:endColor</span>=<span class="string">"@color/colorPrimary"</span> <span class="attr">android:startColor</span>=<span class="string">"@color/colorPrimary"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_focused</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shape</span> <span class="attr">android:shape</span>=<span class="string">"rectangle"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"3dip"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">stroke</span> <span class="attr">android:width</span>=<span class="string">"1dip"</span> <span class="attr">android:color</span>=<span class="string">"@color/colorPrimary"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"@color/colorPrimaryDark"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">shape</span> <span class="attr">android:shape</span>=<span class="string">"rectangle"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"3dip"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">stroke</span> <span class="attr">android:width</span>=<span class="string">"1dip"</span> <span class="attr">android:color</span>=<span class="string">"@color/colorPrimary"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">gradient</span> <span class="attr">android:angle</span>=<span class="string">"-90"</span> <span class="attr">android:endColor</span>=<span class="string">"@color/colorPrimary"</span> <span class="attr">android:startColor</span>=<span class="string">"@color/colorPrimary"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加入统一的样式后，三个按钮好看些了^-^：</p><p><img src="http://pic.blackist.top/android-modulize-ui-common-style-button.png" alt></p><p>但布局文件也变得格外冗长，为减少重复的布局代码，抽离通用样式，在styles.xml添加如下元素：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"ButtonTheme"</span> <span class="attr">parent</span>=<span class="string">"@android:style/Widget.Button"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textSize"</span>&gt;</span>@dimen/font_normal<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textColor"</span>&gt;</span>@color/white<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_height"</span>&gt;</span>wrap_content<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_width"</span>&gt;</span>match_parent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:layout_margin"</span>&gt;</span>@dimen/spacing_tiny<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:paddingTop"</span>&gt;</span>@dimen/spacing_smallest<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:paddingBottom"</span>&gt;</span>@dimen/spacing_smallest<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:background"</span>&gt;</span>@drawable/theme_button_selector<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重新修改布局文件，三个按钮使用通用样式，代码简化了很多：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/main_module_mine"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"@style/ButtonTheme"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Mine"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/main_module_message"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"@style/ButtonTheme"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Message"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/main_module_theme"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"@style/ButtonTheme"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Theme"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="布局重用"><a href="#布局重用" class="headerlink" title="布局重用"></a>布局重用</h4><p>有些布局组件可在全局复用，例如自定义TitleBar、ActionBar，本项目<a href="https://github.com/blackist/modulize" target="_blank" rel="noopener">Modulize</a>使用<a href="https://github.com/wuhenzhizao/android-titlebar" target="_blank" rel="noopener">第三方库CommonTitleBar</a>作为标题栏布局，在layout资源文件夹中定义common_titlebar.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">merge</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.wuhenzhizao.titlebar.widget.CommonTitleBar</span> <span class="attr">xmlns:titlebar</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/titlebar"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">titlebar:centerTextColor</span>=<span class="string">"@color/white"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">titlebar:centerTextSize</span>=<span class="string">"@dimen/font_normal"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">titlebar:centerType</span>=<span class="string">"textView"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">titlebar:fillStatusBar</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">titlebar:leftImageResource</span>=<span class="string">"@drawable/common_transparent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">titlebar:leftType</span>=<span class="string">"imageButton"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">titlebar:rightType</span>=<span class="string">"imageButton"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">titlebar:showBottomLine</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">titlebar:statusBarColor</span>=<span class="string">"?attr/colorPrimaryDark"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">titlebar:titleBarColor</span>=<span class="string">"?attr/colorPrimary"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">merge</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在activity布局文件中使用include引入此布局，merge标签为了减少视图层级（详细使用参考<a href="https://blog.csdn.net/xyz_lmn/article/details/14524567" target="_blank" rel="noopener">Android抽象布局</a>）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/common_titlebar"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/main_module_mine"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">"?android:attr/buttonStyle"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"Mine"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>布局复用可以有效地统一标题栏风格，每个页面设置不同的标题和图标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commonTitleBar = findViewById(R.id.common_titlebar);</span><br><span class="line">commonTitleBar.getCenterTextView().setText(<span class="string">"标题栏"</span>);</span><br><span class="line">commonTitleBar.getRightImageButton().setImageResource(R.drawable.main_action_icon_user);</span><br></pre></td></tr></table></figure><p><img src="http://pic.blackist.top/android-modulize-ui-common-style-actionbar.png" alt="ActionBar"></p><h3 id="1-2-UI模块lib-ui"><a href="#1-2-UI模块lib-ui" class="headerlink" title="1.2 UI模块lib-ui"></a>1.2 UI模块lib-ui</h3><p>模块化开发应用模块之间不直接相互依赖，各模块之间内的样式不可直接被其他模块调用，因此有必要创建UI基础库，将公共样式放在UI库中。</p><p>按照<a href="/2018/10/18/android-modulize-common/">Android组件化-基础框架搭建</a>中基础库搭建方法，新建lib-ui存放公共样式和资源文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">├─res</span><br><span class="line">|  ├─values</span><br><span class="line">|  |   ├─colors.xml</span><br><span class="line">|  |   ├─dimens.xml</span><br><span class="line">|  |   ├─strings.xml</span><br><span class="line">|  |   ├─styles.xml</span><br><span class="line">|  |   └theme.xml</span><br><span class="line">|  ├─layout</span><br><span class="line">|  |   └common_titlebar.xml</span><br><span class="line">|  ├─drawable-xxxhdpi</span><br><span class="line">|  |        ├─action_bar_add.png</span><br><span class="line">|  ├─drawable-xxhdpi</span><br><span class="line">|  |        ├─action_bar_add.png</span><br><span class="line">|  ├─drawable-xhdpi</span><br><span class="line">|  |       ├─action_bar_add.png</span><br><span class="line">|  ├─drawable-mdpi</span><br><span class="line">|  |       ├─action_bar_add.png</span><br><span class="line">|  ├─drawable-hdpi</span><br><span class="line">|  |       ├─action_bar_add.png</span><br><span class="line">|  ├─drawable</span><br><span class="line">|  |    ├─common_transparent.xml</span><br><span class="line">|  |    └theme_button_selector.xml</span><br></pre></td></tr></table></figure><p>使lib-common依赖lib-ui，因此各应用模块就可以使用lib-ui中的公共样式。</p><h2 id="二、主题切换"><a href="#二、主题切换" class="headerlink" title="二、主题切换"></a>二、主题切换</h2><p>主题切换功能开发思路如下：</p><ul><li>根据上述布局风格统一原则配置两套主题</li><li>在Activity中为App设置主题</li><li>动态设置主题，主题设置立即生效</li><li>复杂的View组件随主题动态变化</li></ul><h3 id="2-1-主题配置"><a href="#2-1-主题配置" class="headerlink" title="2.1 主题配置"></a>2.1 主题配置</h3><h4 id="配置至少两个主题"><a href="#配置至少两个主题" class="headerlink" title="配置至少两个主题"></a>配置至少两个主题</h4><p>在lib-ui\src\main\res下添加两个资源文件theme-default.xml、theme-dark.xml，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├─values</span><br><span class="line">|   ├─theme-dark.xml</span><br><span class="line">|   ├─theme-default.xml</span><br><span class="line">|   └theme.xml</span><br></pre></td></tr></table></figure><p>在theme.xml添加主题父类，theme-default和theme-dark中分别定义两个主题继承theme中的父主题：</p><p>theme.xml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  Base application theme. --&gt;</span><br><span class="line">&lt;style name=&quot;AppBaseTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;</span><br><span class="line">    &lt;!--&lt;item name=&quot;android:background&quot;&gt;@drawable/main_background&lt;/item&gt;--&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>theme-default.xml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Default application theme. --&gt;</span><br><span class="line">&lt;style name=&quot;AppTheme&quot; parent=&quot;AppBaseTheme&quot;&gt;</span><br><span class="line">    &lt;!-- Customize your theme here. --&gt;</span><br><span class="line">    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;</span><br><span class="line">&lt;item name=&quot;android:windowBackground&quot;&gt;@color/light_gray&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:buttonStyle&quot;&gt;@style/ButtonTheme&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;color name=&quot;colorPrimary&quot;&gt;#289ff4&lt;/color&gt;</span><br><span class="line">&lt;color name=&quot;colorPrimaryDark&quot;&gt;#0b79b7&lt;/color&gt;</span><br><span class="line">&lt;color name=&quot;colorAccent&quot;&gt;@color/white&lt;/color&gt;</span><br><span class="line"></span><br><span class="line">&lt;style name=&quot;ButtonTheme&quot; parent=&quot;@android:style/Widget.Button&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:textSize&quot;&gt;@dimen/font_normal&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:textColor&quot;&gt;@color/white&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:layout_height&quot;&gt;wrap_content&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:layout_width&quot;&gt;match_parent&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:layout_margin&quot;&gt;@dimen/spacing_tiny&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:paddingTop&quot;&gt;@dimen/spacing_smallest&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:paddingBottom&quot;&gt;@dimen/spacing_smallest&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:background&quot;&gt;@drawable/theme_button_selector&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>theme-dark.xml:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Dark application theme. --&gt;</span><br><span class="line">&lt;style name=&quot;AppDarkTheme&quot; parent=&quot;AppBaseTheme&quot;&gt;</span><br><span class="line">    &lt;!-- Customize your theme here. --&gt;</span><br><span class="line">    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorDarkPrimary&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorDarkPrimaryDark&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorDarkAccent&lt;/item&gt;</span><br><span class="line">&lt;item name=&quot;android:windowBackground&quot;&gt;@color/colorDarkPrimary&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:buttonStyle&quot;&gt;@style/DarkButtonTheme&lt;/item&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;color name=&quot;colorDarkPrimary&quot;&gt;#222222&lt;/color&gt;</span><br><span class="line">&lt;color name=&quot;colorDarkPrimaryDark&quot;&gt;#333333&lt;/color&gt;</span><br><span class="line">&lt;color name=&quot;colorDarkAccent&quot;&gt;#333333&lt;/color&gt;</span><br><span class="line"></span><br><span class="line">&lt;style name=&quot;DarkButtonTheme&quot; parent=&quot;@android:style/Widget.Button&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:textSize&quot;&gt;@dimen/font_normal&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:textColor&quot;&gt;@color/white&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:layout_height&quot;&gt;wrap_content&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:layout_width&quot;&gt;match_parent&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:layout_margin&quot;&gt;@dimen/spacing_tiny&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:paddingTop&quot;&gt;@dimen/spacing_smallest&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:paddingBottom&quot;&gt;@dimen/spacing_smallest&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:background&quot;&gt;@drawable/theme_button_selector&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="配置的内容"><a href="#配置的内容" class="headerlink" title="配置的内容"></a>配置的内容</h4><p>主题配置中重要的配置项，参见Material Design的<a href="https://material.io/design/color/#color-theme-creation" target="_blank" rel="noopener">The Color System</a>：</p><ul><li>colorPrimary：基色，跨域整个App各个页面和组件最常用的颜色，常用于应用栏（Appbar）</li><li>colorPrimaryDark：重基色，一般为状态栏（Sytembar）的颜色，与应用栏形成对比色</li><li>colorAccent:着重色，各View被选中或突出显示时的颜色；Item或CardView的背景色</li><li>android:windowBackground：界面背景色</li><li>android:buttonStyle：按钮样式；其他组件样式也可全局定义</li></ul><p><img src="http://pic.blackist.top/android-modulize-ui-theme-color-system.png" alt="颜色系统"></p><p>各样式和value在activity布局文件中使用如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"?android:windowBackground"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">"org.blackist.modulize.main.view.MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/common_titlebar"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/main_module_mine"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">"?android:attr/buttonStyle"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Mine"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/main_module_message"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">"?android:attr/buttonStyle"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Message"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/main_module_theme"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">"?android:attr/buttonStyle"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Theme"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.CardView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_margin</span>=<span class="string">"@dimen/spacing_tiny"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"?attr/colorAccent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:padding</span>=<span class="string">"@dimen/spacing_tiny"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"?attr/colorAccent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"Use colorAccent \nAs \nItem Backgroud"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.v7.widget.CardView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为页面设置背景色，使用 <strong>background=”?android:windowBackground”</strong> 属性;</p><p>colorAccent用作List Item布局 或 局部布局的背景，当主题切换时Item背景随之切换，使用方式 <strong>background=”?attr/colorAccent”</strong>；</p><p>Button等组件的样式使用 <strong>style=”?android:attr/buttonStyle”</strong>设置；</p><p>本项目文字颜色自适应，即根据当前主题，安卓系统会自动设置字黑色或白色；</p><p>从 <strong>?android:windowBackground</strong> 和 <strong>?colorAccent</strong> 中可以看出，根据如下主题配置项配置方式，决定布局文件中使用这些属性的方式：</p><p><img src="http://pic.blackist.top/android-modulize-ui-theme-item.png" alt="主题配置项配置方式"></p><h3 id="2-2-主题切换"><a href="#2-2-主题切换" class="headerlink" title="2.2 主题切换"></a>2.2 主题切换</h3><p>使用SDK中的setTheme方法设置主题，设置主题需要在setContentView()之前调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    // before set ContentView</span><br><span class="line">    setTheme(mThemeDefault ? R.style.setTheme : R.style.AppTheme);</span><br><span class="line">    setContentView(R.layout.main_activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mThemeDefault为boolean类型的值，存储在SharedPreference中，App启动时读取其值使得App记住用户偏好。</p><p>切换后的主题如下：                    </p><p><img src="http://pic.blackist.top/android-modulize-ui-theme-dark_.jpg" alt></p><h4 id="2-3-主题动态切换"><a href="#2-3-主题动态切换" class="headerlink" title="2.3 主题动态切换"></a>2.3 主题动态切换</h4><p>当使用按钮或Switch触发主题设置后，视图已经创建，设置不能立即生效，需要重启App才能看到效果。想要立即生效则需要重建当前栈中所有activity，因此需要获取到所有已加载activity，使用lib-apptools下的AppManager工具类，在Activity的onCreate()中将自身加入Activity栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AppManager.getInstance().addActivity(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>在onDestory()中使activity出栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AppManager.getInstance().removeActivity(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>调用AppManager.getInstance().recreateAllActivity()方法重建栈中Activity，使得主题切换立即生效。</p><h2 id="三、组件主题"><a href="#三、组件主题" class="headerlink" title="三、组件主题"></a>三、组件主题</h2><p>配置某些组件跟随主题变换颜色等样式。</p><h3 id="3-1-AlertDialog"><a href="#3-1-AlertDialog" class="headerlink" title="3.1 AlertDialog"></a>3.1 AlertDialog</h3><p>配置Dialog的默认样式类似于Button的全局样式，但稍加复杂一些。</p><p>在theme-default.xml中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Default application theme. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"AppBaseTheme"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"alertDialogTheme"</span>&gt;</span>@style/AlertDialog<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AlertDialog"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.Dialog.Alert"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowTitleStyle"</span>&gt;</span>@style/AlertDialogTitle<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>@color/colorPrimary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:background"</span>&gt;</span>@color/colorAccent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AlertDialogTitle"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textAppearance"</span>&gt;</span>@style/AlertDialogTitleStyle<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AlertDialogTitleStyle"</span> <span class="attr">parent</span>=<span class="string">"@android:style/TextAppearance.Holo.DialogWindowTitle"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textSize"</span>&gt;</span>@dimen/font_normal<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textColor"</span>&gt;</span>@color/colorPrimary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>theme-dark.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Dark application theme. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppDarkTheme"</span> <span class="attr">parent</span>=<span class="string">"AppBaseTheme"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"alertDialogTheme"</span>&gt;</span>@style/DarkAlertDialog<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"DarkAlertDialog"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.Dialog.Alert"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowTitleStyle"</span>&gt;</span>@style/DarkAlertDialogTitle<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>@color/text_hint<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:background"</span>&gt;</span>@color/colorDarkAccent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"DarkAlertDialogTitle"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textAppearance"</span>&gt;</span>@style/DarkAlertDialogTitleStyle<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"DarkAlertDialogTitleStyle"</span> <span class="attr">parent</span>=<span class="string">"@android:style/TextAppearance.Holo.DialogWindowTitle"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textSize"</span>&gt;</span>@dimen/font_normal<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:textColor"</span>&gt;</span>@color/text_hint<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Activity中new AlertDialog即可，无需多余的样式设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mTypeDialog = <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>)</span><br><span class="line">    .setIcon(R.mipmap.ic_launcher_round)</span><br><span class="line">    .setTitle(<span class="string">"AlertDialog Theme"</span>)</span><br><span class="line">    .setNegativeButton(<span class="string">"Cancel"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">            dialog.dismiss();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .setPositiveButton(<span class="string">"Confirm"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">            dialog.dismiss();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).create();</span><br><span class="line">mTypeDialog.show();</span><br></pre></td></tr></table></figure><p><img src="http://pic.blackist.top/android-modulize-ui-theme-alertdialog-nal.png" alt></p><p>切换主题后，AlertDialog样式随之变化：</p><p><img src="http://pic.blackist.top/android-modulize-ui-theme-alertdialog.png" alt></p><h3 id="3-2-获取当前主题属性"><a href="#3-2-获取当前主题属性" class="headerlink" title="3.2 获取当前主题属性"></a>3.2 获取当前主题属性</h3><p>在某些自定义组件中需要获取App主题色，比如在AlertDialog中添加一个轮滑选择器，自定义组件Whiew（在lib-ui\src\main\java\org\blackist\modulize\ui\widget\whiew下），当设置文本时需要获取当前主题的相关属性来设置样式。</p><h4 id="获取Color"><a href="#获取Color" class="headerlink" title="获取Color"></a>获取Color</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TypedValue typedValue = new TypedValue();</span><br><span class="line">Theme theme = context.getTheme();</span><br><span class="line">theme.resolveAttribute(R.attr.colorPrimary, typedValue, true);</span><br><span class="line">@ColorInt int color = typedValue.data;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="获取Dimen"><a href="#获取Dimen" class="headerlink" title="获取Dimen"></a>获取Dimen</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tv.setTextSize(TypedValue.COMPLEX_UNIT_PX, context.getResources().getDimensionPixelSize(R.dimen.font_normal));</span><br></pre></td></tr></table></figure><p><img src="http://pic.blackist.top/android-modulize-ui-theme-prop.png" alt></p><hr><p>项目Github地址：<a href="https://github.com/blackist/modulize" target="_blank" rel="noopener">https://github.com/blackist/modulize</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.25xt.com/android" target="_blank" rel="noopener">https://www.25xt.com/android</a></p><p><a href="https://blog.csdn.net/xyz_lmn/article/details/14524567" target="_blank" rel="noopener">https://blog.csdn.net/xyz_lmn/article/details/14524567</a></p><p><a href="https://material.io/design/color/#color-theme-creation" target="_blank" rel="noopener">https://material.io/design/color/#color-theme-creation</a></p><p><a href="https://stackoverflow.com/questions/29797134/how-to-use-and-style-new-alertdialog-from-appcompat-22-1-and-above" target="_blank" rel="noopener">https://stackoverflow.com/questions/29797134/how-to-use-and-style-new-alertdialog-from-appcompat-22-1-and-above</a></p><p><a href="https://stackoverflow.com/questions/17277618/get-color-value-programmatically-when-its-a-reference-theme" target="_blank" rel="noopener">https://stackoverflow.com/questions/17277618/get-color-value-programmatically-when-its-a-reference-theme</a></p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;客户端开发中UI设计极其重要，直接影响用户体验和App的品质；其次UI设计应做到样式、排版统一，简化布局文件，方便全局修改和维护。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://blackist.org/categories/Android/"/>
    
    
      <category term="开发" scheme="https://blackist.org/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="android" scheme="https://blackist.org/tags/android/"/>
    
      <category term="UI" scheme="https://blackist.org/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>校友录-网站样式设计</title>
    <link href="https://blackist.org/2019/03/14/javaweb-ar-style/"/>
    <id>https://blackist.org/2019/03/14/javaweb-ar-style/</id>
    <published>2019-03-14T11:22:46.000Z</published>
    <updated>2019-06-29T13:53:20.088Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://github.com/blackist/ar" target="_blank" rel="noopener">校友录</a>项目网站样式设计简要说明。</p><a id="more"></a><h2 id="一、门户网站"><a href="#一、门户网站" class="headerlink" title="一、门户网站"></a>一、门户网站</h2><h3 id="1-1-首页轮播图"><a href="#1-1-首页轮播图" class="headerlink" title="1.1 首页轮播图"></a>1.1 首页轮播图</h3><p>在 ar-parent\ar-portal\src\main\webapp\WEB-INF\views\portal-main\index.jsp 中有如下代码：</p><p><img src="http://pic.blackist.top/spring-ar-style-portal-index.png" alt></p><p>div.carousel中即使首页的轮播图，图片暂不支持后台手动设置，需要存放在 assets/images/school/ 下或assets其它文件夹下面。</p><p>图片尺寸建议采用2600x720的。</p><h3 id="1-2-导航栏样式"><a href="#1-2-导航栏样式" class="headerlink" title="1.2 导航栏样式"></a>1.2 导航栏样式</h3><p>导航栏由两部分组成：</p><p><img src="http://pic.blackist.top/spring-ar-style-portal-index-header.png" alt></p><p>上面的header，下面的是导航菜单(nav)，这两部分在index.jsp中通过include引入，分别位于 WEB-INF/views/portal-common/header.jsp 和 WEB-INF/views/portal-common/navmenu.jsp。门户网站主要样式在 assets/css/style.css 中定义。</p><h4 id="Header样式"><a href="#Header样式" class="headerlink" title="Header样式"></a>Header样式</h4><p>在style.css中搜索 .top_bg，找到如下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-- header_top --*/</span></span><br><span class="line"><span class="selector-class">.top_bg</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#666666</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>background就是header的背景色。</p><h4 id="Nav样式"><a href="#Nav样式" class="headerlink" title="Nav样式"></a>Nav样式</h4><p>在style.css中搜索 .mega_nav，找到如下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mega_nav</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line"><span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">6px</span> <span class="number">5px</span> <span class="number">#CCCBCB</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改background改变Nav整个背景色。Nav中菜单项的颜色在 assets/css/megamenu.css 中定义，找到如下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.skyblue</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span><span class="selector-class">.color1</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line"><span class="attribute">background</span>:<span class="number">#204056</span>;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可修改菜单项hover的样式，菜单项背景色等可以自行探索。</p><p>修改后导航栏后整体样式如下（一不小心破相了~）：</p><p><img src="http://pic.blackist.top/spring-ar-style-portal-index-style.png" alt></p><h3 id="1-3-表单样式"><a href="#1-3-表单样式" class="headerlink" title="1.3 表单样式"></a>1.3 表单样式</h3><p>门户网站表单组件绝大部分使用bootstrap样式：</p><p><img src="http://pic.blackist.top/spring-ar-style-portal-profile.png" alt></p><p>可根据bootstrap修改按钮等组件样式，本项目参考了一份模板进行设计，整个模板素材存在 ar\ar-tools\model-portal\Bracket1.5\ 下。</p><p>表单样式：</p><p><img src="http://pic.blackist.top/spring-ar-style-portal-bootstrap.png" alt></p><p>按钮样式：</p><p><img src="http://pic.blackist.top/spring-ar-style-portal-bootstrap-button.png" alt></p><p>表格及分页器：</p><p><img src="http://pic.blackist.top/spring-ar-style-portal-bootstrap-pager.png" alt></p><p>门户网站风格和此模板素材基本保持一致，可参考修改。</p><h2 id="二、后台管理"><a href="#二、后台管理" class="headerlink" title="二、后台管理"></a>二、后台管理</h2><p>后台管理网站样式主要定义在 ar-manage\src\main\webapp\assets\css\admin.css 下。</p><h3 id="1-1-首页样式"><a href="#1-1-首页样式" class="headerlink" title="1.1 首页样式"></a>1.1 首页样式</h3><h4 id="管理页主题title"><a href="#管理页主题title" class="headerlink" title="管理页主题title"></a>管理页主题title</h4><p><img src="http://pic.blackist.top/spring-ar-style-manage-index-header.png" alt></p><p>在 WEB-INF/views/main/index.jsp 中搜索如下代码，修改此处即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 导航 --&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"am-topbar-brand"</span>&gt;</span><br><span class="line">    &lt;strong&gt;信电校友录&lt;/strong&gt;</span><br><span class="line">    &lt;small&gt;后台管理&lt;/small&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="页脚"><a href="#页脚" class="headerlink" title="页脚"></a>页脚</h4><p><img src="http://pic.blackist.top/spring-ar-style-manage-index-footer.png" alt></p><p>在 WEB-INF/views/global/footer.jsp 中修改即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"am-padding-left"</span>&gt;</span><br><span class="line">CopyRight © 2015 . &lt;a href="#" target="_blank"&gt;徐州工程学院信电学院&lt;/a&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/footer&gt;</span><br></pre></td></tr></table></figure><h4 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h4><p><img src="http://pic.blackist.top/spring-ar-style-manage-index-sidebar.png" alt></p><p>在 WEB-INF/views/global/sidebar.jsp 中修改即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 公告 bookmark --&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"am-panel am-panel-default admin-sidebar-panel"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"am-panel-bd"</span>&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;span class="am-icon-bookmark"&gt;&lt;/span&gt; 公告</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p&gt;时光静好，与君语；细水流年，与君同。—— 信电校友录&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 社群 wiki --&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"am-panel am-panel-default admin-sidebar-panel"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"am-panel-bd"</span>&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;span class="am-icon-tag"&gt;&lt;/span&gt; 社群</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p&gt;欢迎来到信电校友录后台管理!&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="1-2-表单样式等"><a href="#1-2-表单样式等" class="headerlink" title="1.2 表单样式等"></a>1.2 表单样式等</h3><p>后台管理网站整站风格参考一套AmazeUI素材，素材存在 ar\ar-tools\model-admin\ 下，</p><p><img src="http://pic.blackist.top/spring-ar-style-manage-amazeui.png" alt></p><p><img src="http://pic.blackist.top/spring-ar-style-manage-amazeui-form.png" alt></p><p>按钮等组件样式可参考<a href="http://amazeui.org/" target="_blank" rel="noopener">Amaze官网</a>：</p><p><img src="http://pic.blackist.top/spring-ar-style-manage-amazeui-website.png" alt></p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/blackist/ar&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;校友录&lt;/a&gt;项目网站样式设计简要说明。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="https://blackist.org/categories/JavaWeb/"/>
    
    
      <category term="开发" scheme="https://blackist.org/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaweb" scheme="https://blackist.org/tags/javaweb/"/>
    
      <category term="开源" scheme="https://blackist.org/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="校友录" scheme="https://blackist.org/tags/%E6%A0%A1%E5%8F%8B%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Android测试-Monkey Test</title>
    <link href="https://blackist.org/2019/03/13/android-test-monkey-test/"/>
    <id>https://blackist.org/2019/03/13/android-test-monkey-test/</id>
    <published>2019-03-13T01:36:24.000Z</published>
    <updated>2019-06-16T09:47:35.122Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>APP开发过程中，开人员往往自己做一些功能测试和稳定性测试，使用MonkeyTest做<strong>压力测试</strong>是常用方法，及时修复ANR、CRASH提高项目组整体的开发效率。</p><a id="more"></a><h2 id="一、Monkey简介"><a href="#一、Monkey简介" class="headerlink" title="一、Monkey简介"></a>一、Monkey简介</h2><p>Monkey是一种命令行工具，向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，这个工具存在于Android系统/system/framework/monkey.jar，Android设备/模拟器连接到PC后通过adb shell使用此工具，monkey测试流程如下。</p><p><img src="http://pic.blackist.top/android-test-monkey-framework.png" alt="monkey架构"></p><p>因此两种方式使用monkey，第一种在PC端直接运行命令行：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey --[params]</span><br></pre></td></tr></table></figure><p>第二种进入shell中使用：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">&gt; shell@android: monkey --[params]</span><br></pre></td></tr></table></figure><h2 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h2><p>使用如下命令进行monkey测试：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p org.blackist.modulize --throttle <span class="number">100</span> -v -v <span class="number">100</span> &gt; test.log</span><br></pre></td></tr></table></figure><ul><li>-p org.blackist.modulize：测试包名为org.blackist.modulize</li><li>–throttle 100：每100ms发送一次事件</li><li>-v -v：指定日志级别</li><li>> test.log：输出日志到文件</li></ul><p>如下是monkey日志中测试到的ANR和CRASH：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Sleeping for 100 milliseconds</span><br><span class="line">:Sending Key (ACTION_DOWN): 23    // KEYCODE_DPAD_CENTER</span><br><span class="line">// CRASH: cn.edu.zstu.sdmp (pid 17698)</span><br><span class="line">// Short Msg: java.lang.NullPointerException</span><br><span class="line">// Long Msg: java.lang.NullPointerException: Attempt to invoke virtual method &apos;com.wuhenzhizao.titlebar.widget.CommonTitleBar cn.edu.zstu.sdmp.manage.view.ManageActivity.getCommonTitle()&apos; on a null object reference</span><br><span class="line">// Build Label: vivo/PD1603/PD1603:5.1.1/LMY47V/compiler07131528:user/release-keys</span><br><span class="line">// Build Changelist: eng.compiler.20180713.152451</span><br><span class="line">// Build Time: 1531466945000</span><br><span class="line">// java.lang.NullPointerException: Attempt to invoke virtual method &apos;com.wuhenzhizao.titlebar.widget.CommonTitleBar cn.edu.zstu.sdmp.manage.view.ManageActivity.getCommonTitle()&apos; on a null object reference</span><br><span class="line">//      at cn.edu.zstu.sdmp.manage.view.repair.RepairDetailFragment.initView(RepairDetailFragment.java:153)</span><br><span class="line">//      at cn.edu.zstu.sdmp.manage.view.repair.RepairDetailFragment.initViewAndData(RepairDetailFragment.java:113)</span><br><span class="line">//      at cn.edu.zstu.sdmp.common.base.BaseFragment.onCreateView(BaseFragment.java:135)</span><br><span class="line">//      at android.support.v4.app.Fragment.performCreateView(Fragment.java:2354)</span><br><span class="line">//      at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:1419)</span><br><span class="line">//      at android.support.v4.app.FragmentManagerImpl.moveFragmentToExpectedState(FragmentManager.java:1740)</span><br><span class="line">//      at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:1809)</span><br><span class="line">//      at android.support.v4.app.BackStackRecord.executeOps(BackStackRecord.java:799)</span><br><span class="line">//      at android.support.v4.app.FragmentManagerImpl.executeOps(FragmentManager.java:2580)</span><br><span class="line">//      at android.support.v4.app.FragmentManagerImpl.executeOpsTogether(FragmentManager.java:2367)</span><br><span class="line">//      at android.support.v4.app.FragmentManagerImpl.removeRedundantOperationsAndExecute(FragmentManager.java:2322)</span><br><span class="line">//      at android.support.v4.app.FragmentManagerImpl.execPendingActions(FragmentManager.java:2229)</span><br><span class="line">//      at android.support.v4.app.FragmentManagerImpl$1.run(FragmentManager.java:700)</span><br><span class="line">//      at android.os.Handler.handleCallback(Handler.java:739)</span><br><span class="line">//      at android.os.Handler.dispatchMessage(Handler.java:95)</span><br><span class="line">//      at android.os.Looper.loop(Looper.java:135)</span><br><span class="line">//      at android.app.ActivityThread.main(ActivityThread.java:5418)</span><br><span class="line">//      at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">//      at java.lang.reflect.Method.invoke(Method.java:372)</span><br><span class="line">//      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1037)</span><br><span class="line">//      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:832)</span><br><span class="line">//</span><br><span class="line">// NOT RESPONDING: cn.edu.zstu.sdmp (pid 17698)</span><br><span class="line">ANR in cn.edu.zstu.sdmp (cn.edu.zstu.sdmp/.manage.view.ManageActivity)</span><br><span class="line">PID: 17698</span><br><span class="line">Reason: Input dispatching timed out (Waiting to send key event because the focused window has not finished processing all of the input events that were previously delivered to it.  Outbound queue length: 0.  Wait queue length: 1.)</span><br></pre></td></tr></table></figure><p>可以清楚分析出错误所在的地方，所以monkey是个物美价廉的测试工具啊~</p><h2 id="三、参数说明"><a href="#三、参数说明" class="headerlink" title="三、参数说明"></a>三、参数说明</h2><p>monkey工具参数如下（图片<a href="https://www.cnblogs.com/TankXiao/p/4815134.html" target="_blank" rel="noopener">来源</a>）：</p><p><img src="http://pic.blackist.top/android-test-monkey-params.png" alt="monkey参数"></p><h3 id="3-1-基础参数"><a href="#3-1-基础参数" class="headerlink" title="3.1 基础参数"></a>3.1 基础参数</h3><h4 id="p-lt-允许的包名列表-gt"><a href="#p-lt-允许的包名列表-gt" class="headerlink" title="-p &lt;允许的包名列表&gt;"></a>-p &lt;允许的包名列表&gt;</h4><p>用此参数指定一个或多个包。指定包之后，monkey将只允许系统启动指定的app。如果不指定包， monkey将允许系统启动设备中的所有app。  </p><p>指定一个包：adb shell monkey -p org.blackist.modulize 100   </p><p>指定多个包：adb shell monkey -p org.blackist.modulize  –p org.blackist.brouter  100</p><h4 id="v"><a href="#v" class="headerlink" title="-v"></a>-v</h4><p>用亍指定反馈信息级别（信息级别就是日志的详细程度），总共分3个级别，分别对应的参数如下： </p><p>Level 0  :  adb shell monkey -p org.blackist.modulize -v 100         // 缺省值，仅提供启动提示、测试完成和最终结果等少量信息   </p><p>Level 1  :  adb shell monkey -p org.blackist.modulize -v  -v 100     // 提供较为详细的日志，包括每个发送到Activity的事件信息</p><p>Level 2  :  adb shell monkey -p org.blackist.modulize -v  -v  -v 100 // 最详细的日志，包括了测试中选中/未选中的Activity信息</p><p>一般来说，使用Level0即可。</p><h4 id="s-随机数种子"><a href="#s-随机数种子" class="headerlink" title="-s  (随机数种子)"></a>-s <seed> (随机数种子)</seed></h4><p>用亍指定伪随机数生成器的seed值，如果seed相同，则两次Monkey测试所产生的事件序列也相同的。  示例：</p><p>monkey测试1：adb shell monkey -p org.blackist.modulize –s 101 100                </p><p>monkey测试2：adb shell monkey -p org.blackist.modulize –s 101 100 </p><p>这个参数其实比较重要，比如我们只看日志不容易确定错误位置，需要结合monkey的UI测试过程，这时需要执行相同的随机序列复现步骤。</p><h4 id="–throttle-延时ms"><a href="#–throttle-延时ms" class="headerlink" title="–throttle  (延时ms)"></a>–throttle <delay> (延时ms)</delay></h4><p>用亍指定用户操作（即事件）间的时延，单位是毫秒；如果不指定这个参数，monkey会尽可能快地生成和发送消息。 示例：</p><p>adb shell monkey -p org.blackist.modulize –throttle 3000 100   </p><h3 id="3-2-发送的事件类型"><a href="#3-2-发送的事件类型" class="headerlink" title="3.2 发送的事件类型"></a>3.2 发送的事件类型</h3><p>–pct-touch <percent> （点击事件）</percent></p><p>参数percent为此事件的百分比，比如要求monkey完成10次点击事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey -p org.blackist.modulize -v --pct-touch 100 10</span><br></pre></td></tr></table></figure><p>可以看到如下日志，Event percentages是事件百分比，点击事件100%，其余都是0：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">:Monkey: seed=<span class="number">1552849997195</span> count=<span class="number">10</span></span><br><span class="line">:AllowPackage: cn.edu.zstu.sdmp</span><br><span class="line">:IncludeCategory: android.intent.category.LAUNCHER</span><br><span class="line">:IncludeCategory: android.intent.category.MONKEY</span><br><span class="line">// Event percentages:</span><br><span class="line">//   <span class="number">0</span>: <span class="number">100</span>.<span class="number">0</span>%</span><br><span class="line">//   <span class="number">1</span>: <span class="number">0</span>.<span class="number">0</span>%</span><br><span class="line">//   <span class="number">2</span>: <span class="number">0</span>.<span class="number">0</span>%</span><br><span class="line">//   <span class="number">3</span>: <span class="number">0</span>.<span class="number">0</span>%</span><br><span class="line">//   <span class="number">4</span>: -<span class="number">0</span>.<span class="number">0</span>%</span><br><span class="line">//   <span class="number">5</span>: <span class="number">0</span>.<span class="number">0</span>%</span><br><span class="line">//   <span class="number">6</span>: <span class="number">0</span>.<span class="number">0</span>%</span><br><span class="line">//   <span class="number">7</span>: <span class="number">0</span>.<span class="number">0</span>%</span><br><span class="line">//   <span class="number">8</span>: <span class="number">0</span>.<span class="number">0</span>%</span><br><span class="line">//   <span class="number">9</span>: <span class="number">0</span>.<span class="number">0</span>%</span><br><span class="line">//   <span class="number">10</span>: <span class="number">0</span>.<span class="number">0</span>%</span><br><span class="line">:Switch: #Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=<span class="number">0</span>x10200000;component=cn.edu.zstu.sdmp/.main.view.SplashActivity;end</span><br><span class="line">    // Allowing <span class="built_in">start</span> of Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=cn.edu.zstu.sdmp/.main.view.SplashActivity &#125; <span class="keyword">in</span> package cn.edu.zstu.sdmp</span><br></pre></td></tr></table></figure><p>–pct-motion <percent> （动作事件）</percent></p><p>–pct-trackball <percent> （轨迹球事件）</percent></p><p>–pct-nav <percent> （基本导航事件，输入设备的上、下、左、右）</percent></p><p>–pct-majornav <percent> （主要导航事件，兼容中间键，返回键，菜单按键）</percent></p><p>–pct-syskeys <percent> （系统导航事件，HOME、BACK及拨号音量键）</percent></p><p>–pct-appswitch <percent> （启动App事件）</percent></p><p>–pct-anyevent <percnet> (不常用事件)</percnet></p><p>–ignore-crashes （忽略崩溃事件 CRASH）</p><p>–ignore-timeouts （忽略超时事件 ANR）</p><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><p>monkey test 执行后分析保存的日志，可以搜索CRASH、ANR、Exception等关键字查看错误信息，详细的日志分析参考<a href="http://www.cnblogs.com/wfh1988/archive/2010/11/16/1878224.html" target="_blank" rel="noopener">http://www.cnblogs.com/wfh1988/archive/2010/11/16/1878224.html</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yuti.site/2019/03/02/MonkeyTesting/?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">https://yuti.site/2019/03/02/MonkeyTesting/?tdsourcetag=s_pctim_aiomsg</a></p><p><a href="https://www.cnblogs.com/TankXiao/p/4815134.html" target="_blank" rel="noopener">https://www.cnblogs.com/TankXiao/p/4815134.html</a></p><p><a href="https://blog.csdn.net/gzh0222/article/details/6631988" target="_blank" rel="noopener">https://blog.csdn.net/gzh0222/article/details/6631988</a></p><p><a href="https://blog.csdn.net/viewsky11/article/details/53889143" target="_blank" rel="noopener">https://blog.csdn.net/viewsky11/article/details/53889143</a></p><p><a href="https://www.cnblogs.com/TankXiao/p/4815134.html" target="_blank" rel="noopener">https://www.cnblogs.com/TankXiao/p/4815134.html</a></p><p><a href="https://blog.csdn.net/MTbaby/article/details/78792215" target="_blank" rel="noopener">https://blog.csdn.net/MTbaby/article/details/78792215</a></p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;APP开发过程中，开人员往往自己做一些功能测试和稳定性测试，使用MonkeyTest做&lt;strong&gt;压力测试&lt;/strong&gt;是常用方法，及时修复ANR、CRASH提高项目组整体的开发效率。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://blackist.org/categories/Android/"/>
    
    
      <category term="开发" scheme="https://blackist.org/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="android" scheme="https://blackist.org/tags/android/"/>
    
      <category term="测试" scheme="https://blackist.org/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="monkey" scheme="https://blackist.org/tags/monkey/"/>
    
  </entry>
  
  <entry>
    <title>校友录-项目线上部署</title>
    <link href="https://blackist.org/2019/03/09/javaweb-ar-deploy-path/"/>
    <id>https://blackist.org/2019/03/09/javaweb-ar-deploy-path/</id>
    <published>2019-03-09T12:11:47.000Z</published>
    <updated>2019-06-29T13:53:20.088Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://github.com/blackist/ar" target="_blank" rel="noopener">校友录</a>作为一个具备门户网站服务、后台管理功能的完整项目，可以部署上线使用，线上部署需要注意些事项，本文就笔者的开发过程做个记录。</p><a id="more"></a><h2 id="一、项目编译"><a href="#一、项目编译" class="headerlink" title="一、项目编译"></a>一、项目编译</h2><p>校友录是基于maven构建的多模块项目，ar-parent是父模块，ar-common、ar-manage、ar-portal是子模块，ar-common中主要存放一些实体类、与数据库交互的Mapper文件以及一些基类和工具类，ar-manage、ar-portal皆依赖ar-common，在编译时需要首先编译ar-common并安装到本地，但其实编辑顺序maven可以自行判断，我们只需要执行编译命令即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├─ar-parent</span><br><span class="line">   ├─ar-common</span><br><span class="line">   ├─ar-manage</span><br><span class="line">   └─ar-portal</span><br></pre></td></tr></table></figure><p>校友录项目配置了maven编译插件<strong>maven-war-plugin</strong>，推荐在本地编译项目不建议在服务器构建，项目将以war包的形式部署到tomcat，在ar-parent目录下执行编译命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean &amp;&amp; mvn install &amp;&amp; mvn package</span><br></pre></td></tr></table></figure><p>编译完成后可看到如下日志：</p><p><img src="http://pic.blackist.top/spring-ar-deploy-path-compile-ok.png" alt="校友录构建"></p><p>构建好的ar-portal.war在ar-parent/ar-portal/target/目录下。</p><h2 id="二、服务器配置"><a href="#二、服务器配置" class="headerlink" title="二、服务器配置"></a>二、服务器配置</h2><p>本文以服务器Ubuntu16.04，JDK1.8，Tomcat8.5为例</p><h3 id="2-1-安装JDK1-8"><a href="#2-1-安装JDK1-8" class="headerlink" title="2.1 安装JDK1.8"></a>2.1 安装JDK1.8</h3><p>添加Oracle的PPA(Personal Package Archive)，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br></pre></td></tr></table></figure><p>添加完成后依次执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java8-installer</span><br></pre></td></tr></table></figure><p>安装成功后验证下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -version</span><br></pre></td></tr></table></figure><p>设置java的环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/environment</span><br></pre></td></tr></table></figure><p>文件末尾添加如下内容（替换自己的java路径）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=&quot;/usr/lib/jvm/java-8-oracle&quot;</span><br></pre></td></tr></table></figure></p><p>最后重载环境变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source /etc/environment</span><br><span class="line">echo $JAVA_HOME</span><br></pre></td></tr></table></figure></p><h3 id="2-2-安装tomcat"><a href="#2-2-安装tomcat" class="headerlink" title="2.2 安装tomcat"></a>2.2 安装tomcat</h3><p>下载<a href="http://apache.cs.utah.edu/tomcat/tomcat-8/v8.5.38/bin/apache-tomcat-8.5.38-fulldocs.tar.gz" target="_blank" rel="noopener">Tomcat8.5</a>至服务器，建议放在 /opt/ 目录下解压缩即可。</p><p>tomcat默认使用8080端口，可在conf/server.xml中配置端口，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector executor=&quot;tomcatThreadPool&quot;</span><br><span class="line">   port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">   connectionTimeout=&quot;20000&quot;</span><br><span class="line">   redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3-安装MySQL5-1数据库"><a href="#2-3-安装MySQL5-1数据库" class="headerlink" title="2.3 安装MySQL5.1数据库"></a>2.3 安装MySQL5.1数据库</h3><p>安装MySQL5.1数据库，使用可视化<a href="http://pic.blackist.top/spring-ar-deploy-path-NavicatPro.zip" target="_blank" rel="noopener">客户端Navicat等</a>新建ar数据库，编码utf-t，导入数据库表结构ar-mysql-data.sql。</p><p>如果数据库用户名密码和项目中<strong>ar-parent\ar-portal\src\main\resources\config.properties</strong>中不一致，则修改项目配置并重新编译上传服务器。</p><p><img src="http://pic.blackist.top/spring-ar-deploy-path-mysql-config.png" alt="校友录数据库"></p><h2 id="三、应用发布"><a href="#三、应用发布" class="headerlink" title="三、应用发布"></a>三、应用发布</h2><h3 id="3-1-war包发布"><a href="#3-1-war包发布" class="headerlink" title="3.1 war包发布"></a>3.1 war包发布</h3><p>war放在tomcat的webapps/目录下，执行tomcat/bin/下的./startup.sh，tomcat即可启动。</p><p>启动过程中可能出现异常，此时可监听tomcat日志，在tomcat/logs/下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f catalina.out</span><br></pre></td></tr></table></figure><p>监听到如下日志，说明项目启动成功：</p><p><img src="http://pic.blackist.top/spring-ar-deploy-path-project-init.png" alt="校友录启动"></p><h3 id="3-2-静态资源路径"><a href="#3-2-静态资源路径" class="headerlink" title="3.2 静态资源路径"></a>3.2 静态资源路径</h3><p>笔者最初开发的时候，jsp页面中采用如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">// 获取ar-portal</span><br><span class="line">String path = request.getContextPath();</span><br><span class="line">// 获取 http://localhost:8080/</span><br><span class="line">String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort()</span><br><span class="line">+ path + &quot;/&quot;;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p>如此，页面中的静态资源文件、a标签超链接和Form的action都以<a href>http://localhost:8080/ar-portal/</a>作为基础路径，在本地开发没有任何个问题，当部署到服务器时网站界面一篇空白，我的大脑一阵抽搐，知道肯定是路径出了问题。</p><p>经过排查就是这个basePath引起的，部署到公网服务器资源路径应该是<a href>http://公网ip:8080/ar-portal/</a>，可界面中静态资源等的路径依然是localhost…</p><p>解决路径问题较好的实践是在路径前加入项目环境路径</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">type</span>=<span class="string">"image/jpg"</span> <span class="attr">href</span>=<span class="string">"assets/images/logo/title-logo.jpg"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 静态资源路径加入Spring的环境路径 $&#123;pageContext.request.contextPath&#125; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">type</span>=<span class="string">"image/jpg"</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/assets/images/logo/title-logo.jpg"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"ta/show.action?userId=$&#123;member.userId&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"min-height: 125px;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"$&#123;member.portrait&#125;"</span> <span class="attr">class</span>=<span class="string">"img-responsive center-block"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">style</span>=<span class="string">"max-height: 125px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        $&#123;member.trueName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">type</span>=<span class="string">"image/jpg"</span> <span class="attr">href</span>=<span class="string">"assets/images/logo/title-logo.jpg"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- a标签超链接加入Spring的环境路径 $&#123;pageContext.request.contextPath&#125; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/ta/show.action?userId=$&#123;member.userId&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"min-height: 125px;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"$&#123;member.portrait&#125;"</span> <span class="attr">class</span>=<span class="string">"img-responsive center-block"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">style</span>=<span class="string">"max-height: 125px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        $&#123;member.trueName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-js中处理环境路径"><a href="#3-3-js中处理环境路径" class="headerlink" title="3.3 js中处理环境路径"></a>3.3 js中处理环境路径</h3><p>独立的js文件无法通过 ${pageContext.request.contextPath} 获取环境路径，可以通过location获取contextPath，如下getContextPath()可放在全局js中，这样在任意文件中都可以调用此方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取 contextPath</span><br><span class="line"> * @returns &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">function getContextPath() &#123;</span><br><span class="line">    var pathName = document.location.pathname;</span><br><span class="line">    var index = pathName.substr(1).indexOf(&quot;/&quot;);</span><br><span class="line">    var result = pathName.substr(0, index + 1);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$.post(&apos;classroom/joinClass.action&apos;, &#123;</span><br><span class="line">&quot;userId&quot; : userId,</span><br><span class="line">&quot;classId&quot; : classId</span><br><span class="line">&#125;, function(data) &#123;</span><br><span class="line">window.location.reload();</span><br><span class="line">&#125;);</span><br><span class="line">// 在ajax的url中加入环境路径</span><br><span class="line">$.post(getContextPath() + &apos;/classroom/joinClass.action&apos;, &#123;</span><br><span class="line">&quot;userId&quot; : userId,</span><br><span class="line">&quot;classId&quot; : classId</span><br><span class="line">&#125;, function(data) &#123;</span><br><span class="line">window.location.reload();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>整个项目jsp、js的路径翻修一通，那可真是酸爽。</p><h2 id="四、Nginx域名解析"><a href="#四、Nginx域名解析" class="headerlink" title="四、Nginx域名解析"></a>四、Nginx域名解析</h2><p>自行安装nginx软件，域名商控制台设置域名解析到服务器ip，在/etc/nginx/conf.d/下新建配置文件，文件名任意以.conf结尾即可，如tomcat.conf，配置文件中添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        server_name tomcat.blackist.top;</span><br><span class="line">        listen      80;</span><br><span class="line">        </span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http://localhost:8080;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即当通过域名访问时，访问被代理到本地tomcat的localhost:8080服务，通过域名<a href="http://tomcat.blackist.top/ar-portal/index.action" target="_blank" rel="noopener">http://tomcat.blackist.top/ar-portal</a>即可访问到部署在服务器上的Web应用。</p><hr><p>项目地址：<a href="https://github.com/blackist/ar" target="_blank" rel="noopener">https://github.com/blackist/ar</a></p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/blackist/ar&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;校友录&lt;/a&gt;作为一个具备门户网站服务、后台管理功能的完整项目，可以部署上线使用，线上部署需要注意些事项，本文就笔者的开发过程做个记录。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="https://blackist.org/categories/JavaWeb/"/>
    
    
      <category term="开发" scheme="https://blackist.org/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="javaweb" scheme="https://blackist.org/tags/javaweb/"/>
    
      <category term="开源" scheme="https://blackist.org/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="校友录" scheme="https://blackist.org/tags/%E6%A0%A1%E5%8F%8B%E5%BD%95/"/>
    
  </entry>
  
</feed>
